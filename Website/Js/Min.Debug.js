// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

var Base64 = (function () {
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

    var obj = {
        /**
         * Encodes a string in base64
         * @param {String} input The string to encode in base64.
         */
        encode: function (input) {
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;

            do {
                chr1 = input.charCodeAt(i++);
                chr2 = input.charCodeAt(i++);
                chr3 = input.charCodeAt(i++);

                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;

                if (isNaN(chr2)) {
                    enc3 = enc4 = 64;
                } else if (isNaN(chr3)) {
                    enc4 = 64;
                }

                output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) +
                    keyStr.charAt(enc3) + keyStr.charAt(enc4);
            } while (i < input.length);

            return output;
        },

        /**
         * Decodes a base64 string.
         * @param {String} input The string to decode.
         */
        decode: function (input) {
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;

            // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

            do {
                enc1 = keyStr.indexOf(input.charAt(i++));
                enc2 = keyStr.indexOf(input.charAt(i++));
                enc3 = keyStr.indexOf(input.charAt(i++));
                enc4 = keyStr.indexOf(input.charAt(i++));

                chr1 = (enc1 << 2) | (enc2 >> 4);
                chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                chr3 = ((enc3 & 3) << 6) | enc4;

                output = output + String.fromCharCode(chr1);

                if (enc3 != 64) {
                    output = output + String.fromCharCode(chr2);
                }
                if (enc4 != 64) {
                    output = output + String.fromCharCode(chr3);
                }
            } while (i < input.length);

            return output;
        }
    };

    return obj;
})();
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var MD5 = (function () {
    /*
     * Configurable variables. You may need to tweak these to be compatible with
     * the server-side, but the defaults work in most cases.
     */
    var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase */
    var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance */
    var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode */

    /*
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */
    var safe_add = function (x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    };

    /*
     * Bitwise rotate a 32-bit number to the left.
     */
    var bit_rol = function (num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    };

    /*
     * Convert a string to an array of little-endian words
     * If chrsz is ASCII, characters >255 have their hi-byte silently ignored.
     */
    var str2binl = function (str) {
        var bin = [];
        var mask = (1 << chrsz) - 1;
        for(var i = 0; i < str.length * chrsz; i += chrsz)
        {
            bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (i%32);
        }
        return bin;
    };

    /*
     * Convert an array of little-endian words to a string
     */
    var binl2str = function (bin) {
        var str = "";
        var mask = (1 << chrsz) - 1;
        for(var i = 0; i < bin.length * 32; i += chrsz)
        {
            str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & mask);
        }
        return str;
    };

    /*
     * Convert an array of little-endian words to a hex string.
     */
    var binl2hex = function (binarray) {
        var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
        var str = "";
        for(var i = 0; i < binarray.length * 4; i++)
        {
            str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +
                hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);
        }
        return str;
    };

    /*
     * Convert an array of little-endian words to a base-64 string
     */
    var binl2b64 = function (binarray) {
        var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var str = "";
        var triplet, j;
        for(var i = 0; i < binarray.length * 4; i += 3)
        {
            triplet = (((binarray[i   >> 2] >> 8 * ( i   %4)) & 0xFF) << 16) |
                (((binarray[i+1 >> 2] >> 8 * ((i+1)%4)) & 0xFF) << 8 ) |
                ((binarray[i+2 >> 2] >> 8 * ((i+2)%4)) & 0xFF);
            for(j = 0; j < 4; j++)
            {
                if(i * 8 + j * 6 > binarray.length * 32) { str += b64pad; }
                else { str += tab.charAt((triplet >> 6*(3-j)) & 0x3F); }
            }
        }
        return str;
    };

    /*
     * These functions implement the four basic operations the algorithm uses.
     */
    var md5_cmn = function (q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q),safe_add(x, t)), s),b);
    };

    var md5_ff = function (a, b, c, d, x, s, t) {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
    };

    var md5_gg = function (a, b, c, d, x, s, t) {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
    };

    var md5_hh = function (a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    };

    var md5_ii = function (a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
    };

    /*
     * Calculate the MD5 of an array of little-endian words, and a bit length
     */
    var core_md5 = function (x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << ((len) % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        var a =  1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d =  271733878;

        var olda, oldb, oldc, oldd;
        for (var i = 0; i < x.length; i += 16)
        {
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;

            a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
            d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
            b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
            d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
            c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
            d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
            d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

            a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
            d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
            c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
            b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
            a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
            d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
            c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
            d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
            c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
            a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
            d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
            c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
            b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

            a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
            d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
            b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
            d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
            c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
            d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
            c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
            a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
            d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
            b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

            a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
            d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
            c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
            d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
            d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
            a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
            d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
            b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
        }
        return [a, b, c, d];
    };


    /*
     * Calculate the HMAC-MD5, of a key and some data
     */
    var core_hmac_md5 = function (key, data) {
        var bkey = str2binl(key);
        if(bkey.length > 16) { bkey = core_md5(bkey, key.length * chrsz); }

        var ipad = new Array(16), opad = new Array(16);
        for(var i = 0; i < 16; i++)
        {
            ipad[i] = bkey[i] ^ 0x36363636;
            opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }

        var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz);
        return core_md5(opad.concat(hash), 512 + 128);
    };

    var obj = {
        /*
         * These are the functions you'll usually want to call.
         * They take string arguments and return either hex or base-64 encoded
         * strings.
         */
        hexdigest: function (s) {
            return binl2hex(core_md5(str2binl(s), s.length * chrsz));
        },

        b64digest: function (s) {
            return binl2b64(core_md5(str2binl(s), s.length * chrsz));
        },

        hash: function (s) {
            return binl2str(core_md5(str2binl(s), s.length * chrsz));
        },

        hmac_hexdigest: function (key, data) {
            return binl2hex(core_hmac_md5(key, data));
        },

        hmac_b64digest: function (key, data) {
            return binl2b64(core_hmac_md5(key, data));
        },

        hmac_hash: function (key, data) {
            return binl2str(core_hmac_md5(key, data));
        },

        /*
         * Perform a simple self-test to see if the VM is working
         */
        test: function () {
            return MD5.hexdigest("abc") === "900150983cd24fb0d6963f7d28e17f72";
        }
    };

    return obj;
})();
/*
    This program is distributed under the terms of the MIT license.
    Please see the LICENSE file for details.

    Copyright 2006-2008, OGG, LLC
*/

/* jslint configuration: */
/*global document, window, setTimeout, clearTimeout, console,
    XMLHttpRequest, ActiveXObject,
    Base64, MD5,
    Strophe, $build, $msg, $iq, $pres */

/** File: strophe.js
 *  A JavaScript library for XMPP BOSH.
 *
 *  This is the JavaScript version of the Strophe library.  Since JavaScript
 *  has no facilities for persistent TCP connections, this library uses
 *  Bidirectional-streams Over Synchronous HTTP (BOSH) to emulate
 *  a persistent, stateful, two-way connection to an XMPP server.  More
 *  information on BOSH can be found in XEP 124.
 */

/** PrivateFunction: Function.prototype.bind
 *  Bind a function to an instance.
 *
 *  This Function object extension method creates a bound method similar
 *  to those in Python.  This means that the 'this' object will point
 *  to the instance you want.  See
 *  <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind'>MDC's bind() documentation</a> and 
 *  <a href='http://benjamin.smedbergs.us/blog/2007-01-03/bound-functions-and-function-imports-in-javascript/'>Bound Functions and Function Imports in JavaScript</a>
 *  for a complete explanation.
 *
 *  This extension already exists in some browsers (namely, Firefox 3), but
 *  we provide it to support those that don't.
 *
 *  Parameters:
 *    (Object) obj - The object that will become 'this' in the bound function.
 *    (Object) argN - An option argument that will be prepended to the 
 *      arguments given for the function call
 *
 *  Returns:
 *    The bound function.
 */
if (!Function.prototype.bind) {
    Function.prototype.bind = function (obj /*, arg1, arg2, ... */)
    {
        var func = this;
        var _slice = Array.prototype.slice;
        var _concat = Array.prototype.concat;
        var _args = _slice.call(arguments, 1);
        
        return function () {
            return func.apply(obj ? obj : this,
                              _concat.call(_args,
                                           _slice.call(arguments, 0)));
        };
    };
}

/** PrivateFunction: Array.prototype.indexOf
 *  Return the index of an object in an array.
 *
 *  This function is not supplied by some JavaScript implementations, so
 *  we provide it if it is missing.  This code is from:
 *  http://developer.mozilla.org/En/Core_JavaScript_1.5_Reference:Objects:Array:indexOf
 *
 *  Parameters:
 *    (Object) elt - The object to look for.
 *    (Integer) from - The index from which to start looking. (optional).
 *
 *  Returns:
 *    The index of elt in the array or -1 if not found.
 */
if (!Array.prototype.indexOf)
{
    Array.prototype.indexOf = function(elt /*, from*/)
    {
        var len = this.length;

        var from = Number(arguments[1]) || 0;
        from = (from < 0) ? Math.ceil(from) : Math.floor(from);
        if (from < 0) {
            from += len;
        }

        for (; from < len; from++) {
            if (from in this && this[from] === elt) {
                return from;
            }
        }

        return -1;
    };
}

/* All of the Strophe globals are defined in this special function below so
 * that references to the globals become closures.  This will ensure that
 * on page reload, these references will still be available to callbacks
 * that are still executing.
 */

(function (callback) {
var Strophe;

/** Function: $build
 *  Create a Strophe.Builder.
 *  This is an alias for 'new Strophe.Builder(name, attrs)'.
 *
 *  Parameters:
 *    (String) name - The root element name.
 *    (Object) attrs - The attributes for the root element in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $build(name, attrs) { return new Strophe.Builder(name, attrs); }
/** Function: $msg
 *  Create a Strophe.Builder with a <message/> element as the root.
 *
 *  Parmaeters:
 *    (Object) attrs - The <message/> element attributes in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $msg(attrs) { return new Strophe.Builder("message", attrs); }
/** Function: $iq
 *  Create a Strophe.Builder with an <iq/> element as the root.
 *
 *  Parameters:
 *    (Object) attrs - The <iq/> element attributes in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $iq(attrs) { return new Strophe.Builder("iq", attrs); }
/** Function: $pres
 *  Create a Strophe.Builder with a <presence/> element as the root.
 *
 *  Parameters:
 *    (Object) attrs - The <presence/> element attributes in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $pres(attrs) { return new Strophe.Builder("presence", attrs); }

/** Class: Strophe
 *  An object container for all Strophe library functions.
 *
 *  This class is just a container for all the objects and constants
 *  used in the library.  It is not meant to be instantiated, but to
 *  provide a namespace for library objects, constants, and functions.
 */
Strophe = {
    /** Constant: VERSION
     *  The version of the Strophe library. Unreleased builds will have
     *  a version of head-HASH where HASH is a partial revision.
     */
    VERSION: "8d27954",

    /** Constants: XMPP Namespace Constants
     *  Common namespace constants from the XMPP RFCs and XEPs.
     *
     *  NS.HTTPBIND - HTTP BIND namespace from XEP 124.
     *  NS.BOSH - BOSH namespace from XEP 206.
     *  NS.CLIENT - Main XMPP client namespace.
     *  NS.AUTH - Legacy authentication namespace.
     *  NS.ROSTER - Roster operations namespace.
     *  NS.PROFILE - Profile namespace.
     *  NS.DISCO_INFO - Service discovery info namespace from XEP 30.
     *  NS.DISCO_ITEMS - Service discovery items namespace from XEP 30.
     *  NS.MUC - Multi-User Chat namespace from XEP 45.
     *  NS.SASL - XMPP SASL namespace from RFC 3920.
     *  NS.STREAM - XMPP Streams namespace from RFC 3920.
     *  NS.BIND - XMPP Binding namespace from RFC 3920.
     *  NS.SESSION - XMPP Session namespace from RFC 3920.
     */
    NS: {
        HTTPBIND: "http://jabber.org/protocol/httpbind",
        BOSH: "urn:xmpp:xbosh",
        CLIENT: "jabber:client",
        AUTH: "jabber:iq:auth",
        ROSTER: "jabber:iq:roster",
        PROFILE: "jabber:iq:profile",
        DISCO_INFO: "http://jabber.org/protocol/disco#info",
        DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
        MUC: "http://jabber.org/protocol/muc",
        SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
        STREAM: "http://etherx.jabber.org/streams",
        BIND: "urn:ietf:params:xml:ns:xmpp-bind",
        SESSION: "urn:ietf:params:xml:ns:xmpp-session",
        VERSION: "jabber:iq:version",
        STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas"
    },

    /** Function: addNamespace
     *  This function is used to extend the current namespaces in
     *	Strophe.NS.  It takes a key and a value with the key being the
     *	name of the new namespace, with its actual value.
     *	For example:
     *	Strophe.addNamespace('PUBSUB', "http://jabber.org/protocol/pubsub");
     *
     *  Parameters:
     *    (String) name - The name under which the namespace will be
     *      referenced under Strophe.NS
     *    (String) value - The actual namespace.
     */
    addNamespace: function (name, value)
    {
	Strophe.NS[name] = value;
    },

    /** Constants: Connection Status Constants
     *  Connection status constants for use by the connection handler
     *  callback.
     *
     *  Status.ERROR - An error has occurred
     *  Status.CONNECTING - The connection is currently being made
     *  Status.CONNFAIL - The connection attempt failed
     *  Status.AUTHENTICATING - The connection is authenticating
     *  Status.AUTHFAIL - The authentication attempt failed
     *  Status.CONNECTED - The connection has succeeded
     *  Status.DISCONNECTED - The connection has been terminated
     *  Status.DISCONNECTING - The connection is currently being terminated
     *  Status.ATTACHED - The connection has been attached
     */
    Status: {
        ERROR: 0,
        CONNECTING: 1,
        CONNFAIL: 2,
        AUTHENTICATING: 3,
        AUTHFAIL: 4,
        CONNECTED: 5,
        DISCONNECTED: 6,
        DISCONNECTING: 7,
        ATTACHED: 8
    },

    /** Constants: Log Level Constants
     *  Logging level indicators.
     *
     *  LogLevel.DEBUG - Debug output
     *  LogLevel.INFO - Informational output
     *  LogLevel.WARN - Warnings
     *  LogLevel.ERROR - Errors
     *  LogLevel.FATAL - Fatal errors
     */
    LogLevel: {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3,
        FATAL: 4
    },

    /** PrivateConstants: DOM Element Type Constants
     *  DOM element types.
     *
     *  ElementType.NORMAL - Normal element.
     *  ElementType.TEXT - Text data element.
     */
    ElementType: {
        NORMAL: 1,
        TEXT: 3,
        CDATA: 4
    },

    /** PrivateConstants: Timeout Values
     *  Timeout values for error states.  These values are in seconds.
     *  These should not be changed unless you know exactly what you are
     *  doing.
     *
     *  TIMEOUT - Timeout multiplier. A waiting request will be considered
     *      failed after Math.floor(TIMEOUT * wait) seconds have elapsed.
     *      This defaults to 1.1, and with default wait, 66 seconds.
     *  SECONDARY_TIMEOUT - Secondary timeout multiplier. In cases where
     *      Strophe can detect early failure, it will consider the request
     *      failed if it doesn't return after
     *      Math.floor(SECONDARY_TIMEOUT * wait) seconds have elapsed.
     *      This defaults to 0.1, and with default wait, 6 seconds.
     */
    TIMEOUT: 1.1,
    SECONDARY_TIMEOUT: 0.1,

    /** Function: forEachChild
     *  Map a function over some or all child elements of a given element.
     *
     *  This is a small convenience function for mapping a function over
     *  some or all of the children of an element.  If elemName is null, all
     *  children will be passed to the function, otherwise only children
     *  whose tag names match elemName will be passed.
     *
     *  Parameters:
     *    (XMLElement) elem - The element to operate on.
     *    (String) elemName - The child element tag name filter.
     *    (Function) func - The function to apply to each child.  This
     *      function should take a single argument, a DOM element.
     */
    forEachChild: function (elem, elemName, func)
    {
        var i, childNode;

        for (i = 0; i < elem.childNodes.length; i++) {
            childNode = elem.childNodes[i];
            if (childNode.nodeType == Strophe.ElementType.NORMAL &&
                (!elemName || this.isTagEqual(childNode, elemName))) {
                func(childNode);
            }
        }
    },

    /** Function: isTagEqual
     *  Compare an element's tag name with a string.
     *
     *  This function is case insensitive.
     *
     *  Parameters:
     *    (XMLElement) el - A DOM element.
     *    (String) name - The element name.
     *
     *  Returns:
     *    true if the element's tag name matches _el_, and false
     *    otherwise.
     */
    isTagEqual: function (el, name)
    {
        return el.tagName.toLowerCase() == name.toLowerCase();
    },

    /** PrivateVariable: _xmlGenerator
     *  _Private_ variable that caches a DOM document to
     *  generate elements.
     */
    _xmlGenerator: null,

    /** PrivateFunction: _makeGenerator
     *  _Private_ function that creates a dummy XML DOM document to serve as
     *  an element and text node generator.
     */
    _makeGenerator: function () {
        var doc;

        if (document.implementation.createDocument === undefined) {
            doc = this._getIEXmlDom();
            doc.appendChild(doc.createElement('strophe'));
        } else {
            doc = document.implementation
                .createDocument('jabber:client', 'strophe', null);
        }

        return doc;
    },

    /** Function: xmlGenerator
     *  Get the DOM document to generate elements.
     *
     *  Returns:
     *    The currently used DOM document.
     */
    xmlGenerator: function () {
        if (!Strophe._xmlGenerator) {
            Strophe._xmlGenerator = Strophe._makeGenerator();
        }
        return Strophe._xmlGenerator;
    },

    /** PrivateFunction: _getIEXmlDom
     *  Gets IE xml doc object
     *
     *  Returns:
     *    A Microsoft XML DOM Object
     *  See Also:
     *    http://msdn.microsoft.com/en-us/library/ms757837%28VS.85%29.aspx
     */
    _getIEXmlDom : function() {
        var doc = null;
        var docStrings = [
            "Msxml2.DOMDocument.6.0",
            "Msxml2.DOMDocument.5.0",
            "Msxml2.DOMDocument.4.0",
            "MSXML2.DOMDocument.3.0",
            "MSXML2.DOMDocument",
            "MSXML.DOMDocument",
            "Microsoft.XMLDOM"
        ];

        for (var d = 0; d < docStrings.length; d++) {
            if (doc === null) {
                try {
                    doc = new ActiveXObject(docStrings[d]);
                } catch (e) {
                    doc = null;
                }
            } else {
                break;
            }
        }

        return doc;
    },

    /** Function: xmlElement
     *  Create an XML DOM element.
     *
     *  This function creates an XML DOM element correctly across all
     *  implementations. Note that these are not HTML DOM elements, which
     *  aren't appropriate for XMPP stanzas.
     *
     *  Parameters:
     *    (String) name - The name for the element.
     *    (Array|Object) attrs - An optional array or object containing
     *      key/value pairs to use as element attributes. The object should
     *      be in the format {'key': 'value'} or {key: 'value'}. The array
     *      should have the format [['key1', 'value1'], ['key2', 'value2']].
     *    (String) text - The text child data for the element.
     *
     *  Returns:
     *    A new XML DOM element.
     */
    xmlElement: function (name)
    {
        if (!name) { return null; }

        var node = Strophe.xmlGenerator().createElement(name);

        // FIXME: this should throw errors if args are the wrong type or
        // there are more than two optional args
        var a, i, k;
        for (a = 1; a < arguments.length; a++) {
            if (!arguments[a]) { continue; }
            if (typeof(arguments[a]) == "string" ||
                typeof(arguments[a]) == "number") {
                node.appendChild(Strophe.xmlTextNode(arguments[a]));
            } else if (typeof(arguments[a]) == "object" &&
                       typeof(arguments[a].sort) == "function") {
                for (i = 0; i < arguments[a].length; i++) {
                    if (typeof(arguments[a][i]) == "object" &&
                        typeof(arguments[a][i].sort) == "function") {
                        node.setAttribute(arguments[a][i][0],
                                          arguments[a][i][1]);
                    }
                }
            } else if (typeof(arguments[a]) == "object") {
                for (k in arguments[a]) {
                    if (arguments[a].hasOwnProperty(k)) {
                        node.setAttribute(k, arguments[a][k]);
                    }
                }
            }
        }

        return node;
    },

    /*  Function: xmlescape
     *  Excapes invalid xml characters.
     *
     *  Parameters:
     *     (String) text - text to escape.
     *
     *	Returns:
     *      Escaped text.
     */
    xmlescape: function(text)
    {
        text = text.replace(/\&/g, "&amp;");
        text = text.replace(/</g,  "&lt;");
        text = text.replace(/>/g,  "&gt;");
        text = text.replace(/'/g,  "&apos;");
        text = text.replace(/"/g,  "&quot;");
        return text;
    },

    /** Function: xmlTextNode
     *  Creates an XML DOM text node.
     *
     *  Provides a cross implementation version of document.createTextNode.
     *
     *  Parameters:
     *    (String) text - The content of the text node.
     *
     *  Returns:
     *    A new XML DOM text node.
     */
    xmlTextNode: function (text)
    {
	//ensure text is escaped
	text = Strophe.xmlescape(text);

        return Strophe.xmlGenerator().createTextNode(text);
    },

    /** Function: getText
     *  Get the concatenation of all text children of an element.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    A String with the concatenated text of all text element children.
     */
    getText: function (elem)
    {
        if (!elem) { return null; }

        var str = "";
        if (elem.childNodes.length === 0 && elem.nodeType ==
            Strophe.ElementType.TEXT) {
            str += elem.nodeValue;
        }

        for (var i = 0; i < elem.childNodes.length; i++) {
            if (elem.childNodes[i].nodeType == Strophe.ElementType.TEXT) {
                str += elem.childNodes[i].nodeValue;
            }
        }

        return str;
    },

    /** Function: copyElement
     *  Copy an XML DOM element.
     *
     *  This function copies a DOM element and all its descendants and returns
     *  the new copy.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    A new, copied DOM element tree.
     */
    copyElement: function (elem)
    {
        var i, el;
        if (elem.nodeType == Strophe.ElementType.NORMAL) {
            el = Strophe.xmlElement(elem.tagName);

            for (i = 0; i < elem.attributes.length; i++) {
                el.setAttribute(elem.attributes[i].nodeName.toLowerCase(),
                                elem.attributes[i].value);
            }

            for (i = 0; i < elem.childNodes.length; i++) {
                el.appendChild(Strophe.copyElement(elem.childNodes[i]));
            }
        } else if (elem.nodeType == Strophe.ElementType.TEXT) {
            el = Strophe.xmlGenerator().createTextNode(elem.nodeValue);
        }

        return el;
    },

    /** Function: escapeNode
     *  Escape the node part (also called local part) of a JID.
     *
     *  Parameters:
     *    (String) node - A node (or local part).
     *
     *  Returns:
     *    An escaped node (or local part).
     */
    escapeNode: function (node)
    {
        return node.replace(/^\s+|\s+$/g, '')
            .replace(/\\/g,  "\\5c")
            .replace(/ /g,   "\\20")
            .replace(/\"/g,  "\\22")
            .replace(/\&/g,  "\\26")
            .replace(/\'/g,  "\\27")
            .replace(/\//g,  "\\2f")
            .replace(/:/g,   "\\3a")
            .replace(/</g,   "\\3c")
            .replace(/>/g,   "\\3e")
            .replace(/@/g,   "\\40");
    },

    /** Function: unescapeNode
     *  Unescape a node part (also called local part) of a JID.
     *
     *  Parameters:
     *    (String) node - A node (or local part).
     *
     *  Returns:
     *    An unescaped node (or local part).
     */
    unescapeNode: function (node)
    {
        return node.replace(/\\20/g, " ")
            .replace(/\\22/g, '"')
            .replace(/\\26/g, "&")
            .replace(/\\27/g, "'")
            .replace(/\\2f/g, "/")
            .replace(/\\3a/g, ":")
            .replace(/\\3c/g, "<")
            .replace(/\\3e/g, ">")
            .replace(/\\40/g, "@")
            .replace(/\\5c/g, "\\");
    },

    /** Function: getNodeFromJid
     *  Get the node portion of a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the node.
     */
    getNodeFromJid: function (jid)
    {
        if (jid.indexOf("@") < 0) { return null; }
        return jid.split("@")[0];
    },

    /** Function: getDomainFromJid
     *  Get the domain portion of a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the domain.
     */
    getDomainFromJid: function (jid)
    {
        var bare = Strophe.getBareJidFromJid(jid);
        if (bare.indexOf("@") < 0) {
            return bare;
        } else {
            var parts = bare.split("@");
            parts.splice(0, 1);
            return parts.join('@');
        }
    },

    /** Function: getResourceFromJid
     *  Get the resource portion of a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the resource.
     */
    getResourceFromJid: function (jid)
    {
        var s = jid.split("/");
        if (s.length < 2) { return null; }
        s.splice(0, 1);
        return s.join('/');
    },

    /** Function: getBareJidFromJid
     *  Get the bare JID from a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the bare JID.
     */
    getBareJidFromJid: function (jid)
    {
        return jid ? jid.split("/")[0] : null;
    },

    /** Function: log
     *  User overrideable logging function.
     *
     *  This function is called whenever the Strophe library calls any
     *  of the logging functions.  The default implementation of this
     *  function does nothing.  If client code wishes to handle the logging
     *  messages, it should override this with
     *  > Strophe.log = function (level, msg) {
     *  >   (user code here)
     *  > };
     *
     *  Please note that data sent and received over the wire is logged
     *  via Strophe.Connection.rawInput() and Strophe.Connection.rawOutput().
     *
     *  The different levels and their meanings are
     *
     *    DEBUG - Messages useful for debugging purposes.
     *    INFO - Informational messages.  This is mostly information like
     *      'disconnect was called' or 'SASL auth succeeded'.
     *    WARN - Warnings about potential problems.  This is mostly used
     *      to report transient connection errors like request timeouts.
     *    ERROR - Some error occurred.
     *    FATAL - A non-recoverable fatal error occurred.
     *
     *  Parameters:
     *    (Integer) level - The log level of the log message.  This will
     *      be one of the values in Strophe.LogLevel.
     *    (String) msg - The log message.
     */
    log: function (level, msg)
    {
        return;
    },

    /** Function: debug
     *  Log a message at the Strophe.LogLevel.DEBUG level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    debug: function(msg)
    {
        this.log(this.LogLevel.DEBUG, msg);
    },

    /** Function: info
     *  Log a message at the Strophe.LogLevel.INFO level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    info: function (msg)
    {
        this.log(this.LogLevel.INFO, msg);
    },

    /** Function: warn
     *  Log a message at the Strophe.LogLevel.WARN level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    warn: function (msg)
    {
        this.log(this.LogLevel.WARN, msg);
    },

    /** Function: error
     *  Log a message at the Strophe.LogLevel.ERROR level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    error: function (msg)
    {
        this.log(this.LogLevel.ERROR, msg);
    },

    /** Function: fatal
     *  Log a message at the Strophe.LogLevel.FATAL level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    fatal: function (msg)
    {
        this.log(this.LogLevel.FATAL, msg);
    },

    /** Function: serialize
     *  Render a DOM element and all descendants to a String.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    The serialized element tree as a String.
     */
    serialize: function (elem)
    {
        var result;

        if (!elem) { return null; }

        if (typeof(elem.tree) === "function") {
            elem = elem.tree();
        }

        var nodeName = elem.nodeName;
        var i, child;

        if (elem.getAttribute("_realname")) {
            nodeName = elem.getAttribute("_realname");
        }

        result = "<" + nodeName;
        for (i = 0; i < elem.attributes.length; i++) {
               if(elem.attributes[i].nodeName != "_realname") {
                 result += " " + elem.attributes[i].nodeName.toLowerCase() +
                "='" + elem.attributes[i].value
                    .replace(/&/g, "&amp;")
                       .replace(/\'/g, "&apos;")
                       .replace(/</g, "&lt;") + "'";
               }
        }

        if (elem.childNodes.length > 0) {
            result += ">";
            for (i = 0; i < elem.childNodes.length; i++) {
                child = elem.childNodes[i];
                switch( child.nodeType ){
                  case Strophe.ElementType.NORMAL:
                    // normal element, so recurse
                    result += Strophe.serialize(child);
                    break;
                  case Strophe.ElementType.TEXT:
                    // text element to escape values
                    result += child.nodeValue;
                    break;
                  case Strophe.ElementType.CDATA:
                    // cdata section so don't escape values
                    result += "<![CDATA["+child.nodeValue+"]]>";
                }
            }
            result += "</" + nodeName + ">";
        } else {
            result += "/>";
        }

        return result;
    },

    /** PrivateVariable: _requestId
     *  _Private_ variable that keeps track of the request ids for
     *  connections.
     */
    _requestId: 0,

    /** PrivateVariable: Strophe.connectionPlugins
     *  _Private_ variable Used to store plugin names that need
     *  initialization on Strophe.Connection construction.
     */
    _connectionPlugins: {},

    /** Function: addConnectionPlugin
     *  Extends the Strophe.Connection object with the given plugin.
     *
     *  Parameters:
     *    (String) name - The name of the extension.
     *    (Object) ptype - The plugin's prototype.
     */
    addConnectionPlugin: function (name, ptype)
    {
        Strophe._connectionPlugins[name] = ptype;
    }
};

/** Class: Strophe.Builder
 *  XML DOM builder.
 *
 *  This object provides an interface similar to JQuery but for building
 *  DOM element easily and rapidly.  All the functions except for toString()
 *  and tree() return the object, so calls can be chained.  Here's an
 *  example using the $iq() builder helper.
 *  > $iq({to: 'you', from: 'me', type: 'get', id: '1'})
 *  >     .c('query', {xmlns: 'strophe:example'})
 *  >     .c('example')
 *  >     .toString()
 *  The above generates this XML fragment
 *  > <iq to='you' from='me' type='get' id='1'>
 *  >   <query xmlns='strophe:example'>
 *  >     <example/>
 *  >   </query>
 *  > </iq>
 *  The corresponding DOM manipulations to get a similar fragment would be
 *  a lot more tedious and probably involve several helper variables.
 *
 *  Since adding children makes new operations operate on the child, up()
 *  is provided to traverse up the tree.  To add two children, do
 *  > builder.c('child1', ...).up().c('child2', ...)
 *  The next operation on the Builder will be relative to the second child.
 */

/** Constructor: Strophe.Builder
 *  Create a Strophe.Builder object.
 *
 *  The attributes should be passed in object notation.  For example
 *  > var b = new Builder('message', {to: 'you', from: 'me'});
 *  or
 *  > var b = new Builder('messsage', {'xml:lang': 'en'});
 *
 *  Parameters:
 *    (String) name - The name of the root element.
 *    (Object) attrs - The attributes for the root element in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder.
 */
Strophe.Builder = function (name, attrs)
{
    // Set correct namespace for jabber:client elements
    if (name == "presence" || name == "message" || name == "iq") {
        if (attrs && !attrs.xmlns) {
            attrs.xmlns = Strophe.NS.CLIENT;
        } else if (!attrs) {
            attrs = {xmlns: Strophe.NS.CLIENT};
        }
    }

    // Holds the tree being built.
    this.nodeTree = Strophe.xmlElement(name, attrs);

    // Points to the current operation node.
    this.node = this.nodeTree;
};

Strophe.Builder.prototype = {
    /** Function: tree
     *  Return the DOM tree.
     *
     *  This function returns the current DOM tree as an element object.  This
     *  is suitable for passing to functions like Strophe.Connection.send().
     *
     *  Returns:
     *    The DOM tree as a element object.
     */
    tree: function ()
    {
        return this.nodeTree;
    },

    /** Function: toString
     *  Serialize the DOM tree to a String.
     *
     *  This function returns a string serialization of the current DOM
     *  tree.  It is often used internally to pass data to a
     *  Strophe.Request object.
     *
     *  Returns:
     *    The serialized DOM tree in a String.
     */
    toString: function ()
    {
        return Strophe.serialize(this.nodeTree);
    },

    /** Function: up
     *  Make the current parent element the new current element.
     *
     *  This function is often used after c() to traverse back up the tree.
     *  For example, to add two children to the same element
     *  > builder.c('child1', {}).up().c('child2', {});
     *
     *  Returns:
     *    The Stophe.Builder object.
     */
    up: function ()
    {
        this.node = this.node.parentNode;
        return this;
    },

    /** Function: attrs
     *  Add or modify attributes of the current element.
     *
     *  The attributes should be passed in object notation.  This function
     *  does not move the current element pointer.
     *
     *  Parameters:
     *    (Object) moreattrs - The attributes to add/modify in object notation.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    attrs: function (moreattrs)
    {
        for (var k in moreattrs) {
            if (moreattrs.hasOwnProperty(k)) {
                this.node.setAttribute(k, moreattrs[k]);
            }
        }
        return this;
    },

    /** Function: c
     *  Add a child to the current element and make it the new current
     *  element.
     *
     *  This function moves the current element pointer to the child,
     *  unless text is provided.  If you need to add another child, it
     *  is necessary to use up() to go back to the parent in the tree.
     *
     *  Parameters:
     *    (String) name - The name of the child.
     *    (Object) attrs - The attributes of the child in object notation.
     *    (String) text - The text to add to the child.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    c: function (name, attrs, text)
    {
        var child = Strophe.xmlElement(name, attrs, text);
        this.node.appendChild(child);
        if (!text) {
            this.node = child;
        }
        return this;
    },

    /** Function: cnode
     *  Add a child to the current element and make it the new current
     *  element.
     *
     *  This function is the same as c() except that instead of using a
     *  name and an attributes object to create the child it uses an
     *  existing DOM element object.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    cnode: function (elem)
    {
        var xmlGen = Strophe.xmlGenerator();
        try {
            var impNode = (xmlGen.importNode !== undefined);
        }
        catch (e) {
            var impNode = false;
        }
        var newElem = impNode ?
                      xmlGen.importNode(elem, true) :
                      Strophe.copyElement(elem);
        this.node.appendChild(newElem);
        this.node = newElem;
        return this;
    },

    /** Function: t
     *  Add a child text element.
     *
     *  This *does not* make the child the new current element since there
     *  are no children of text elements.
     *
     *  Parameters:
     *    (String) text - The text data to append to the current element.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    t: function (text)
    {
        var child = Strophe.xmlTextNode(text);
        this.node.appendChild(child);
        return this;
    }
};


/** PrivateClass: Strophe.Handler
 *  _Private_ helper class for managing stanza handlers.
 *
 *  A Strophe.Handler encapsulates a user provided callback function to be
 *  executed when matching stanzas are received by the connection.
 *  Handlers can be either one-off or persistant depending on their
 *  return value. Returning true will cause a Handler to remain active, and
 *  returning false will remove the Handler.
 *
 *  Users will not use Strophe.Handler objects directly, but instead they
 *  will use Strophe.Connection.addHandler() and
 *  Strophe.Connection.deleteHandler().
 */

/** PrivateConstructor: Strophe.Handler
 *  Create and initialize a new Strophe.Handler.
 *
 *  Parameters:
 *    (Function) handler - A function to be executed when the handler is run.
 *    (String) ns - The namespace to match.
 *    (String) name - The element name to match.
 *    (String) type - The element type to match.
 *    (String) id - The element id attribute to match.
 *    (String) from - The element from attribute to match.
 *    (Object) options - Handler options
 *
 *  Returns:
 *    A new Strophe.Handler object.
 */
Strophe.Handler = function (handler, ns, name, type, id, from, options)
{
    this.handler = handler;
    this.ns = ns;
    this.name = name;
    this.type = type;
    this.id = id;
    this.options = options || {matchbare: false};

    // default matchBare to false if undefined
    if (!this.options.matchBare) {
        this.options.matchBare = false;
    }

    if (this.options.matchBare) {
        this.from = from ? Strophe.getBareJidFromJid(from) : null;
    } else {
        this.from = from;
    }

    // whether the handler is a user handler or a system handler
    this.user = true;
};

Strophe.Handler.prototype = {
    /** PrivateFunction: isMatch
     *  Tests if a stanza matches the Strophe.Handler.
     *
     *  Parameters:
     *    (XMLElement) elem - The XML element to test.
     *
     *  Returns:
     *    true if the stanza matches and false otherwise.
     */
    isMatch: function (elem)
    {
        var nsMatch;
        var from = null;

        if (this.options.matchBare) {
            from = Strophe.getBareJidFromJid(elem.getAttribute('from'));
        } else {
            from = elem.getAttribute('from');
        }

        nsMatch = false;
        if (!this.ns) {
            nsMatch = true;
        } else {
            var that = this;
            Strophe.forEachChild(elem, null, function (elem) {
                if (elem.getAttribute("xmlns") == that.ns) {
                    nsMatch = true;
                }
            });

            nsMatch = nsMatch || elem.getAttribute("xmlns") == this.ns;
        }

        if (nsMatch &&
            (!this.name || Strophe.isTagEqual(elem, this.name)) &&
            (!this.type || elem.getAttribute("type") == this.type) &&
            (!this.id || elem.getAttribute("id") == this.id) &&
            (!this.from || from == this.from)) {
                return true;
        }

        return false;
    },

    /** PrivateFunction: run
     *  Run the callback on a matching stanza.
     *
     *  Parameters:
     *    (XMLElement) elem - The DOM element that triggered the
     *      Strophe.Handler.
     *
     *  Returns:
     *    A boolean indicating if the handler should remain active.
     */
    run: function (elem)
    {
        var result = null;
        try {
            result = this.handler(elem);
        } catch (e) {
            if (e.sourceURL) {
                Strophe.fatal("error: " + this.handler +
                              " " + e.sourceURL + ":" +
                              e.line + " - " + e.name + ": " + e.message);
            } else if (e.fileName) {
                if (typeof(console) != "undefined") {
                    console.trace();
                    console.error(this.handler, " - error - ", e, e.message);
                }
                Strophe.fatal("error: " + this.handler + " " +
                              e.fileName + ":" + e.lineNumber + " - " +
                              e.name + ": " + e.message);
            } else {
                Strophe.fatal("error: " + this.handler);
            }

            throw e;
        }

        return result;
    },

    /** PrivateFunction: toString
     *  Get a String representation of the Strophe.Handler object.
     *
     *  Returns:
     *    A String.
     */
    toString: function ()
    {
        return "{Handler: " + this.handler + "(" + this.name + "," +
            this.id + "," + this.ns + ")}";
    }
};

/** PrivateClass: Strophe.TimedHandler
 *  _Private_ helper class for managing timed handlers.
 *
 *  A Strophe.TimedHandler encapsulates a user provided callback that
 *  should be called after a certain period of time or at regular
 *  intervals.  The return value of the callback determines whether the
 *  Strophe.TimedHandler will continue to fire.
 *
 *  Users will not use Strophe.TimedHandler objects directly, but instead
 *  they will use Strophe.Connection.addTimedHandler() and
 *  Strophe.Connection.deleteTimedHandler().
 */

/** PrivateConstructor: Strophe.TimedHandler
 *  Create and initialize a new Strophe.TimedHandler object.
 *
 *  Parameters:
 *    (Integer) period - The number of milliseconds to wait before the
 *      handler is called.
 *    (Function) handler - The callback to run when the handler fires.  This
 *      function should take no arguments.
 *
 *  Returns:
 *    A new Strophe.TimedHandler object.
 */
Strophe.TimedHandler = function (period, handler)
{
    this.period = period;
    this.handler = handler;

    this.lastCalled = new Date().getTime();
    this.user = true;
};

Strophe.TimedHandler.prototype = {
    /** PrivateFunction: run
     *  Run the callback for the Strophe.TimedHandler.
     *
     *  Returns:
     *    true if the Strophe.TimedHandler should be called again, and false
     *      otherwise.
     */
    run: function ()
    {
        this.lastCalled = new Date().getTime();
        return this.handler();
    },

    /** PrivateFunction: reset
     *  Reset the last called time for the Strophe.TimedHandler.
     */
    reset: function ()
    {
        this.lastCalled = new Date().getTime();
    },

    /** PrivateFunction: toString
     *  Get a string representation of the Strophe.TimedHandler object.
     *
     *  Returns:
     *    The string representation.
     */
    toString: function ()
    {
        return "{TimedHandler: " + this.handler + "(" + this.period +")}";
    }
};

/** PrivateClass: Strophe.Request
 *  _Private_ helper class that provides a cross implementation abstraction
 *  for a BOSH related XMLHttpRequest.
 *
 *  The Strophe.Request class is used internally to encapsulate BOSH request
 *  information.  It is not meant to be used from user's code.
 */

/** PrivateConstructor: Strophe.Request
 *  Create and initialize a new Strophe.Request object.
 *
 *  Parameters:
 *    (XMLElement) elem - The XML data to be sent in the request.
 *    (Function) func - The function that will be called when the
 *      XMLHttpRequest readyState changes.
 *    (Integer) rid - The BOSH rid attribute associated with this request.
 *    (Integer) sends - The number of times this same request has been
 *      sent.
 */
Strophe.Request = function (elem, func, rid, sends)
{
    this.id = ++Strophe._requestId;
    this.xmlData = elem;
    this.data = Strophe.serialize(elem);
    // save original function in case we need to make a new request
    // from this one.
    this.origFunc = func;
    this.func = func;
    this.rid = rid;
    this.date = NaN;
    this.sends = sends || 0;
    this.abort = false;
    this.dead = null;
    this.age = function () {
        if (!this.date) { return 0; }
        var now = new Date();
        return (now - this.date) / 1000;
    };
    this.timeDead = function () {
        if (!this.dead) { return 0; }
        var now = new Date();
        return (now - this.dead) / 1000;
    };
    this.xhr = this._newXHR();
};

Strophe.Request.prototype = {
    /** PrivateFunction: getResponse
     *  Get a response from the underlying XMLHttpRequest.
     *
     *  This function attempts to get a response from the request and checks
     *  for errors.
     *
     *  Throws:
     *    "parsererror" - A parser error occured.
     *
     *  Returns:
     *    The DOM element tree of the response.
     */
    getResponse: function ()
    {
        var node = null;
        if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
            node = this.xhr.responseXML.documentElement;
            if (node.tagName == "parsererror") {
                Strophe.error("invalid response received");
                Strophe.error("responseText: " + this.xhr.responseText);
                Strophe.error("responseXML: " +
                              Strophe.serialize(this.xhr.responseXML));
                throw "parsererror";
            }
        } else if (this.xhr.responseText) {
            Strophe.error("invalid response received");
            Strophe.error("responseText: " + this.xhr.responseText);
            Strophe.error("responseXML: " +
                          Strophe.serialize(this.xhr.responseXML));
        }

        return node;
    },

    /** PrivateFunction: _newXHR
     *  _Private_ helper function to create XMLHttpRequests.
     *
     *  This function creates XMLHttpRequests across all implementations.
     *
     *  Returns:
     *    A new XMLHttpRequest.
     */
    _newXHR: function ()
    {
        var xhr = null;
        if (window.XMLHttpRequest) {
            xhr = new XMLHttpRequest();
            if (xhr.overrideMimeType) {
                xhr.overrideMimeType("text/xml");
            }
        } else if (window.ActiveXObject) {
            xhr = new ActiveXObject("Microsoft.XMLHTTP");
        }

        // use Function.bind() to prepend ourselves as an argument
        xhr.onreadystatechange = this.func.bind(null, this);

        return xhr;
    }
};

/** Class: Strophe.Connection
 *  XMPP Connection manager.
 *
 *  Thie class is the main part of Strophe.  It manages a BOSH connection
 *  to an XMPP server and dispatches events to the user callbacks as
 *  data arrives.  It supports SASL PLAIN, SASL DIGEST-MD5, and legacy
 *  authentication.
 *
 *  After creating a Strophe.Connection object, the user will typically
 *  call connect() with a user supplied callback to handle connection level
 *  events like authentication failure, disconnection, or connection
 *  complete.
 *
 *  The user will also have several event handlers defined by using
 *  addHandler() and addTimedHandler().  These will allow the user code to
 *  respond to interesting stanzas or do something periodically with the
 *  connection.  These handlers will be active once authentication is
 *  finished.
 *
 *  To send data to the connection, use send().
 */

/** Constructor: Strophe.Connection
 *  Create and initialize a Strophe.Connection object.
 *
 *  Parameters:
 *    (String) service - The BOSH service URL.
 *
 *  Returns:
 *    A new Strophe.Connection object.
 */
Strophe.Connection = function (service)
{
    /* The path to the httpbind service. */
    this.service = service;
    /* The connected JID. */
    this.jid = "";
    /* request id for body tags */
    this.rid = Math.floor(Math.random() * 4294967295);
    /* The current session ID. */
    this.sid = null;
    this.streamId = null;
    /* stream:features */
    this.features = null;

    // SASL
    this.do_session = false;
    this.do_bind = false;

    // handler lists
    this.timedHandlers = [];
    this.handlers = [];
    this.removeTimeds = [];
    this.removeHandlers = [];
    this.addTimeds = [];
    this.addHandlers = [];

    this._idleTimeout = null;
    this._disconnectTimeout = null;

    this.authenticated = false;
    this.disconnecting = false;
    this.connected = false;

    this.errors = 0;

    this.paused = false;

    // default BOSH values
    this.hold = 1;
    this.wait = 60;
    this.window = 5;

    this._data = [];
    this._requests = [];
    this._uniqueId = Math.round(Math.random() * 10000);

    this._sasl_success_handler = null;
    this._sasl_failure_handler = null;
    this._sasl_challenge_handler = null;

    // setup onIdle callback every 1/10th of a second
    this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);

    // initialize plugins
    for (var k in Strophe._connectionPlugins) {
        if (Strophe._connectionPlugins.hasOwnProperty(k)) {
	    var ptype = Strophe._connectionPlugins[k];
            // jslint complaints about the below line, but this is fine
            var F = function () {};
            F.prototype = ptype;
            this[k] = new F();
	    this[k].init(this);
        }
    }
};

Strophe.Connection.prototype = {
    /** Function: reset
     *  Reset the connection.
     *
     *  This function should be called after a connection is disconnected
     *  before that connection is reused.
     */
    reset: function ()
    {
        this.rid = Math.floor(Math.random() * 4294967295);

        this.sid = null;
        this.streamId = null;

        // SASL
        this.do_session = false;
        this.do_bind = false;

        // handler lists
        this.timedHandlers = [];
        this.handlers = [];
        this.removeTimeds = [];
        this.removeHandlers = [];
        this.addTimeds = [];
        this.addHandlers = [];

        this.authenticated = false;
        this.disconnecting = false;
        this.connected = false;

        this.errors = 0;

        this._requests = [];
        this._uniqueId = Math.round(Math.random()*10000);
    },

    /** Function: pause
     *  Pause the request manager.
     *
     *  This will prevent Strophe from sending any more requests to the
     *  server.  This is very useful for temporarily pausing while a lot
     *  of send() calls are happening quickly.  This causes Strophe to
     *  send the data in a single request, saving many request trips.
     */
    pause: function ()
    {
        this.paused = true;
    },

    /** Function: resume
     *  Resume the request manager.
     *
     *  This resumes after pause() has been called.
     */
    resume: function ()
    {
        this.paused = false;
    },

    /** Function: getUniqueId
     *  Generate a unique ID for use in <iq/> elements.
     *
     *  All <iq/> stanzas are required to have unique id attributes.  This
     *  function makes creating these easy.  Each connection instance has
     *  a counter which starts from zero, and the value of this counter
     *  plus a colon followed by the suffix becomes the unique id. If no
     *  suffix is supplied, the counter is used as the unique id.
     *
     *  Suffixes are used to make debugging easier when reading the stream
     *  data, and their use is recommended.  The counter resets to 0 for
     *  every new connection for the same reason.  For connections to the
     *  same server that authenticate the same way, all the ids should be
     *  the same, which makes it easy to see changes.  This is useful for
     *  automated testing as well.
     *
     *  Parameters:
     *    (String) suffix - A optional suffix to append to the id.
     *
     *  Returns:
     *    A unique string to be used for the id attribute.
     */
    getUniqueId: function (suffix)
    {
        if (typeof(suffix) == "string" || typeof(suffix) == "number") {
            return ++this._uniqueId + ":" + suffix;
        } else {
            return ++this._uniqueId + "";
        }
    },

    /** Function: connect
     *  Starts the connection process.
     *
     *  As the connection process proceeds, the user supplied callback will
     *  be triggered multiple times with status updates.  The callback
     *  should take two arguments - the status code and the error condition.
     *
     *  The status code will be one of the values in the Strophe.Status
     *  constants.  The error condition will be one of the conditions
     *  defined in RFC 3920 or the condition 'strophe-parsererror'.
     *
     *  Please see XEP 124 for a more detailed explanation of the optional
     *  parameters below.
     *
     *  Parameters:
     *    (String) jid - The user's JID.  This may be a bare JID,
     *      or a full JID.  If a node is not supplied, SASL ANONYMOUS
     *      authentication will be attempted.
     *    (String) pass - The user's password.
     *    (Function) callback - The connect callback function.
     *    (Integer) wait - The optional HTTPBIND wait value.  This is the
     *      time the server will wait before returning an empty result for
     *      a request.  The default setting of 60 seconds is recommended.
     *      Other settings will require tweaks to the Strophe.TIMEOUT value.
     *    (Integer) hold - The optional HTTPBIND hold value.  This is the
     *      number of connections the server will hold at one time.  This
     *      should almost always be set to 1 (the default).
     */
    connect: function (jid, pass, callback, wait, hold)
    {
        this.jid = jid;
        this.pass = pass;
        this.connect_callback = callback;
        this.disconnecting = false;
        this.connected = false;
        this.authenticated = false;
        this.errors = 0;

        this.wait = wait || this.wait;
        this.hold = hold || this.hold;

        // parse jid for domain and resource
        this.domain = Strophe.getDomainFromJid(this.jid);

        // build the body tag
        var body = this._buildBody().attrs({
            to: this.domain,
            "xml:lang": "en",
            wait: this.wait,
            hold: this.hold,
            content: "text/xml; charset=utf-8",
            ver: "1.6",
            "xmpp:version": "1.0",
            "xmlns:xmpp": Strophe.NS.BOSH
        });

        this._changeConnectStatus(Strophe.Status.CONNECTING, null);

        this._requests.push(
            new Strophe.Request(body.tree(),
                                this._onRequestStateChange.bind(
                                    this, this._connect_cb.bind(this)),
                                body.tree().getAttribute("rid")));
        this._throttledRequestHandler();
    },

    /** Function: attach
     *  Attach to an already created and authenticated BOSH session.
     *
     *  This function is provided to allow Strophe to attach to BOSH
     *  sessions which have been created externally, perhaps by a Web
     *  application.  This is often used to support auto-login type features
     *  without putting user credentials into the page.
     *
     *  Parameters:
     *    (String) jid - The full JID that is bound by the session.
     *    (String) sid - The SID of the BOSH session.
     *    (String) rid - The current RID of the BOSH session.  This RID
     *      will be used by the next request.
     *    (Function) callback The connect callback function.
     *    (Integer) wait - The optional HTTPBIND wait value.  This is the
     *      time the server will wait before returning an empty result for
     *      a request.  The default setting of 60 seconds is recommended.
     *      Other settings will require tweaks to the Strophe.TIMEOUT value.
     *    (Integer) hold - The optional HTTPBIND hold value.  This is the
     *      number of connections the server will hold at one time.  This
     *      should almost always be set to 1 (the default).
     *    (Integer) wind - The optional HTTBIND window value.  This is the
     *      allowed range of request ids that are valid.  The default is 5.
     */
    attach: function (jid, sid, rid, callback, wait, hold, wind)
    {
        this.jid = jid;
        this.sid = sid;
        this.rid = rid;
        this.connect_callback = callback;

        this.domain = Strophe.getDomainFromJid(this.jid);

        this.authenticated = true;
        this.connected = true;

        this.wait = wait || this.wait;
        this.hold = hold || this.hold;
        this.window = wind || this.window;

        this._changeConnectStatus(Strophe.Status.ATTACHED, null);
    },

    /** Function: xmlInput
     *  User overrideable function that receives XML data coming into the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.xmlInput = function (elem) {
     *  >   (user code)
     *  > };
     *
     *  Parameters:
     *    (XMLElement) elem - The XML data received by the connection.
     */
    xmlInput: function (elem)
    {
        return;
    },

    /** Function: xmlOutput
     *  User overrideable function that receives XML data sent to the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.xmlOutput = function (elem) {
     *  >   (user code)
     *  > };
     *
     *  Parameters:
     *    (XMLElement) elem - The XMLdata sent by the connection.
     */
    xmlOutput: function (elem)
    {
        return;
    },

    /** Function: rawInput
     *  User overrideable function that receives raw data coming into the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.rawInput = function (data) {
     *  >   (user code)
     *  > };
     *
     *  Parameters:
     *    (String) data - The data received by the connection.
     */
    rawInput: function (data)
    {
        return;
    },

    /** Function: rawOutput
     *  User overrideable function that receives raw data sent to the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.rawOutput = function (data) {
     *  >   (user code)
     *  > };
     *
     *  Parameters:
     *    (String) data - The data sent by the connection.
     */
    rawOutput: function (data)
    {
        return;
    },

    /** Function: send
     *  Send a stanza.
     *
     *  This function is called to push data onto the send queue to
     *  go out over the wire.  Whenever a request is sent to the BOSH
     *  server, all pending data is sent and the queue is flushed.
     *
     *  Parameters:
     *    (XMLElement |
     *     [XMLElement] |
     *     Strophe.Builder) elem - The stanza to send.
     */
    send: function (elem)
    {
        if (elem === null) { return ; }
        if (typeof(elem.sort) === "function") {
            for (var i = 0; i < elem.length; i++) {
                this._queueData(elem[i]);
            }
        } else if (typeof(elem.tree) === "function") {
            this._queueData(elem.tree());
        } else {
            this._queueData(elem);
        }

        this._throttledRequestHandler();
        clearTimeout(this._idleTimeout);
        this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);
    },

    /** Function: flush
     *  Immediately send any pending outgoing data.
     *
     *  Normally send() queues outgoing data until the next idle period
     *  (100ms), which optimizes network use in the common cases when
     *  several send()s are called in succession. flush() can be used to
     *  immediately send all pending data.
     */
    flush: function ()
    {
        // cancel the pending idle period and run the idle function
        // immediately
        clearTimeout(this._idleTimeout);
        this._onIdle();
    },

    /** Function: sendIQ
     *  Helper function to send IQ stanzas.
     *
     *  Parameters:
     *    (XMLElement) elem - The stanza to send.
     *    (Function) callback - The callback function for a successful request.
     *    (Function) errback - The callback function for a failed or timed
     *      out request.  On timeout, the stanza will be null.
     *    (Integer) timeout - The time specified in milliseconds for a
     *      timeout to occur.
     *
     *  Returns:
     *    The id used to send the IQ.
    */
    sendIQ: function(elem, callback, errback, timeout) {
        var timeoutHandler = null;
        var that = this;

        if (typeof(elem.tree) === "function") {
            elem = elem.tree();
        }
	var id = elem.getAttribute('id');

	// inject id if not found
	if (!id) {
	    id = this.getUniqueId("sendIQ");
	    elem.setAttribute("id", id);
	}

	var handler = this.addHandler(function (stanza) {
	    // remove timeout handler if there is one
            if (timeoutHandler) {
                that.deleteTimedHandler(timeoutHandler);
            }

            var iqtype = stanza.getAttribute('type');
	    if (iqtype == 'result') {
		if (callback) {
                    callback(stanza);
                }
	    } else if (iqtype == 'error') {
		if (errback) {
                    errback(stanza);
                }
	    } else {
                throw {
                    name: "StropheError",
                    message: "Got bad IQ type of " + iqtype
                };
            }
	}, null, 'iq', null, id);

	// if timeout specified, setup timeout handler.
	if (timeout) {
	    timeoutHandler = this.addTimedHandler(timeout, function () {
                // get rid of normal handler
                that.deleteHandler(handler);

	        // call errback on timeout with null stanza
                if (errback) {
		    errback(null);
                }
		return false;
	    });
	}

	this.send(elem);

	return id;
    },

    /** PrivateFunction: _queueData
     *  Queue outgoing data for later sending.  Also ensures that the data
     *  is a DOMElement.
     */
    _queueData: function (element) {
        if (element === null ||
            !element.tagName ||
            !element.childNodes) {
            throw {
                name: "StropheError",
                message: "Cannot queue non-DOMElement."
            };
        }

        this._data.push(element);
    },

    /** PrivateFunction: _sendRestart
     *  Send an xmpp:restart stanza.
     */
    _sendRestart: function ()
    {
        this._data.push("restart");

        this._throttledRequestHandler();
        clearTimeout(this._idleTimeout);
        this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);
    },

    /** Function: addTimedHandler
     *  Add a timed handler to the connection.
     *
     *  This function adds a timed handler.  The provided handler will
     *  be called every period milliseconds until it returns false,
     *  the connection is terminated, or the handler is removed.  Handlers
     *  that wish to continue being invoked should return true.
     *
     *  Because of method binding it is necessary to save the result of
     *  this function if you wish to remove a handler with
     *  deleteTimedHandler().
     *
     *  Note that user handlers are not active until authentication is
     *  successful.
     *
     *  Parameters:
     *    (Integer) period - The period of the handler.
     *    (Function) handler - The callback function.
     *
     *  Returns:
     *    A reference to the handler that can be used to remove it.
     */
    addTimedHandler: function (period, handler)
    {
        var thand = new Strophe.TimedHandler(period, handler);
        this.addTimeds.push(thand);
        return thand;
    },

    /** Function: deleteTimedHandler
     *  Delete a timed handler for a connection.
     *
     *  This function removes a timed handler from the connection.  The
     *  handRef parameter is *not* the function passed to addTimedHandler(),
     *  but is the reference returned from addTimedHandler().
     *
     *  Parameters:
     *    (Strophe.TimedHandler) handRef - The handler reference.
     */
    deleteTimedHandler: function (handRef)
    {
        // this must be done in the Idle loop so that we don't change
        // the handlers during iteration
        this.removeTimeds.push(handRef);
    },

    /** Function: addHandler
     *  Add a stanza handler for the connection.
     *
     *  This function adds a stanza handler to the connection.  The
     *  handler callback will be called for any stanza that matches
     *  the parameters.  Note that if multiple parameters are supplied,
     *  they must all match for the handler to be invoked.
     *
     *  The handler will receive the stanza that triggered it as its argument.
     *  The handler should return true if it is to be invoked again;
     *  returning false will remove the handler after it returns.
     *
     *  As a convenience, the ns parameters applies to the top level element
     *  and also any of its immediate children.  This is primarily to make
     *  matching /iq/query elements easy.
     *
     *  The options argument contains handler matching flags that affect how
     *  matches are determined. Currently the only flag is matchBare (a
     *  boolean). When matchBare is true, the from parameter and the from
     *  attribute on the stanza will be matched as bare JIDs instead of
     *  full JIDs. To use this, pass {matchBare: true} as the value of
     *  options. The default value for matchBare is false.
     *
     *  The return value should be saved if you wish to remove the handler
     *  with deleteHandler().
     *
     *  Parameters:
     *    (Function) handler - The user callback.
     *    (String) ns - The namespace to match.
     *    (String) name - The stanza name to match.
     *    (String) type - The stanza type attribute to match.
     *    (String) id - The stanza id attribute to match.
     *    (String) from - The stanza from attribute to match.
     *    (String) options - The handler options
     *
     *  Returns:
     *    A reference to the handler that can be used to remove it.
     */
    addHandler: function (handler, ns, name, type, id, from, options)
    {
        var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);
        this.addHandlers.push(hand);
        return hand;
    },

    /** Function: deleteHandler
     *  Delete a stanza handler for a connection.
     *
     *  This function removes a stanza handler from the connection.  The
     *  handRef parameter is *not* the function passed to addHandler(),
     *  but is the reference returned from addHandler().
     *
     *  Parameters:
     *    (Strophe.Handler) handRef - The handler reference.
     */
    deleteHandler: function (handRef)
    {
        // this must be done in the Idle loop so that we don't change
        // the handlers during iteration
        this.removeHandlers.push(handRef);
    },

    /** Function: disconnect
     *  Start the graceful disconnection process.
     *
     *  This function starts the disconnection process.  This process starts
     *  by sending unavailable presence and sending BOSH body of type
     *  terminate.  A timeout handler makes sure that disconnection happens
     *  even if the BOSH server does not respond.
     *
     *  The user supplied connection callback will be notified of the
     *  progress as this process happens.
     *
     *  Parameters:
     *    (String) reason - The reason the disconnect is occuring.
     */
    disconnect: function (reason)
    {
        this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);

        Strophe.info("Disconnect was called because: " + reason);
        if (this.connected) {
            // setup timeout handler
            this._disconnectTimeout = this._addSysTimedHandler(
                3000, this._onDisconnectTimeout.bind(this));
            this._sendTerminate();
        }
    },

    /** PrivateFunction: _changeConnectStatus
     *  _Private_ helper function that makes sure plugins and the user's
     *  callback are notified of connection status changes.
     *
     *  Parameters:
     *    (Integer) status - the new connection status, one of the values
     *      in Strophe.Status
     *    (String) condition - the error condition or null
     */
    _changeConnectStatus: function (status, condition)
    {
        // notify all plugins listening for status changes
        for (var k in Strophe._connectionPlugins) {
            if (Strophe._connectionPlugins.hasOwnProperty(k)) {
                var plugin = this[k];
                if (plugin.statusChanged) {
                    try {
                        plugin.statusChanged(status, condition);
                    } catch (err) {
                        Strophe.error("" + k + " plugin caused an exception " +
                                      "changing status: " + err);
                    }
                }
            }
        }

        // notify the user's callback
        if (this.connect_callback) {
            try {
                this.connect_callback(status, condition);
            } catch (e) {
                Strophe.error("User connection callback caused an " +
                              "exception: " + e);
            }
        }
    },

    /** PrivateFunction: _buildBody
     *  _Private_ helper function to generate the <body/> wrapper for BOSH.
     *
     *  Returns:
     *    A Strophe.Builder with a <body/> element.
     */
    _buildBody: function ()
    {
        var bodyWrap = $build('body', {
            rid: this.rid++,
            xmlns: Strophe.NS.HTTPBIND
        });

        if (this.sid !== null) {
            bodyWrap.attrs({sid: this.sid});
        }

        return bodyWrap;
    },

    /** PrivateFunction: _removeRequest
     *  _Private_ function to remove a request from the queue.
     *
     *  Parameters:
     *    (Strophe.Request) req - The request to remove.
     */
    _removeRequest: function (req)
    {
        Strophe.debug("removing request");

        var i;
        for (i = this._requests.length - 1; i >= 0; i--) {
            if (req == this._requests[i]) {
                this._requests.splice(i, 1);
            }
        }

        // IE6 fails on setting to null, so set to empty function
        req.xhr.onreadystatechange = function () {};

        this._throttledRequestHandler();
    },

    /** PrivateFunction: _restartRequest
     *  _Private_ function to restart a request that is presumed dead.
     *
     *  Parameters:
     *    (Integer) i - The index of the request in the queue.
     */
    _restartRequest: function (i)
    {
        var req = this._requests[i];
        if (req.dead === null) {
            req.dead = new Date();
        }

        this._processRequest(i);
    },

    /** PrivateFunction: _processRequest
     *  _Private_ function to process a request in the queue.
     *
     *  This function takes requests off the queue and sends them and
     *  restarts dead requests.
     *
     *  Parameters:
     *    (Integer) i - The index of the request in the queue.
     */
    _processRequest: function (i)
    {
        var req = this._requests[i];
        var reqStatus = -1;

        try {
            if (req.xhr.readyState == 4) {
                reqStatus = req.xhr.status;
            }
        } catch (e) {
            Strophe.error("caught an error in _requests[" + i +
                          "], reqStatus: " + reqStatus);
        }

        if (typeof(reqStatus) == "undefined") {
            reqStatus = -1;
        }

        // make sure we limit the number of retries
        if (req.sends > 5) {
            this._onDisconnectTimeout();
            return;
        }

        var time_elapsed = req.age();
        var primaryTimeout = (!isNaN(time_elapsed) &&
                              time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait));
        var secondaryTimeout = (req.dead !== null &&
                                req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait));
        var requestCompletedWithServerError = (req.xhr.readyState == 4 &&
                                               (reqStatus < 1 ||
                                                reqStatus >= 500));
        if (primaryTimeout || secondaryTimeout ||
            requestCompletedWithServerError) {
            if (secondaryTimeout) {
                Strophe.error("Request " +
                              this._requests[i].id +
                              " timed out (secondary), restarting");
            }
            req.abort = true;
            req.xhr.abort();
            // setting to null fails on IE6, so set to empty function
            req.xhr.onreadystatechange = function () {};
            this._requests[i] = new Strophe.Request(req.xmlData,
                                                    req.origFunc,
                                                    req.rid,
                                                    req.sends);
            req = this._requests[i];
        }

        if (req.xhr.readyState === 0) {
            Strophe.debug("request id " + req.id +
                          "." + req.sends + " posting");

            try {
				var async = !('sync' in this && this.sync === true);
				req.xhr.open("POST", this.service, async);
			} catch (e2) {
                Strophe.error("XHR open failed.");
                if (!this.connected) {
                    this._changeConnectStatus(Strophe.Status.CONNFAIL,
                                              "bad-service");
                }
                this.disconnect();
                return;
            }

            // Fires the XHR request -- may be invoked immediately
            // or on a gradually expanding retry window for reconnects
            var sendFunc = function () {
                req.date = new Date();
                req.xhr.send(req.data);
            };

            // Implement progressive backoff for reconnects --
            // First retry (send == 1) should also be instantaneous
            if (req.sends > 1) {
                // Using a cube of the retry number creates a nicely
                // expanding retry window
                var backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait),
                                       Math.pow(req.sends, 3)) * 1000;
                setTimeout(sendFunc, backoff);
            } else {
                sendFunc();
            }

            req.sends++;

            if (this.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {
                this.xmlOutput(req.xmlData);
            }
            if (this.rawOutput !== Strophe.Connection.prototype.rawOutput) {
                this.rawOutput(req.data);
            }
        } else {
            Strophe.debug("_processRequest: " +
                          (i === 0 ? "first" : "second") +
                          " request has readyState of " +
                          req.xhr.readyState);
        }
    },

    /** PrivateFunction: _throttledRequestHandler
     *  _Private_ function to throttle requests to the connection window.
     *
     *  This function makes sure we don't send requests so fast that the
     *  request ids overflow the connection window in the case that one
     *  request died.
     */
    _throttledRequestHandler: function ()
    {
        if (!this._requests) {
            Strophe.debug("_throttledRequestHandler called with " +
                          "undefined requests");
        } else {
            Strophe.debug("_throttledRequestHandler called with " +
                          this._requests.length + " requests");
        }

        if (!this._requests || this._requests.length === 0) {
            return;
        }

        if (this._requests.length > 0) {
            this._processRequest(0);
        }

        if (this._requests.length > 1 &&
            Math.abs(this._requests[0].rid -
                     this._requests[1].rid) < this.window) {
            this._processRequest(1);
        }
    },

    /** PrivateFunction: _onRequestStateChange
     *  _Private_ handler for Strophe.Request state changes.
     *
     *  This function is called when the XMLHttpRequest readyState changes.
     *  It contains a lot of error handling logic for the many ways that
     *  requests can fail, and calls the request callback when requests
     *  succeed.
     *
     *  Parameters:
     *    (Function) func - The handler for the request.
     *    (Strophe.Request) req - The request that is changing readyState.
     */
    _onRequestStateChange: function (func, req)
    {
        Strophe.debug("request id " + req.id +
                      "." + req.sends + " state changed to " +
                      req.xhr.readyState);

        if (req.abort) {
            req.abort = false;
            return;
        }

        // request complete
        var reqStatus;
        if (req.xhr.readyState == 4) {
            reqStatus = 0;
            try {
                reqStatus = req.xhr.status;
            } catch (e) {
                // ignore errors from undefined status attribute.  works
                // around a browser bug
            }

            if (typeof(reqStatus) == "undefined") {
                reqStatus = 0;
            }

            if (this.disconnecting) {
                if (reqStatus >= 400) {
                    this._hitError(reqStatus);
                    return;
                }
            }

            var reqIs0 = (this._requests[0] == req);
            var reqIs1 = (this._requests[1] == req);

            if ((reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
                // remove from internal queue
                this._removeRequest(req);
                Strophe.debug("request id " +
                              req.id +
                              " should now be removed");
            }

            // request succeeded
            if (reqStatus == 200) {
                // if request 1 finished, or request 0 finished and request
                // 1 is over Strophe.SECONDARY_TIMEOUT seconds old, we need to
                // restart the other - both will be in the first spot, as the
                // completed request has been removed from the queue already
                if (reqIs1 ||
                    (reqIs0 && this._requests.length > 0 &&
                     this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait))) {
                    this._restartRequest(0);
                }
                // call handler
                Strophe.debug("request id " +
                              req.id + "." +
                              req.sends + " got 200");
                func(req);
                this.errors = 0;
            } else {
                Strophe.error("request id " +
                              req.id + "." +
                              req.sends + " error " + reqStatus +
                              " happened");
                if (reqStatus === 0 ||
                    (reqStatus >= 400 && reqStatus < 600) ||
                    reqStatus >= 12000) {
                    this._hitError(reqStatus);
                    if (reqStatus >= 400 && reqStatus < 500) {
                        this._changeConnectStatus(Strophe.Status.DISCONNECTING,
                                                  null);
                        this._doDisconnect();
                    }
                }
            }

            if (!((reqStatus > 0 && reqStatus < 500) ||
                  req.sends > 5)) {
                this._throttledRequestHandler();
            }
        }
    },

    /** PrivateFunction: _hitError
     *  _Private_ function to handle the error count.
     *
     *  Requests are resent automatically until their error count reaches
     *  5.  Each time an error is encountered, this function is called to
     *  increment the count and disconnect if the count is too high.
     *
     *  Parameters:
     *    (Integer) reqStatus - The request status.
     */
    _hitError: function (reqStatus)
    {
        this.errors++;
        Strophe.warn("request errored, status: " + reqStatus +
                     ", number of errors: " + this.errors);
        if (this.errors > 4) {
            this._onDisconnectTimeout();
        }
    },

    /** PrivateFunction: _doDisconnect
     *  _Private_ function to disconnect.
     *
     *  This is the last piece of the disconnection logic.  This resets the
     *  connection and alerts the user's connection callback.
     */
    _doDisconnect: function ()
    {
        Strophe.info("_doDisconnect was called");
        this.authenticated = false;
        this.disconnecting = false;
        this.sid = null;
        this.streamId = null;
        this.rid = Math.floor(Math.random() * 4294967295);

        // tell the parent we disconnected
        if (this.connected) {
            this._changeConnectStatus(Strophe.Status.DISCONNECTED, null);
            this.connected = false;
        }

        // delete handlers
        this.handlers = [];
        this.timedHandlers = [];
        this.removeTimeds = [];
        this.removeHandlers = [];
        this.addTimeds = [];
        this.addHandlers = [];
    },

    /** PrivateFunction: _dataRecv
     *  _Private_ handler to processes incoming data from the the connection.
     *
     *  Except for _connect_cb handling the initial connection request,
     *  this function handles the incoming data for all requests.  This
     *  function also fires stanza handlers that match each incoming
     *  stanza.
     *
     *  Parameters:
     *    (Strophe.Request) req - The request that has data ready.
     */
    _dataRecv: function (req)
    {
        try {
            var elem = req.getResponse();
        } catch (e) {
            if (e != "parsererror") { throw e; }
            this.disconnect("strophe-parsererror");
        }
        if (elem === null) { return; }

        if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
            this.xmlInput(elem);
        }
        if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
            this.rawInput(Strophe.serialize(elem));
        }

        // remove handlers scheduled for deletion
        var i, hand;
        while (this.removeHandlers.length > 0) {
            hand = this.removeHandlers.pop();
            i = this.handlers.indexOf(hand);
            if (i >= 0) {
                this.handlers.splice(i, 1);
            }
        }

        // add handlers scheduled for addition
        while (this.addHandlers.length > 0) {
            this.handlers.push(this.addHandlers.pop());
        }

        // handle graceful disconnect
        if (this.disconnecting && this._requests.length === 0) {
            this.deleteTimedHandler(this._disconnectTimeout);
            this._disconnectTimeout = null;
            this._doDisconnect();
            return;
        }

        var typ = elem.getAttribute("type");
        var cond, conflict;
        if (typ !== null && typ == "terminate") {
            // Don't process stanzas that come in after disconnect
            if (this.disconnecting) {
                return;
            }

            // an error occurred
            cond = elem.getAttribute("condition");
            conflict = elem.getElementsByTagName("conflict");
            if (cond !== null) {
                if (cond == "remote-stream-error" && conflict.length > 0) {
                    cond = "conflict";
                }
                this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
            } else {
                this._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
            }
            this.disconnect();
            return;
        }

        // send each incoming stanza through the handler chain
        var that = this;
        Strophe.forEachChild(elem, null, function (child) {
            var i, newList;
            // process handlers
            newList = that.handlers;
            that.handlers = [];
            for (i = 0; i < newList.length; i++) {
                var hand = newList[i];
                // encapsulate 'handler.run' not to lose the whole handler list if
                // one of the handlers throws an exception
                try {
                    if (hand.isMatch(child) &&
                        (that.authenticated || !hand.user)) {
                        if (hand.run(child)) {
                            that.handlers.push(hand);
                        }
                    } else {
                        that.handlers.push(hand);
                    }
                } catch(e) {
                    //if the handler throws an exception, we consider it as false
                }
            }
        });
    },

    /** PrivateFunction: _sendTerminate
     *  _Private_ function to send initial disconnect sequence.
     *
     *  This is the first step in a graceful disconnect.  It sends
     *  the BOSH server a terminate body and includes an unavailable
     *  presence if authentication has completed.
     */
    _sendTerminate: function ()
    {
        Strophe.info("_sendTerminate was called");
        var body = this._buildBody().attrs({type: "terminate"});

        if (this.authenticated) {
            body.c('presence', {
                xmlns: Strophe.NS.CLIENT,
                type: 'unavailable'
            });
        }

        this.disconnecting = true;

        var req = new Strophe.Request(body.tree(),
                                      this._onRequestStateChange.bind(
                                          this, this._dataRecv.bind(this)),
                                      body.tree().getAttribute("rid"));

        this._requests.push(req);
        this._throttledRequestHandler();
    },

    /** PrivateFunction: _connect_cb
     *  _Private_ handler for initial connection request.
     *
     *  This handler is used to process the initial connection request
     *  response from the BOSH server. It is used to set up authentication
     *  handlers and start the authentication process.
     *
     *  SASL authentication will be attempted if available, otherwise
     *  the code will fall back to legacy authentication.
     *
     *  Parameters:
     *    (Strophe.Request) req - The current request.
     */
    _connect_cb: function (req)
    {
        Strophe.info("_connect_cb was called");

        this.connected = true;
        var bodyWrap = req.getResponse();
        if (!bodyWrap) { return; }

        if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
            this.xmlInput(bodyWrap);
        }
        if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
            this.rawInput(Strophe.serialize(bodyWrap));
        }

        var typ = bodyWrap.getAttribute("type");
        var cond, conflict;
        if (typ !== null && typ == "terminate") {
            // an error occurred
            cond = bodyWrap.getAttribute("condition");
            conflict = bodyWrap.getElementsByTagName("conflict");
            if (cond !== null) {
                if (cond == "remote-stream-error" && conflict.length > 0) {
                    cond = "conflict";
                }
                this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
            } else {
                this._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
            }
            return;
        }

        // check to make sure we don't overwrite these if _connect_cb is
        // called multiple times in the case of missing stream:features
        if (!this.sid) {
            this.sid = bodyWrap.getAttribute("sid");
        }
        if (!this.stream_id) {
            this.stream_id = bodyWrap.getAttribute("authid");
        }
        var wind = bodyWrap.getAttribute('requests');
        if (wind) { this.window = parseInt(wind, 10); }
        var hold = bodyWrap.getAttribute('hold');
        if (hold) { this.hold = parseInt(hold, 10); }
        var wait = bodyWrap.getAttribute('wait');
        if (wait) { this.wait = parseInt(wait, 10); }


        var do_sasl_plain = false;
        var do_sasl_digest_md5 = false;
        var do_sasl_anonymous = false;

        var mechanisms = bodyWrap.getElementsByTagName("mechanism");
        var i, mech, auth_str, hashed_auth_str;
        if (mechanisms.length > 0) {
            for (i = 0; i < mechanisms.length; i++) {
                mech = Strophe.getText(mechanisms[i]);
                if (mech == 'DIGEST-MD5') {
                    do_sasl_digest_md5 = true;
                } else if (mech == 'PLAIN') {
                    do_sasl_plain = true;
                } else if (mech == 'ANONYMOUS') {
                    do_sasl_anonymous = true;
                }
            }
        } else {
            // we didn't get stream:features yet, so we need wait for it
            // by sending a blank poll request
            var body = this._buildBody();
            this._requests.push(
                new Strophe.Request(body.tree(),
                                    this._onRequestStateChange.bind(
                                        this, this._connect_cb.bind(this)),
                                    body.tree().getAttribute("rid")));
            this._throttledRequestHandler();
            return;
        }

        if (Strophe.getNodeFromJid(this.jid) === null &&
            do_sasl_anonymous) {
            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
            this._sasl_success_handler = this._addSysHandler(
                this._sasl_success_cb.bind(this), null,
                "success", null, null);
            this._sasl_failure_handler = this._addSysHandler(
                this._sasl_failure_cb.bind(this), null,
                "failure", null, null);

            this.send($build("auth", {
                xmlns: Strophe.NS.SASL,
                mechanism: "ANONYMOUS"
            }).tree());
        } else if (Strophe.getNodeFromJid(this.jid) === null) {
            // we don't have a node, which is required for non-anonymous
            // client connections
            this._changeConnectStatus(Strophe.Status.CONNFAIL,
                                      'x-strophe-bad-non-anon-jid');
            this.disconnect();
        } else if (do_sasl_digest_md5) {
            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
            this._sasl_challenge_handler = this._addSysHandler(
                this._sasl_challenge1_cb.bind(this), null,
                "challenge", null, null);
            this._sasl_failure_handler = this._addSysHandler(
                this._sasl_failure_cb.bind(this), null,
                "failure", null, null);

            this.send($build("auth", {
                xmlns: Strophe.NS.SASL,
                mechanism: "DIGEST-MD5"
            }).tree());
        } else if (do_sasl_plain) {
            // Build the plain auth string (barejid null
            // username null password) and base 64 encoded.
            auth_str = unescape(encodeURIComponent(Strophe.getBareJidFromJid(this.jid)));
            auth_str = auth_str + "\u0000";
            auth_str = auth_str + unescape(encodeURIComponent(Strophe.getNodeFromJid(this.jid)));
            auth_str = auth_str + "\u0000";
            auth_str = auth_str + this.pass;

            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
            this._sasl_success_handler = this._addSysHandler(
                this._sasl_success_cb.bind(this), null,
                "success", null, null);
            this._sasl_failure_handler = this._addSysHandler(
                this._sasl_failure_cb.bind(this), null,
                "failure", null, null);

            hashed_auth_str = Base64.encode(auth_str);
            this.send($build("auth", {
                xmlns: Strophe.NS.SASL,
                mechanism: "PLAIN"
            }).t(hashed_auth_str).tree());
        } else {
            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
            this._addSysHandler(this._auth1_cb.bind(this), null, null,
                                null, "_auth_1");

            this.send($iq({
                type: "get",
                to: this.domain,
                id: "_auth_1"
            }).c("query", {
                xmlns: Strophe.NS.AUTH
            }).c("username", {}).t(Strophe.getNodeFromJid(this.jid)).tree());
        }
    },

    /** PrivateFunction: _sasl_challenge1_cb
     *  _Private_ handler for DIGEST-MD5 SASL authentication.
     *
     *  Parameters:
     *    (XMLElement) elem - The challenge stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_challenge1_cb: function (elem)
    {
        var attribMatch = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/;

        var challenge = Base64.decode(Strophe.getText(elem));
        var cnonce = MD5.hexdigest("" + (Math.random() * 1234567890));
        var realm = "";
        var host = null;
        var nonce = "";
        var qop = "";
        var matches;

        // remove unneeded handlers
        this.deleteHandler(this._sasl_failure_handler);

        while (challenge.match(attribMatch)) {
            matches = challenge.match(attribMatch);
            challenge = challenge.replace(matches[0], "");
            matches[2] = matches[2].replace(/^"(.+)"$/, "$1");
            switch (matches[1]) {
            case "realm":
                realm = matches[2];
                break;
            case "nonce":
                nonce = matches[2];
                break;
            case "qop":
                qop = matches[2];
                break;
            case "host":
                host = matches[2];
                break;
            }
        }

        var digest_uri = "xmpp/" + this.domain;
        if (host !== null) {
            digest_uri = digest_uri + "/" + host;
        }

        var A1 = MD5.hash(unescape(encodeURIComponent(Strophe.getNodeFromJid(this.jid))) +
                          ":" + realm + ":" + this.pass) +
            ":" + nonce + ":" + cnonce;
        var A2 = 'AUTHENTICATE:' + digest_uri;

        var responseText = "";
        responseText += 'username=' +
            this._quote(unescape(encodeURIComponent(Strophe.getNodeFromJid(this.jid)))) + ',';
        responseText += 'realm=' + this._quote(realm) + ',';
        responseText += 'nonce=' + this._quote(nonce) + ',';
        responseText += 'cnonce=' + this._quote(cnonce) + ',';
        responseText += 'nc="00000001",';
        responseText += 'qop="auth",';
        responseText += 'digest-uri=' + this._quote(digest_uri) + ',';
        responseText += 'response=' + this._quote(
            MD5.hexdigest(MD5.hexdigest(A1) + ":" +
                          nonce + ":00000001:" +
                          cnonce + ":auth:" +
                          MD5.hexdigest(A2))) + ',';
        responseText += 'charset="utf-8"';

        this._sasl_challenge_handler = this._addSysHandler(
            this._sasl_challenge2_cb.bind(this), null,
            "challenge", null, null);
        this._sasl_success_handler = this._addSysHandler(
            this._sasl_success_cb.bind(this), null,
            "success", null, null);
        this._sasl_failure_handler = this._addSysHandler(
            this._sasl_failure_cb.bind(this), null,
            "failure", null, null);

        this.send($build('response', {
            xmlns: Strophe.NS.SASL
        }).t(Base64.encode(responseText)).tree());

        return false;
    },

    /** PrivateFunction: _quote
     *  _Private_ utility function to backslash escape and quote strings.
     *
     *  Parameters:
     *    (String) str - The string to be quoted.
     *
     *  Returns:
     *    quoted string
     */
    _quote: function (str)
    {
        return '"' + str.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
        //" end string workaround for emacs
    },


    /** PrivateFunction: _sasl_challenge2_cb
     *  _Private_ handler for second step of DIGEST-MD5 SASL authentication.
     *
     *  Parameters:
     *    (XMLElement) elem - The challenge stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_challenge2_cb: function (elem)
    {
        // remove unneeded handlers
        this.deleteHandler(this._sasl_success_handler);
        this.deleteHandler(this._sasl_failure_handler);

        this._sasl_success_handler = this._addSysHandler(
            this._sasl_success_cb.bind(this), null,
            "success", null, null);
        this._sasl_failure_handler = this._addSysHandler(
            this._sasl_failure_cb.bind(this), null,
            "failure", null, null);
        this.send($build('response', {xmlns: Strophe.NS.SASL}).tree());
        return false;
    },

    /** PrivateFunction: _auth1_cb
     *  _Private_ handler for legacy authentication.
     *
     *  This handler is called in response to the initial <iq type='get'/>
     *  for legacy authentication.  It builds an authentication <iq/> and
     *  sends it, creating a handler (calling back to _auth2_cb()) to
     *  handle the result
     *
     *  Parameters:
     *    (XMLElement) elem - The stanza that triggered the callback.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _auth1_cb: function (elem)
    {
        // build plaintext auth iq
        var iq = $iq({type: "set", id: "_auth_2"})
            .c('query', {xmlns: Strophe.NS.AUTH})
            .c('username', {}).t(Strophe.getNodeFromJid(this.jid))
            .up()
            .c('password').t(this.pass);

        if (!Strophe.getResourceFromJid(this.jid)) {
            // since the user has not supplied a resource, we pick
            // a default one here.  unlike other auth methods, the server
            // cannot do this for us.
            this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe';
        }
        iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));

        this._addSysHandler(this._auth2_cb.bind(this), null,
                            null, null, "_auth_2");

        this.send(iq.tree());

        return false;
    },

    /** PrivateFunction: _sasl_success_cb
     *  _Private_ handler for succesful SASL authentication.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_success_cb: function (elem)
    {
        Strophe.info("SASL authentication succeeded.");

        // remove old handlers
        this.deleteHandler(this._sasl_failure_handler);
        this._sasl_failure_handler = null;
        if (this._sasl_challenge_handler) {
            this.deleteHandler(this._sasl_challenge_handler);
            this._sasl_challenge_handler = null;
        }

        this._addSysHandler(this._sasl_auth1_cb.bind(this), null,
                            "stream:features", null, null);

        // we must send an xmpp:restart now
        this._sendRestart();

        return false;
    },

    /** PrivateFunction: _sasl_auth1_cb
     *  _Private_ handler to start stream binding.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_auth1_cb: function (elem)
    {
        // save stream:features for future usage
        this.features = elem;

        var i, child;

        for (i = 0; i < elem.childNodes.length; i++) {
            child = elem.childNodes[i];
            if (child.nodeName == 'bind') {
                this.do_bind = true;
            }

            if (child.nodeName == 'session') {
                this.do_session = true;
            }
        }

        if (!this.do_bind) {
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false;
        } else {
            this._addSysHandler(this._sasl_bind_cb.bind(this), null, null,
                                null, "_bind_auth_2");

            var resource = Strophe.getResourceFromJid(this.jid);
            if (resource) {
                this.send($iq({type: "set", id: "_bind_auth_2"})
                          .c('bind', {xmlns: Strophe.NS.BIND})
                          .c('resource', {}).t(resource).tree());
            } else {
                this.send($iq({type: "set", id: "_bind_auth_2"})
                          .c('bind', {xmlns: Strophe.NS.BIND})
                          .tree());
            }
        }

        return false;
    },

    /** PrivateFunction: _sasl_bind_cb
     *  _Private_ handler for binding result and session start.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_bind_cb: function (elem)
    {
        if (elem.getAttribute("type") == "error") {
            Strophe.info("SASL binding failed.");
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false;
        }

        // TODO - need to grab errors
        var bind = elem.getElementsByTagName("bind");
        var jidNode;
        if (bind.length > 0) {
            // Grab jid
            jidNode = bind[0].getElementsByTagName("jid");
            if (jidNode.length > 0) {
                this.jid = Strophe.getText(jidNode[0]);

                if (this.do_session) {
                    this._addSysHandler(this._sasl_session_cb.bind(this),
                                        null, null, null, "_session_auth_2");

                    this.send($iq({type: "set", id: "_session_auth_2"})
                                  .c('session', {xmlns: Strophe.NS.SESSION})
                                  .tree());
                } else {
                    this.authenticated = true;
                    this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                }
            }
        } else {
            Strophe.info("SASL binding failed.");
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false;
        }
    },

    /** PrivateFunction: _sasl_session_cb
     *  _Private_ handler to finish successful SASL connection.
     *
     *  This sets Connection.authenticated to true on success, which
     *  starts the processing of user handlers.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_session_cb: function (elem)
    {
        if (elem.getAttribute("type") == "result") {
            this.authenticated = true;
            this._changeConnectStatus(Strophe.Status.CONNECTED, null);
        } else if (elem.getAttribute("type") == "error") {
            Strophe.info("Session creation failed.");
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false;
        }

        return false;
    },

    /** PrivateFunction: _sasl_failure_cb
     *  _Private_ handler for SASL authentication failure.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_failure_cb: function (elem)
    {
        // delete unneeded handlers
        if (this._sasl_success_handler) {
            this.deleteHandler(this._sasl_success_handler);
            this._sasl_success_handler = null;
        }
        if (this._sasl_challenge_handler) {
            this.deleteHandler(this._sasl_challenge_handler);
            this._sasl_challenge_handler = null;
        }

        this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
        return false;
    },

    /** PrivateFunction: _auth2_cb
     *  _Private_ handler to finish legacy authentication.
     *
     *  This handler is called when the result from the jabber:iq:auth
     *  <iq/> stanza is returned.
     *
     *  Parameters:
     *    (XMLElement) elem - The stanza that triggered the callback.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _auth2_cb: function (elem)
    {
        if (elem.getAttribute("type") == "result") {
            this.authenticated = true;
            this._changeConnectStatus(Strophe.Status.CONNECTED, null);
        } else if (elem.getAttribute("type") == "error") {
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            this.disconnect();
        }

        return false;
    },

    /** PrivateFunction: _addSysTimedHandler
     *  _Private_ function to add a system level timed handler.
     *
     *  This function is used to add a Strophe.TimedHandler for the
     *  library code.  System timed handlers are allowed to run before
     *  authentication is complete.
     *
     *  Parameters:
     *    (Integer) period - The period of the handler.
     *    (Function) handler - The callback function.
     */
    _addSysTimedHandler: function (period, handler)
    {
        var thand = new Strophe.TimedHandler(period, handler);
        thand.user = false;
        this.addTimeds.push(thand);
        return thand;
    },

    /** PrivateFunction: _addSysHandler
     *  _Private_ function to add a system level stanza handler.
     *
     *  This function is used to add a Strophe.Handler for the
     *  library code.  System stanza handlers are allowed to run before
     *  authentication is complete.
     *
     *  Parameters:
     *    (Function) handler - The callback function.
     *    (String) ns - The namespace to match.
     *    (String) name - The stanza name to match.
     *    (String) type - The stanza type attribute to match.
     *    (String) id - The stanza id attribute to match.
     */
    _addSysHandler: function (handler, ns, name, type, id)
    {
        var hand = new Strophe.Handler(handler, ns, name, type, id);
        hand.user = false;
        this.addHandlers.push(hand);
        return hand;
    },

    /** PrivateFunction: _onDisconnectTimeout
     *  _Private_ timeout handler for handling non-graceful disconnection.
     *
     *  If the graceful disconnect process does not complete within the
     *  time allotted, this handler finishes the disconnect anyway.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _onDisconnectTimeout: function ()
    {
        Strophe.info("_onDisconnectTimeout was called");

        // cancel all remaining requests and clear the queue
        var req;
        while (this._requests.length > 0) {
            req = this._requests.pop();
            req.abort = true;
            req.xhr.abort();
            // jslint complains, but this is fine. setting to empty func
            // is necessary for IE6
            req.xhr.onreadystatechange = function () {};
        }

        // actually disconnect
        this._doDisconnect();

        return false;
    },

    /** PrivateFunction: _onIdle
     *  _Private_ handler to process events during idle cycle.
     *
     *  This handler is called every 100ms to fire timed handlers that
     *  are ready and keep poll requests going.
     */
    _onIdle: function ()
    {
        var i, thand, since, newList;

        // add timed handlers scheduled for addition
        // NOTE: we add before remove in the case a timed handler is
        // added and then deleted before the next _onIdle() call.
        while (this.addTimeds.length > 0) {
            this.timedHandlers.push(this.addTimeds.pop());
        }

        // remove timed handlers that have been scheduled for deletion
        while (this.removeTimeds.length > 0) {
            thand = this.removeTimeds.pop();
            i = this.timedHandlers.indexOf(thand);
            if (i >= 0) {
                this.timedHandlers.splice(i, 1);
            }
        }

        // call ready timed handlers
        var now = new Date().getTime();
        newList = [];
        for (i = 0; i < this.timedHandlers.length; i++) {
            thand = this.timedHandlers[i];
            if (this.authenticated || !thand.user) {
                since = thand.lastCalled + thand.period;
                if (since - now <= 0) {
                    if (thand.run()) {
                        newList.push(thand);
                    }
                } else {
                    newList.push(thand);
                }
            }
        }
        this.timedHandlers = newList;

        var body, time_elapsed;

        // if no requests are in progress, poll
        if (this.authenticated && this._requests.length === 0 &&
            this._data.length === 0 && !this.disconnecting) {
            Strophe.info("no requests during idle cycle, sending " +
                         "blank request");
            this._data.push(null);
        }

        if (this._requests.length < 2 && this._data.length > 0 &&
            !this.paused) {
            body = this._buildBody();
            for (i = 0; i < this._data.length; i++) {
                if (this._data[i] !== null) {
                    if (this._data[i] === "restart") {
                        body.attrs({
                            to: this.domain,
                            "xml:lang": "en",
                            "xmpp:restart": "true",
                            "xmlns:xmpp": Strophe.NS.BOSH
                        });
                    } else {
                        body.cnode(this._data[i]).up();
                    }
                }
            }
            delete this._data;
            this._data = [];
            this._requests.push(
                new Strophe.Request(body.tree(),
                                    this._onRequestStateChange.bind(
                                        this, this._dataRecv.bind(this)),
                                    body.tree().getAttribute("rid")));
            this._processRequest(this._requests.length - 1);
        }

        if (this._requests.length > 0) {
            time_elapsed = this._requests[0].age();
            if (this._requests[0].dead !== null) {
                if (this._requests[0].timeDead() >
                    Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {
                    this._throttledRequestHandler();
                }
            }

            if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {
                Strophe.warn("Request " +
                             this._requests[0].id +
                             " timed out, over " + Math.floor(Strophe.TIMEOUT * this.wait) +
                             " seconds since last activity");
                this._throttledRequestHandler();
            }
        }

        clearTimeout(this._idleTimeout);

        // reactivate the timer only if connected
        if (this.connected) {
            this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);
        }
    }
};

if (callback) {
    callback(Strophe, $build, $msg, $iq, $pres);
}

})(function () {
    window.Strophe = arguments[0];
    window.$build = arguments[1];
    window.$msg = arguments[2];
    window.$iq = arguments[3];
    window.$pres = arguments[4];
});
/*
Plugin to implement the MUC extension. http://xmpp.org/extensions/xep-0045.html
*/
/* jslint configuration: */
/* global document, window, setTimeout, clearTimeout, console,
    XMLHttpRequest, ActiveXObject,
    Base64, MD5,
    Strophe, $build, $msg, $iq, $pres 
*/

Strophe.addConnectionPlugin('muc', {
    _connection: null,
    // The plugin must have the init function
    /***Function
    Initialize the MUC plugin. Sets the correct connection object and
    extends the namesace.
    */
    init: function(conn) {
        this._connection = conn;
        /* extend name space 
         *  NS.MUC - XMPP Multi-user chat namespace
         *              from XEP 45.  
         *
         */
        Strophe.addNamespace('MUC_OWNER', Strophe.NS.MUC+"#owner");
        Strophe.addNamespace('MUC_ADMIN', Strophe.NS.MUC+"#admin");
    },
    /***Function
    Join a multi-user chat room
    Parameters:
    (String) room - The multi-user chat room to join.
    (String) nick - The nickname to use in the chat room. Optional
    (Function) msg_handler_cb - The function call to handle messages from the
    specified chat room.
    (Function) pres_handler_cb - The function call back to handle presence
    in the chat room.
    (String) password - The optional password to use. (password protected
    rooms only)
    */
    join: function(room, nick, msg_handler_cb, pres_handler_cb, password) {
        var room_nick = this.test_append_nick(room, nick);        
        var msg = $pres({from: this._connection.jid,
                         to: room_nick})
            .c("x",{xmlns: Strophe.NS.MUC});
        if (password)
        {
            var password_elem = Strophe.xmlElement("password", 
                                                   [],
                                                   password);
            msg.cnode(password_elem);
        }
        if (msg_handler_cb)
        {
            this._connection.addHandler(function(stanza) {
                var from = stanza.getAttribute('from');
                var roomname = from.split("/");
                // filter on room name
                if (roomname[0] == room)
                {
                    return msg_handler_cb(stanza);
                }
                else
                {
                    return true;
                }
            },
                                        null,
                                        "message",
                                        null,
                                        null,
                                        null);
        }
        if (pres_handler_cb)
        {
            this._connection.addHandler(function(stanza) {
                var xquery = stanza.getElementsByTagName("x");
                if (xquery.length > 0)
                {
                    //Handle only MUC user protocol
                    for (var i = 0; i < xquery.length; i++)
                    {
                        var xmlns = xquery[i].getAttribute("xmlns");
                        
                        if (xmlns && xmlns.match(Strophe.NS.MUC))
                        {
                            return pres_handler_cb(stanza);
                        }
                    }
                }
                return true;                
            },
                                        null,
                                        "presence",
                                        null,
                                        null,
                                        null);
        }
        this._connection.send(msg);
    },
    /***Function
    Leave a multi-user chat room
    Parameters:
    (String) room - The multi-user chat room to leave.
    (String) nick - The nick name used in the room.
    (Function) handler_cb - Optional function to handle the successful leave.
    Returns:
    iqid - The unique id for the room leave.
    */
    leave: function(room, nick, handler_cb) {
        var room_nick = this.test_append_nick(room, nick);        
        var presenceid = this._connection.getUniqueId();
        var presence = $pres({type: "unavailable",
                              id: presenceid,
                              from: this._connection.jid,
                              to: room_nick})
            .c("x",{xmlns: Strophe.NS.MUC});
        this._connection.addHandler(handler_cb,
                                    null,
                                    "presence",
                                    null,
                                    presenceid,
                                    null);
        this._connection.send(presence);
        return presenceid;
    },
    /***Function
    Parameters:
    (String) room - The multi-user chat room name.
    (String) nick - The nick name used in the chat room.
    (String) message - The message to send to the room.
    (String) type - "groupchat" for group chat messages or "chat" for private chat messages
    Returns:
    msgiq - the unique id used to send the message
    */
    message: function(room, nick, message, type) {
        var room_nick = this.test_append_nick(room, nick);        
        type = type || "groupchat";
        var msgid = this._connection.getUniqueId();
        var msg = $msg({to: room_nick,
                        from: this._connection.jid,
                        type: type,
                        id: msgid}).c("body",
                                      {xmlns: Strophe.NS.CLIENT}).t(message);
        msg.up().c("x", {xmlns: "jabber:x:event"}).c("composing");
        this._connection.send(msg);
        return msgid;
    },
    /***Function
    Start a room configuration.
    Parameters:
    (String) room - The multi-user chat room name.
    Returns:
    id - the unique id used to send the configuration request
    */
    configure: function(room) {
        //send iq to start room configuration
        var config = $iq({to:room,
                          type: "get"}).c("query",
                                          {xmlns: Strophe.NS.MUC_OWNER});
        var stanza = config.tree();
        return this._connection.sendIQ(stanza,
                               function(){},
                               function(){});
    },
    /***Function
    Cancel the room configuration
    Parameters:
    (String) room - The multi-user chat room name.
    Returns:
    id - the unique id used to cancel the configuration.
    */
    cancelConfigure: function(room) {
        //send iq to start room configuration
        var config = $iq({to: room,
                          type: "set"})
            .c("query", {xmlns: Strophe.NS.MUC_OWNER})
            .c("x", {xmlns: "jabber:x:data", type: "cancel"});
        var stanza = config.tree();
        return this._connection.sendIQ(stanza,
                                       function(){},
                                       function(){});
    },
    /***Function
    Save a room configuration.
    Parameters:
    (String) room - The multi-user chat room name.
    (Array) configarray - an array of form elements used to configure the room.
    Returns:
    id - the unique id used to save the configuration.
    */
    saveConfiguration: function(room, configarray) {
        var config = $iq({to: room,
                          type: "set"})
            .c("query", {xmlns: Strophe.NS.MUC_OWNER})
            .c("x", {xmlns: "jabber:x:data", type: "submit"});
        for (var i = 0; i < configarray.length; i++) {
            config.cnode(configarray[i]);
            config.up();
        }
        var stanza = config.tree();
        return this._connection.sendIQ(stanza,
                                       function(){},
                                       function(){});        
    },
    /***Function
    Parameters:
    (String) room - The multi-user chat room name.
    Returns:
    id - the unique id used to create the chat room.
    */
    createInstantRoom: function(room) {
        var roomiq = $iq({to: room,
                          type: "set"})
            .c("query", {xmlns: Strophe.NS.MUC_OWNER})
            .c("x", {xmlns: "jabber:x:data",
                     type: "submit"});
        return this._connection.sendIQ(roomiq.tree(),
                                       function() {},
                                       function() {});
    },
    /***
     Set the topic of the chat room.
     Parameters:
     (String) room - The multi-user chat room name.
     (String) topic - Topic message.
     */
    setTopic: function(room, topic) {
        var msg = $msg({to: room,
                        from: this._connection.jid,
                        type: "groupchat"})
            .c("subject", {xmlns: "jabber:client"}).t(topic);
        this._connection.send(msg.tree());
    },
    /***Function
    Changes the role and affiliation of a member of a MUC room.
    The modification can only be done by a room moderator. An error will be
    returned if the user doesn't have permission.
    Parameters:
    (String) room - The multi-user chat room name.
    (String) nick - The nick name of the user to modify.
    (String) role - The new role of the user.
    (String) affiliation - The new affiliation of the user.
    (String) reason - The reason for the change.
    Returns:
    iq - the id of the mode change request.
    */
    modifyUser: function(room, nick, role, affiliation, reason) {
        var item_attrs = {nick: Strophe.escapeNode(nick)};
        if (role !== null)
        {
            item_attrs.role = role;
        }
        if (affiliation !== null)
        {
            item_attrs.affiliation = affiliation;
        }
        var item = $build("item", item_attrs);
        if (reason !== null)
        {
            item.cnode(Strophe.xmlElement("reason", reason));
        }
        var roomiq = $iq({to: room,
                          type: "set"})
            .c("query", {xmlns: Strophe.NS.MUC_OWNER}).cnode(item.tree());
        return this._connection.sendIQ(roomiq.tree(),
                                       function() {},
                                       function() {});
    },
    /***Function
    Change the current users nick name.
    Parameters:
    (String) room - The multi-user chat room name.
    (String) user - The new nick name.
    */
    changeNick: function(room, user) {
        var room_nick = this.test_append_nick(room, user);
        var presence = $pres({from: this._connection.jid,
                              to: room_nick})
            .c("x",{xmlns: Strophe.NS.MUC});
        this._connection.send(presence.tree());
    },
    /***Function
    List all chat room available on a server.
    Parameters:
    (String) server - name of chat server.
    (String) handle_cb - Function to call for room list return.
    */
    listRooms: function(server, handle_cb) {
        var iq = $iq({to: server,
                      from: this._connection.jid,
                      type: "get"})
            .c("query",{xmlns: Strophe.NS.DISCO_ITEMS});        
        this._connection.sendIQ(iq, handle_cb, function(){});        
    },
    test_append_nick: function(room, nick) {
        var room_nick = room;
        if (nick) 
        {
            room_nick += "/" + Strophe.escapeNode(nick); 
        }
        return room_nick;
    }
});
/*
  mustache.js — Logic-less templates in JavaScript

  See http://mustache.github.com/ for more info.
*/

var Mustache = function() {
  var Renderer = function() {};

  Renderer.prototype = {
    otag: "{{",
    ctag: "}}",
    pragmas: {},
    buffer: [],
    pragmas_implemented: {
      "IMPLICIT-ITERATOR": true
    },
    context: {},

    render: function(template, context, partials, in_recursion) {
      // reset buffer & set context
      if(!in_recursion) {
        this.context = context;
        this.buffer = []; // TODO: make this non-lazy
      }

      // fail fast
      if(!this.includes("", template)) {
        if(in_recursion) {
          return template;
        } else {
          this.send(template);
          return;
        }
      }

      template = this.render_pragmas(template);
      var html = this.render_section(template, context, partials);
      if(in_recursion) {
        return this.render_tags(html, context, partials, in_recursion);
      }

      this.render_tags(html, context, partials, in_recursion);
    },

    /*
      Sends parsed lines
    */
    send: function(line) {
      if(line !== "") {
        this.buffer.push(line);
      }
    },

    /*
      Looks for %PRAGMAS
    */
    render_pragmas: function(template) {
      // no pragmas
      if(!this.includes("%", template)) {
        return template;
      }

      var that = this;
      var regex = new RegExp(this.otag + "%([\\w-]+) ?([\\w]+=[\\w]+)?" +
            this.ctag, "g");
      return template.replace(regex, function(match, pragma, options) {
        if(!that.pragmas_implemented[pragma]) {
          throw({message: 
            "This implementation of mustache doesn't understand the '" +
            pragma + "' pragma"});
        }
        that.pragmas[pragma] = {};
        if(options) {
          var opts = options.split("=");
          that.pragmas[pragma][opts[0]] = opts[1];
        }
        return "";
        // ignore unknown pragmas silently
      });
    },

    /*
      Tries to find a partial in the curent scope and render it
    */
    render_partial: function(name, context, partials) {
      name = this.trim(name);
      if(!partials || partials[name] === undefined) {
        throw({message: "unknown_partial '" + name + "'"});
      }
      if(typeof(context[name]) != "object") {
        return this.render(partials[name], context, partials, true);
      }
      return this.render(partials[name], context[name], partials, true);
    },

    /*
      Renders inverted (^) and normal (#) sections
    */
    render_section: function(template, context, partials) {
      if(!this.includes("#", template) && !this.includes("^", template)) {
        return template;
      }

      var that = this;
      // CSW - Added "+?" so it finds the tighest bound, not the widest
      var regex = new RegExp(this.otag + "(\\^|\\#)\\s*(.+)\\s*" + this.ctag +
              "\n*([\\s\\S]+?)" + this.otag + "\\/\\s*\\2\\s*" + this.ctag +
              "\\s*", "mg");

      // for each {{#foo}}{{/foo}} section do...
      return template.replace(regex, function(match, type, name, content) {
        var value = that.find(name, context);
        if(type == "^") { // inverted section
          if(!value || that.is_array(value) && value.length === 0) {
            // false or empty list, render it
            return that.render(content, context, partials, true);
          } else {
            return "";
          }
        } else if(type == "#") { // normal section
          if(that.is_array(value)) { // Enumerable, Let's loop!
            return that.map(value, function(row) {
              return that.render(content, that.create_context(row),
                partials, true);
            }).join("");
          } else if(that.is_object(value)) { // Object, Use it as subcontext!
            return that.render(content, that.create_context(value),
              partials, true);
          } else if(typeof value === "function") {
            // higher order section
            return value.call(context, content, function(text) {
              return that.render(text, context, partials, true);
            });
          } else if(value) { // boolean section
            return that.render(content, context, partials, true);
          } else {
            return "";
          }
        }
      });
    },

    /*
      Replace {{foo}} and friends with values from our view
    */
    render_tags: function(template, context, partials, in_recursion) {
      // tit for tat
      var that = this;

      var new_regex = function() {
        return new RegExp(that.otag + "(=|!|>|\\{|%)?([^\\/#\\^]+?)\\1?" +
          that.ctag + "+", "g");
      };

      var regex = new_regex();
      var tag_replace_callback = function(match, operator, name) {
        switch(operator) {
        case "!": // ignore comments
          return "";
        case "=": // set new delimiters, rebuild the replace regexp
          that.set_delimiters(name);
          regex = new_regex();
          return "";
        case ">": // render partial
          return that.render_partial(name, context, partials);
        case "{": // the triple mustache is unescaped
          return that.find(name, context);
        default: // escape the value
          return that.escape(that.find(name, context));
        }
      };
      var lines = template.split("\n");
      for(var i = 0; i < lines.length; i++) {
        lines[i] = lines[i].replace(regex, tag_replace_callback, this);
        if(!in_recursion) {
          this.send(lines[i]);
        }
      }

      if(in_recursion) {
        return lines.join("\n");
      }
    },

    set_delimiters: function(delimiters) {
      var dels = delimiters.split(" ");
      this.otag = this.escape_regex(dels[0]);
      this.ctag = this.escape_regex(dels[1]);
    },

    escape_regex: function(text) {
      // thank you Simon Willison
      if(!arguments.callee.sRE) {
        var specials = [
          '/', '.', '*', '+', '?', '|',
          '(', ')', '[', ']', '{', '}', '\\'
        ];
        arguments.callee.sRE = new RegExp(
          '(\\' + specials.join('|\\') + ')', 'g'
        );
      }
      return text.replace(arguments.callee.sRE, '\\$1');
    },

    /*
      find `name` in current `context`. That is find me a value
      from the view object
    */
    find: function(name, context) {
      name = this.trim(name);

      // Checks whether a value is thruthy or false or 0
      function is_kinda_truthy(bool) {
        return bool === false || bool === 0 || bool;
      }

      var value;
      if(is_kinda_truthy(context[name])) {
        value = context[name];
      } else if(is_kinda_truthy(this.context[name])) {
        value = this.context[name];
      }

      if(typeof value === "function") {
        return value.apply(context);
      }
      if(value !== undefined) {
        return value;
      }
      // silently ignore unkown variables
      return "";
    },

    // Utility methods

    /* includes tag */
    includes: function(needle, haystack) {
      return haystack.indexOf(this.otag + needle) != -1;
    },

    /*
      Does away with nasty characters
    */
    escape: function(s) {
      s = String(s === null ? "" : s);
      return s.replace(/&(?!\w+;)|["'<>\\]/g, function(s) {
        switch(s) {
        case "&": return "&amp;";
        case "\\": return "\\\\";
        case '"': return '&quot;';
        case "'": return '&#39;';
        case "<": return "&lt;";
        case ">": return "&gt;";
        default: return s;
        }
      });
    },

    // by @langalex, support for arrays of strings
    create_context: function(_context) {
      if(this.is_object(_context)) {
        return _context;
      } else {
        var iterator = ".";
        if(this.pragmas["IMPLICIT-ITERATOR"]) {
          iterator = this.pragmas["IMPLICIT-ITERATOR"].iterator;
        }
        var ctx = {};
        ctx[iterator] = _context;
        return ctx;
      }
    },

    is_object: function(a) {
      return a && typeof a == "object";
    },

    is_array: function(a) {
      return Object.prototype.toString.call(a) === '[object Array]';
    },

    /*
      Gets rid of leading and trailing whitespace
    */
    trim: function(s) {
      return s.replace(/^\s*|\s*$/g, "");
    },

    /*
      Why, why, why? Because IE. Cry, cry cry.
    */
    map: function(array, fn) {
      if (typeof array.map == "function") {
        return array.map(fn);
      } else {
        var r = [];
        var l = array.length;
        for(var i = 0; i < l; i++) {
          r.push(fn(array[i]));
        }
        return r;
      }
    }
  };

  return({
    name: "mustache.js",
    version: "0.3.1-dev",

    /*
      Turns a template and view into HTML
    */
    to_html: function(template, view, partials, send_fun) {
      var renderer = new Renderer();
      if(send_fun) {
        renderer.send = send_fun;
      }
      renderer.render(template, view, partials);
      if(!send_fun) {
        return renderer.buffer.join("\n");
      }
    }
  });
}();
/*
 * jQuery i18n plugin
 * @requires jQuery v1.1 or later
 *
 * See http://recursive-design.com/projects/jquery-i18n/
 *
 * Licensed under the MIT license:
 *   http://www.opensource.org/licenses/mit-license.php
 *
 * Version: 0.9.2 (201111281039)
 */
 (function($) {
/**
 * i18n provides a mechanism for translating strings using a jscript dictionary.
 *
 */


/*
 * i18n property list
 */
$.i18n = {
	
	dict: null,
	
/**
 * setDictionary()
 * Initialise the dictionary and translate nodes
 *
 * @param property_list i18n_dict : The dictionary to use for translation
 */
	setDictionary: function(i18n_dict) {
		this.dict = i18n_dict;
	},
	
/**
 * _()
 * The actual translation function. Looks the given string up in the 
 * dictionary and returns the translation if one exists. If a translation 
 * is not found, returns the original word
 *
 * @param string str : The string to translate 
 * @param property_list params : params for using printf() on the string
 * @return string : Translated word
 *
 */
	_: function (str, params) {
		var transl = str;
		if (this.dict && this.dict[str]) {
			transl = this.dict[str];
		}
		return this.printf(transl, params);
	},
	
/**
 * toEntity()
 * Change non-ASCII characters to entity representation 
 *
 * @param string str : The string to transform
 * @return string result : Original string with non-ASCII content converted to entities
 *
 */
	toEntity: function (str) {
		var result = '';
		for (var i=0;i<str.length; i++) {
			if (str.charCodeAt(i) > 128)
				result += "&#"+str.charCodeAt(i)+";";
			else
				result += str.charAt(i);
		}
		return result;
	},
	
/**
 * stripStr()
 *
 * @param string str : The string to strip
 * @return string result : Stripped string
 *
 */
 	stripStr: function(str) {
		return str.replace(/^\s*/, "").replace(/\s*$/, "");
	},
	
/**
 * stripStrML()
 *
 * @param string str : The multi-line string to strip
 * @return string result : Stripped string
 *
 */
	stripStrML: function(str) {
		// Split because m flag doesn't exist before JS1.5 and we need to
		// strip newlines anyway
		var parts = str.split('\n');
		for (var i=0; i<parts.length; i++)
			parts[i] = stripStr(parts[i]);
	
		// Don't join with empty strings, because it "concats" words
		// And strip again
		return stripStr(parts.join(" "));
	},

/*
 * printf()
 * C-printf like function, which substitutes %s with parameters
 * given in list. %%s is used to escape %s.
 *
 * Doesn't work in IE5.0 (splice)
 *
 * @param string S : string to perform printf on.
 * @param string L : Array of arguments for printf()
 */
	printf: function(S, L) {
		if (!L) return S;

		var nS = "",
			search = /%(\d+)\$s/g;
		// replace %n1$ where n is a number
		while (result = search.exec(S)) {
			var index = parseInt(result[1], 10) -1;
			S = S.replace('%' + result[1] + '\$s', (L[index]));
			L.splice(index, 1);
		}
		var tS = S.split("%s");
		if (tS.length > 1) {
			for(var i = 0; i < L.length; i++) {
				if (tS[i].lastIndexOf('%') == tS[i].length-1 && i != L.length-1)
					tS[i] += "s"+tS.splice(i+1,1)[0];
				nS += tS[i] + L[i];
			}
		}
		return nS + tS[tS.length-1];
	}

};

/*
 * _t
 * Allows you to translate a jQuery selector
 *
 * eg $('h1')._t('some text')
 * 
 * @param string str : The string to translate 
 * @param property_list params : params for using printf() on the string
 * @return element : chained and translated element(s)
*/
$.fn._t = function(str, params) {
  return $(this).text($.i18n._(str, params));
};


})(jQuery);
/*
 * Date Format 1.2.3
 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
 * MIT license
 *
 * Includes enhancements by Scott Trenda <scott.trenda.net>
 * and Kris Kowal <cixar.com/~kris.kowal/>
 *
 * Accepts a date, a mask, or a date and a mask.
 * Returns a formatted version of the given date.
 * The date defaults to the current date/time.
 * The mask defaults to dateFormat.masks.default.
 *
 * @link http://blog.stevenlevithan.com/archives/date-time-format
 */

var dateFormat = function () {
	var	token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
		timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
		timezoneClip = /[^-+\dA-Z]/g,
		pad = function (val, len) {
			val = String(val);
			len = len || 2;
			while (val.length < len) val = "0" + val;
			return val;
		};

	// Regexes and supporting functions are cached through closure
	return function (date, mask, utc) {
		var dF = dateFormat;

		// You can't provide utc if you skip other args (use the "UTC:" mask prefix)
		if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
			mask = date;
			date = undefined;
		}

		// Passing date through Date applies Date.parse, if necessary
		date = date ? new Date(date) : new Date;
		if (isNaN(date)) throw SyntaxError("invalid date");

		mask = String(dF.masks[mask] || mask || dF.masks["default"]);

		// Allow setting the utc argument via the mask
		if (mask.slice(0, 4) == "UTC:") {
			mask = mask.slice(4);
			utc = true;
		}

		var	_ = utc ? "getUTC" : "get",
			d = date[_ + "Date"](),
			D = date[_ + "Day"](),
			m = date[_ + "Month"](),
			y = date[_ + "FullYear"](),
			H = date[_ + "Hours"](),
			M = date[_ + "Minutes"](),
			s = date[_ + "Seconds"](),
			L = date[_ + "Milliseconds"](),
			o = utc ? 0 : date.getTimezoneOffset(),
			flags = {
				d:    d,
				dd:   pad(d),
				ddd:  dF.i18n.dayNames[D],
				dddd: dF.i18n.dayNames[D + 7],
				m:    m + 1,
				mm:   pad(m + 1),
				mmm:  dF.i18n.monthNames[m],
				mmmm: dF.i18n.monthNames[m + 12],
				yy:   String(y).slice(2),
				yyyy: y,
				h:    H % 12 || 12,
				hh:   pad(H % 12 || 12),
				H:    H,
				HH:   pad(H),
				M:    M,
				MM:   pad(M),
				s:    s,
				ss:   pad(s),
				l:    pad(L, 3),
				L:    pad(L > 99 ? Math.round(L / 10) : L),
				t:    H < 12 ? "a"  : "p",
				tt:   H < 12 ? "am" : "pm",
				T:    H < 12 ? "A"  : "P",
				TT:   H < 12 ? "AM" : "PM",
				Z:    utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
				o:    (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
				S:    ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
			};

		return mask.replace(token, function ($0) {
			return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
		});
	};
}();

// Some common format strings
dateFormat.masks = {
	"default":      "ddd mmm dd yyyy HH:MM:ss",
	shortDate:      "m/d/yy",
	mediumDate:     "mmm d, yyyy",
	longDate:       "mmmm d, yyyy",
	fullDate:       "dddd, mmmm d, yyyy",
	shortTime:      "h:MM TT",
	mediumTime:     "h:MM:ss TT",
	longTime:       "h:MM:ss TT Z",
	isoDate:        "yyyy-mm-dd",
	isoTime:        "HH:MM:ss",
	isoDateTime:    "yyyy-mm-dd'T'HH:MM:ss",
	isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
};

// Internationalization strings
dateFormat.i18n = {
	dayNames: [
		"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
		"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
	],
	monthNames: [
		"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
		"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
	]
};

// For convenience...
Date.prototype.format = function (mask, utc) {
	return dateFormat(this, mask, utc);
};
/** File: candy.js
 * Candy - Chats are not dead yet.
 *
 * Authors:
 *   - Patrick Stadler <patrick.stadler@gmail.com>
 *   - Michael Weibel <michael.weibel@gmail.com>
 *
 * Copyright:
 *   (c) 2011 Amiado Group AG. All rights reserved.
 */

/*jslint regexp: true, browser: true, confusion: true, sloppy: true, white: true, nomen: true, plusplus: true, maxerr: 50, indent: 4 */
/*global jQuery: true, MD5: true, escape: true, Mustache: true, console: true, Strophe: true, $iq: true, $pres: true */

/** Class: Candy
 * Candy base class for initalizing the view and the core
 *
 * Parameters:
 *   (Candy) self - itself
 *   (jQuery) $ - jQuery
 */
var Candy = (function (self, $) {
	/** Object: about
	 * About candy
	 *
	 * Contains:
	 *   (String) name - Candy
	 *   (Float) version - Candy version
	 */
	self.about = {
		name: 'Candy',
		version: '1.0.9'
	};

	/** Function: init
	 * Init view & core
	 *
	 * Parameters:
	 *   (String) service - URL to the BOSH interface
	 *   (Object) options - Options for candy
	 *
	 * Options:
	 *   (Boolean) debug - Debug (Default: false)
	 *   (Array|Boolean) autojoin - Autojoin these channels. When boolean true, do not autojoin, wait if the server sends something.
	 */
    self.init = function (service, options) {
		self.View.init($('#candy'), options.view);
		self.Core.init(service, options.core);
	};

	return self;
}(Candy || {}, jQuery));
/** File: core.js
 * Candy - Chats are not dead yet.
 *
 * Authors:
 *   - Patrick Stadler <patrick.stadler@gmail.com>
 *   - Michael Weibel <michael.weibel@gmail.com>
 *
 * Copyright:
 *   (c) 2011 Amiado Group AG. All rights reserved.
 */

/** Class: Candy.Core
 * Candy Chat Core
 *
 * Parameters:
 *   (Candy.Core) self - itself
 *   (Strophe) Strophe - Strophe JS
 *   (jQuery) $ - jQuery
 */
Candy.Core = (function (self, Strophe, $) {
		/** PrivateVariable: _connection
		 * Strophe connection
		 */
	var _connection = null,
		/** PrivateVariable: _service
		 * URL of BOSH service
		 */
		_service = null,
		/** PrivateVariable: _user
		 * Current user (me)
		 */
		_user = null,
		/** PrivateVariable: _rooms
		 * Opened rooms, containing instances of Candy.Core.ChatRooms
		 */
		_rooms = {},
		/** PrivateVariable: _anonymousConnection
		 * Set in <Candy.Core.connect> when jidOrHost doesn't contain a @-char.
		 */
		_anonymousConnection = false,
		/** PrivateVariable: _options
		 * Options:
		 *   (Boolean) debug - Debug (Default: false)
		 *   (Array|Boolean) autojoin - Autojoin these channels. When boolean true, do not autojoin, wait if the server sends something.
		 */
		_options = {
			/** Boolean: autojoin
			 * If set to `true` try to get the bookmarks and autojoin the rooms (supported by Openfire).
			 * You may want to define an array of rooms to autojoin: `['room1@conference.host.tld', 'room2...]` (ejabberd, Openfire, ...)
			 */
			autojoin: true,
			debug: false
		},

		/** PrivateFunction: _addNamespace
		 * Adds a namespace.
		 *
		 * Parameters:
		 *   (String) name - namespace name (will become a constant living in Strophe.NS.*)
		 *   (String) value - XML Namespace
		 */
		_addNamespace = function (name, value) {
			Strophe.addNamespace(name, value);
		},

		/** PrivateFunction: _addNamespaces
		 * Adds namespaces needed by Candy.
		 */
		_addNamespaces = function () {
			_addNamespace('PRIVATE', 'jabber:iq:private');
			_addNamespace('BOOKMARKS', 'storage:bookmarks');
			_addNamespace('PRIVACY', 'jabber:iq:privacy');
			_addNamespace('DELAY', 'jabber:x:delay');
		},

		/** PrivateFunction: _registerEventHandlers
		 * Adds listening handlers to the connection.
		 */
		_registerEventHandlers = function () {
			self.addHandler(self.Event.Jabber.Version, Strophe.NS.VERSION, 'iq');
			self.addHandler(self.Event.Jabber.Presence, null, 'presence');
			self.addHandler(self.Event.Jabber.Message, null, 'message');
			self.addHandler(self.Event.Jabber.Bookmarks, Strophe.NS.PRIVATE, 'iq');
			self.addHandler(self.Event.Jabber.Room.Disco, Strophe.NS.DISCO_INFO, 'iq');
			self.addHandler(self.Event.Jabber.PrivacyList, Strophe.NS.PRIVACY, 'iq', 'result');
			self.addHandler(self.Event.Jabber.PrivacyListError, Strophe.NS.PRIVACY, 'iq', 'error');
		};

	/** Function: init
	 * Initialize Core.
	 *
	 * Parameters:
	 *   (String) service - URL of BOSH service
	 *   (Object) options - Options for candy
	 */
    self.init = function (service, options) {
		_service = service;
		// Apply options
		$.extend(true, _options, options);

		// Enable debug logging
        if (_options.debug) {
            self.log = function (str) {
				try { // prevent erroring
                    if (typeof window.console !== undefined && typeof window.console.log !== undefined) {
						console.log(str);
					}
                } catch (e) {
					//console.error(e);
				}
			};
			self.log('[Init] Debugging enabled');
		}

		_addNamespaces();
		// Connect to BOSH service
		_connection = new Strophe.Connection(_service);
		_connection.rawInput = self.rawInput.bind(self);
		_connection.rawOutput = self.rawOutput.bind(self);

		// Window unload handler... works on all browsers but Opera. There is NO workaround.
		// Opera clients getting disconnected 1-2 minutes delayed.
		window.onbeforeunload = self.onWindowUnload;

		// Prevent Firefox from aborting AJAX requests when pressing ESC
        if ($.browser.mozilla) {
            $(document).keydown(function (e) {
                if (e.which === 27) {
					e.preventDefault();
				}
			});
		}
	};

	/** Function: connect
	 * Connect to the jabber host.
	 *
	 * There are four different procedures to login:
	 *   connect('JID', 'password') - Connect a registered user
	 *   connect('domain') - Connect anonymously to the domain. The user should receive a random JID.
	 *   connect('domain', null, 'nick') - Connect anonymously to the domain. The user should receive a random JID but with a nick set.
	 *   connect('JID') - Show login form and prompt for password. JID input is hidden.
	 *   connect() - Show login form and prompt for JID and password.
	 *
	 * See:
	 *   <Candy.Core.attach()> for attaching an already established session.
	 *
	 * Parameters:
	 *   (String) jidOrHost - JID or Host
	 *   (String) password  - Password of the user
	 *   (String) nick      - Nick of the user. Set one if you want to anonymously connect but preset a nick. If jidOrHost is a domain
	 *                        and this param is not set, Candy will prompt for a nick.
	 */
    self.connect = function (jidOrHost, password, nick) {
		// Reset before every connection attempt to make sure reconnections work after authfail, alltabsclosed, ...
		_connection.reset();
		_registerEventHandlers();

		_anonymousConnection = !_anonymousConnection ? jidOrHost && jidOrHost.indexOf("@") < 0 : true;

        if (jidOrHost && password) {
			// authentication
			_connection.connect(_getEscapedJidFromJid(jidOrHost) + '/' + Candy.about.name, password, Candy.Core.Event.Strophe.Connect);
			_user = new self.ChatUser(jidOrHost, Strophe.getNodeFromJid(jidOrHost));
        } else if (jidOrHost && nick) {
			// anonymous connect
			_connection.connect(_getEscapedJidFromJid(jidOrHost) + '/' + Candy.about.name, null, Candy.Core.Event.Strophe.Connect);
			_user = new self.ChatUser(null, nick); // set jid to null because we'll later receive it
        } else if (jidOrHost) {
			Candy.Core.Event.Login(jidOrHost);
		} else {
			// display login modal
			Candy.Core.Event.Login();
		}
	};
	
    _getEscapedJidFromJid = function (jid) {
		var node = Strophe.getNodeFromJid(jid),
			domain = Strophe.getDomainFromJid(jid);
		return node ? Strophe.escapeNode(node) + '@' + domain : domain;
	};

	/** Function: attach
	 * Attach an already binded & connected session to the server
	 *
	 * _See_ Strophe.Connection.attach
	 *
	 * Parameters:
	 *   (String) jid - Jabber ID
	 *   (Integer) sid - Session ID
	 *   (Integer) rid - rid
	 */
    self.attach = function (jid, sid, rid) {
		_user = new self.ChatUser(jid, Strophe.getNodeFromJid(jid));
		_registerEventHandlers();
		_connection.attach(jid, sid, rid, Candy.Core.Event.Strophe.Connect);
	};

	/** Function: disconnect
	 * Leave all rooms and disconnect
	 */
    self.disconnect = function () {
        if (_connection.connected) {
            $.each(self.getRooms(), function () {
				Candy.Core.Action.Jabber.Room.Leave(this.getJid());
			});
			_connection.disconnect();
		}
	};
	
	/** Function: addHandler
	 * Wrapper for Strophe.Connection.addHandler() to add a stanza handler for the connection.
	 *
	 * Parameters:
	 *   (Function) handler - The user callback.
	 *   (String) ns - The namespace to match.
	 *   (String) name - The stanza name to match.
	 *   (String) type - The stanza type attribute to match.
	 *   (String) id - The stanza id attribute to match.
	 *   (String) from - The stanza from attribute to match.
	 *   (String) options - The handler options
	 *
	 * Returns:
	 *   A reference to the handler that can be used to remove it.
	 */
    self.addHandler = function (handler, ns, name, type, id, from, options) {
		return _connection.addHandler(handler, ns, name, type, id, from, options);
	};

	/** Function: getUser
	 * Gets current user
	 *
	 * Returns:
	 *   Instance of Candy.Core.ChatUser
	 */
    self.getUser = function () {
		return _user;
	};

	/** Function: setUser
	 * Set current user. Needed when anonymous login is used, as jid gets retrieved later.
	 *
	 * Parameters:
	 *   (Candy.Core.ChatUser) user - User instance
	 */
    self.setUser = function (user) {
		_user = user;
	};

	/** Function: getConnection
	 * Gets Strophe connection
	 *
	 * Returns:
	 *   Instance of Strophe.Connection
	 */
    self.getConnection = function () {
		return _connection;
	};

	/** Function: getRooms
	 * Gets all joined rooms
	 *
	 * Returns:
	 *   Object containing instances of Candy.Core.ChatRoom
	 */
    self.getRooms = function () {
		return _rooms;
	};

	/** Function: isAnonymousConnection
	 * Returns true if <Candy.Core.connect> was first called with a domain instead of a jid as the first param.
	 *
	 * Returns:
	 *   (Boolean)
	 */
    self.isAnonymousConnection = function () {
		return _anonymousConnection;
	};

	/** Function: getOptions
	 * Gets options
	 *
	 * Returns:
	 *   Object
	 */
    self.getOptions = function () {
		return _options;
	};

    /** Function: getRoom
	 * Gets a specific room
	 *
	 * Parameters:
	 *   (String) roomJid - JID of the room
	 *
	 * Returns:
	 *   If the room is joined, instance of Candy.Core.ChatRoom, otherwise null.
	 */
    self.getRoom = function (roomJid) {
		if (_rooms[roomJid]) {
			return _rooms[roomJid];
		}
		return null;
	};

	/** Function: onWindowUnload
	 * window.onbeforeunload event which disconnects the client from the Jabber server.
	 */
    self.onWindowUnload = function () {
		// Enable synchronous requests because Safari doesn't send asynchronous requests within unbeforeunload events.
		// Only works properly when following patch is applied to strophejs: https://github.com/metajack/strophejs/issues/16/#issuecomment-600266
		_connection.sync = true;
		self.disconnect();
		_connection.flush();
	};

	/** Function: rawInput
	 * (Overridden from Strophe.Connection.rawInput)
	 *
	 * Logs all raw input if debug is set to true.
	 */
    self.rawInput = function (data) {
		this.log('RECV: ' + data);
	};

	/** Function rawOutput
	 * (Overridden from Strophe.Connection.rawOutput)
	 *
	 * Logs all raw output if debug is set to true.
	 */
    self.rawOutput = function (data) {
		this.log('SENT: ' + data);
	};

	/** Function: log
	 * Overridden to do something useful if debug is set to true.
	 *
	 * See: Candy.Core#init
	 */
    self.log = function () { };

	return self;
}(Candy.Core || {}, Strophe, jQuery));
/** File: view.js
 * Candy - Chats are not dead yet.
 *
 * Authors:
 *   - Patrick Stadler <patrick.stadler@gmail.com>
 *   - Michael Weibel <michael.weibel@gmail.com>
 *
 * Copyright:
 *   (c) 2011 Amiado Group AG. All rights reserved.
 */

/** Class: Candy.View
 * The Candy View Class
 *
 * Parameters:
 *   (Candy.View) self - itself
 *   (jQuery) $ - jQuery
 */
Candy.View = (function (self, $) {
		/** PrivateObject: _current
		 * Object containing current container & roomJid which the client sees.
		 */
	var _current = { container: null, roomJid: null },
		/** PrivateObject: _options
		 *
		 * Options:
		 *   (String) language - language to use
		 *   (String) resources - path to resources directory (with trailing slash)
		 *   (Object) messages - limit: clean up message pane when n is reached / remove: remove n messages after limit has been reached
		 *   (Object) crop - crop if longer than defined: message.nickname=15, message.body=1000, roster.nickname=15
		 */
		_options = {
			language: 'en',
			resources: 'res/',
			messages: { limit: 2000, remove: 500 },
			crop: {
				message: { nickname: 15, body: 1000 },
				roster: { nickname: 15 }
			}
		},

		/** PrivateFunction: _setupTranslation
		 * Set dictionary using jQuery.i18n plugin.
		 *
		 * See: view/translation.js
		 * See: libs/jquery-i18n/jquery.i18n.js
		 *
		 * Parameters:
		 *   (String) language - Language identifier
		 */
		_setupTranslation = function (language) {
			$.i18n.setDictionary(self.Translation[language]);
		},

		/** PrivateFunction: _registerObservers
		 * Register observers. Candy core will now notify the View on changes.
		 */
		_registerObservers = function () {
			Candy.Core.Event.addObserver(Candy.Core.Event.KEYS.CHAT, self.Observer.Chat);
			Candy.Core.Event.addObserver(Candy.Core.Event.KEYS.PRESENCE, self.Observer.Presence);
			Candy.Core.Event.addObserver(Candy.Core.Event.KEYS.PRESENCE_ERROR, self.Observer.PresenceError);
			Candy.Core.Event.addObserver(Candy.Core.Event.KEYS.MESSAGE, self.Observer.Message);
			Candy.Core.Event.addObserver(Candy.Core.Event.KEYS.LOGIN, self.Observer.Login);
		},

		/** PrivateFunction: _registerWindowHandlers
		 * Register window focus / blur / resize handlers.
		 *
		 * jQuery.focus()/.blur() <= 1.5.1 do not work for IE < 9. Fortunately onfocusin/onfocusout will work for them.
		 */
		_registerWindowHandlers = function () {
			// Cross-browser focus handling
		    if ($.browser.msie && !$.browser.version.toString().match('^9')) {
				$(document).focusin(Candy.View.Pane.Window.onFocus).focusout(Candy.View.Pane.Window.onBlur);
			} else {
				$(window).focus(Candy.View.Pane.Window.onFocus).blur(Candy.View.Pane.Window.onBlur);
			}
			$(window).resize(Candy.View.Pane.Chat.fitTabs);
		},

		/** PrivateFunction: _registerToolbarHandlers
		 * Register toolbar handlers and disable sound if cookie says so.
		 */
		_registerToolbarHandlers = function () {
		    $('#emoticons-icon').on('click', function (e) {
				self.Pane.Chat.Context.showEmoticonsMenu(e.currentTarget);
				e.stopPropagation();
			});
			$('#chat-autoscroll-control').click(Candy.View.Pane.Chat.Toolbar.onAutoscrollControlClick);

			$('#chat-sound-control').click(Candy.View.Pane.Chat.Toolbar.onSoundControlClick);
		    if (Candy.Util.cookieExists('candy-nosound')) {
				$('#chat-sound-control').click();
			}
			$('#chat-statusmessage-control').click(Candy.View.Pane.Chat.Toolbar.onStatusMessageControlClick);
		    if (Candy.Util.cookieExists('candy-nostatusmessages')) {
				$('#chat-statusmessage-control').click();
			}
		},

		/** PrivateFunction: _delegateTooltips
		 * Delegate mouseenter on tooltipified element to <Candy.View.Pane.Chat.Tooltip.show>.
		 */
		_delegateTooltips = function () {
			$('body').delegate('li[data-tooltip]', 'mouseenter', Candy.View.Pane.Chat.Tooltip.show);
		};

	/** Function: init
	 * Initialize chat view (setup DOM, register handlers & observers)
	 *
	 * Parameters:
	 *   (jQuery.element) container - Container element of the whole chat view
	 *   (Object) options - Options: see _options field (value passed here gets extended by the default value in _options field)
	 */
    self.init = function (container, options) {
		$.extend(true, _options, options);
		_setupTranslation(_options.language);
		
		// Set path to emoticons
		Candy.Util.Parser.setEmoticonPath(this.getOptions().resources + 'img/emoticons/');

		// Start DOMination...
		_current.container = container;
		_current.container.html(Mustache.to_html(Candy.View.Template.Chat.pane, {
            tooltipEmoticons: $.i18n._('tooltipEmoticons'),
            tooltipSound: $.i18n._('tooltipSound'),
            tooltipAutoscroll: $.i18n._('tooltipAutoscroll'),
            tooltipStatusmessage: $.i18n._('tooltipStatusmessage'),
            tooltipAdministration: $.i18n._('tooltipAdministration'),
            tooltipUsercount: $.i18n._('tooltipUsercount'),
            resourcesPath: this.getOptions().resources
		}, {
			tabs: Candy.View.Template.Chat.tabs,
			rooms: Candy.View.Template.Chat.rooms,
			modal: Candy.View.Template.Chat.modal,
			toolbar: Candy.View.Template.Chat.toolbar,
			soundcontrol: Candy.View.Template.Chat.soundcontrol
		}));

		// ... and let the elements dance.
		_registerWindowHandlers();
		_registerToolbarHandlers();
		_registerObservers();
		_delegateTooltips();
	};

	/** Function: getCurrent
	 * Get current container & roomJid in an object.
	 *
	 * Returns:
	 *   Object containing container & roomJid
	 */
    self.getCurrent = function () {
		return _current;
	};

	/** Function: getOptions
	 * Gets options
	 *
	 * Returns:
	 *   Object
	 */
    self.getOptions = function () {
		return _options;
	};

	return self;
}(Candy.View || {}, jQuery));
/** File: util.js
 * Candy - Chats are not dead yet.
 *
 * Authors:
 *   - Patrick Stadler <patrick.stadler@gmail.com>
 *   - Michael Weibel <michael.weibel@gmail.com>
 *
 * Copyright:
 *   (c) 2011 Amiado Group AG. All rights reserved.
 */

/** Class: Candy.Util
 * Candy utils
 *
 * Parameters:
 *   (Candy.Util) self - itself
 *   (jQuery) $ - jQuery
 */
Candy.Util = (function (self, $) {
	/** Function: jidToId
	 * Translates a jid to a MD5-Id
	 *
	 * Parameters:
	 *   (String) jid - Jid
	 *
	 * Returns:
	 *   MD5-ified jid
	 */
    self.jidToId = function (jid) {
		return MD5.hexdigest(jid);
	};
	
	/** Function: escapeJid
	 * Escapes a jid (node & resource get escaped)
	 *
	 * See:
	 *   XEP-0106
	 *
	 * Parameters:
	 *   (String) jid - Jid
	 *
	 * Returns:
	 *   (String) - escaped jid
	 */
    self.escapeJid = function (jid) {
		var node = Strophe.escapeNode(Strophe.getNodeFromJid(jid)),
			domain = Strophe.getDomainFromJid(jid),
			resource = Strophe.getResourceFromJid(jid);
			
		jid = node + '@' + domain;
		if (resource) {
			jid += '/' + Strophe.escapeNode(resource);
		}
		
		return jid;
	};
	
	/** Function: unescapeJid
	 * Unescapes a jid (node & resource get unescaped)
	 *
	 * See:
	 *   XEP-0106
	 *
	 * Parameters:
	 *   (String) jid - Jid
	 *
	 * Returns:
	 *   (String) - unescaped Jid
	 */
    self.unescapeJid = function (jid) {
		var node = Strophe.unescapeNode(Strophe.getNodeFromJid(jid)),
			domain = Strophe.getDomainFromJid(jid),
			resource = Strophe.getResourceFromJid(jid);
		
		jid = node + '@' + domain;
        if (resource) {
			jid += '/' + Strophe.unescapeNode(resource);
		}
		
		return jid;
	};

	/** Function: crop
	 * Crop a string with the specified length
	 *
	 * Parameters:
	 *   (String) str - String to crop
	 *   (Integer) len - Max length
	 */
    self.crop = function (str, len) {
		if (str.length > len) {
			str = str.substr(0, len - 3) + '...';
		}
		return str;
	};

	/** Function: setCookie
	 * Sets a new cookie
	 *
	 * Parameters:
	 *   (String) name - cookie name
	 *   (String) value - Value
	 *   (Integer) lifetime_days - Lifetime in days
	 */
    self.setCookie = function (name, value, lifetime_days) {
		var exp = new Date();
		exp.setDate(new Date().getDate() + lifetime_days);
		document.cookie = name + '=' + value + ';expires=' + exp.toUTCString() + ';path=/';
	};

	/** Function: cookieExists
	 * Tests if a cookie with the given name exists
	 *
	 * Parameters:
	 *   (String) name - Cookie name
	 *
	 * Returns:
	 *   (Boolean) - true/false
	 */
    self.cookieExists = function (name) {
		return document.cookie.indexOf(name) > -1;
	};

	/** Function: getCookie
	 * Returns the cookie value if there's one with this name, otherwise returns undefined
	 *
	 * Parameters:
	 *   (String) name - Cookie name
	 *
	 * Returns:
	 *   Cookie value or undefined
	 */
    self.getCookie = function (name) {
        if (document.cookie) {
				var regex = new RegExp(escape(name) + '=([^;]*)', 'gm'),
					matches = regex.exec(document.cookie);
            if (matches) {
						return matches[1];
					}
	    }
	};

	/** Function: deleteCookie
	 * Deletes a cookie with the given name
	 *
	 * Parameters:
	 *   (String) name - cookie name
	 */
    self.deleteCookie = function (name) {
		document.cookie = name + '=;expires=Thu, 01-Jan-70 00:00:01 GMT;path=/';
	};

	/** Function: getPosLeftAccordingToWindowBounds
	 * Fetches the window width and element width
	 * and checks if specified position + element width is bigger
	 * than the window width.
	 *
	 * If this evaluates to true, the position gets substracted by the element width.
	 *
	 * Parameters:
	 *   (jQuery.Element) elem - Element to position
	 *   (Integer) pos - Position left
	 *
	 * Returns:
	 *   Object containing `px` (calculated position in pixel) and `alignment` (alignment of the element in relation to pos, either 'left' or 'right')
	 */
    self.getPosLeftAccordingToWindowBounds = function (elem, pos) {
        var windowWidth = $(document).width(),
			elemWidth = elem.outerWidth(),
			marginDiff = elemWidth - elem.outerWidth(true),
			backgroundPositionAlignment = 'left';

		if (pos + elemWidth >= windowWidth) {
			pos -= elemWidth - marginDiff;
			backgroundPositionAlignment = 'right';
		}

		return { px: pos, backgroundPositionAlignment: backgroundPositionAlignment };
	};

	/** Function: getPosTopAccordingToWindowBounds
	 * Fetches the window height and element height
	 * and checks if specified position + element height is bigger
	 * than the window height.
	 *
	 * If this evaluates to true, the position gets substracted by the element height.
	 *
	 * Parameters:
	 *   (jQuery.Element) elem - Element to position
	 *   (Integer) pos - Position top
	 *
	 * Returns:
	 *   Object containing `px` (calculated position in pixel) and `alignment` (alignment of the element in relation to pos, either 'top' or 'bottom')
	 */
    self.getPosTopAccordingToWindowBounds = function (elem, pos) {
		var windowHeight = $(document).height(),
			elemHeight = elem.outerHeight(),
			marginDiff = elemHeight - elem.outerHeight(true),
			backgroundPositionAlignment = 'top';

		if (pos + elemHeight >= windowHeight) {
			pos -= elemHeight - marginDiff;
			backgroundPositionAlignment = 'bottom';
		}

		return { px: pos, backgroundPositionAlignment: backgroundPositionAlignment };
	};

	/** Function: localizedTime
	 * Localizes ISO-8610 Date with the time/dateformat specified in the translation.
	 *
	 * See: libs/dateformat/dateFormat.js
	 * See: src/view/translation.js
	 * See: jquery-i18n/jquery.i18n.js
	 *
	 * Parameters:
	 *   (String) dateTime - ISO-8610 Datetime
	 *
	 * Returns:
	 *   If current date is equal to the date supplied, format with timeFormat, otherwise with dateFormat
	 */
    self.localizedTime = function (dateTime) {
		if (dateTime === undefined) {
			return undefined;
		}

		var date = self.iso8601toDate(dateTime);
        if (date.toDateString() === new Date().toDateString()) {
			return date.format($.i18n._('timeFormat'));
		} else {
			return date.format($.i18n._('dateFormat'));
		}
    };

    self.formatAMPM = function (date) {
        var hours = date.getHours();
        var minutes = date.getMinutes();
        var ampm = hours >= 12 ? 'pm' : 'am';
        hours = hours % 12;
        hours = hours ? hours : 12; // the hour '0' should be '12'
        minutes = minutes < 10 ? '0' + minutes : minutes;
        var strTime = hours + ':' + minutes + ' ' + ampm;
        return strTime;
    }

	/** Function: iso8610toDate
	 * Parses a ISO-8610 Date to a Date-Object.
	 *
	 * Uses a fallback if the client's browser doesn't support it.
	 *
	 * Quote:
	 *   ECMAScript revision 5 adds native support for ISO-8601 dates in the Date.parse method,
	 *   but many browsers currently on the market (Safari 4, Chrome 4, IE 6-8) do not support it.
	 *
	 * Credits:
	 *  <Colin Snover at http://zetafleet.com/blog/javascript-dateparse-for-iso-8601>
	 *
	 * Parameters:
	 *   (String) date - ISO-8610 Date
	 *
	 * Returns:
	 *   Date-Object
	 */
    self.iso8601toDate = function (date) {
        var timestamp = Date.parse(date), minutesOffset = 0;
        if (isNaN(timestamp)) {
			var struct = /^(\d{4}|[+\-]\d{6})-(\d{2})-(\d{2})(?:[T ](\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?))?/.exec(date);
            if (struct) {
                if (struct[8] !== 'Z') {
					minutesOffset = +struct[10] * 60 + (+struct[11]);
                    if (struct[9] === '+') {
						minutesOffset = -minutesOffset;
					}
				}
				return new Date(+struct[1], +struct[2] - 1, +struct[3], +struct[4], +struct[5] + minutesOffset, +struct[6], struct[7] ? +struct[7].substr(0, 3) : 0);
			} else {
				// XEP-0091 date
				timestamp = Date.parse(date.replace(/^(\d{4})(\d{2})(\d{2})/, '$1-$2-$3') + 'Z');
			}
        }
        return new Date(timestamp);
	};

	/** Function: isEmptyObject
	 * IE7 doesn't work with jQuery.isEmptyObject (<=1.5.1), workaround.
	 *
	 * Parameters:
	 *   (Object) obj - the object to test for
	 *
	 * Returns:
	 *   Boolean true or false.
	 */
    self.isEmptyObject = function (obj) {
		var prop;
        for (prop in obj) {
			if (obj.hasOwnProperty(prop)) {
				return false;
			}
		}
		return true;
	};

	/** Function: forceRedraw
	 * Fix IE7 not redrawing under some circumstances.
	 *
	 * Parameters:
	 *   (jQuery.element) elem - jQuery element to redraw
	 */
    self.forceRedraw = function (elem) {
        elem.css({ display: 'none' });
        setTimeout(function () {
            this.css({ display: 'block' });
		}.bind(elem), 1);
	};

	/** Class: Candy.Util.Parser
	 * Parser for emoticons, links and also supports escaping.
	 */
	self.Parser = {
		/** PrivateVariable: _emoticonPath
		 * Path to emoticons.
		 *
		 * Use setEmoticonPath() to change it
		 */
		_emoticonPath: '',
		
		/** Function: setEmoticonPath
		 * Set emoticons location.
		 *
		 * Parameters:
		 *   (String) path - location of emoticons with trailing slash
		 */
        setEmoticonPath: function (path) {
			this._emoticonPath = path;
		},

		/** Array: emoticons
		 * Array containing emoticons to be replaced by their images.
		 *
		 * Can be overridden/extended.
		 */
		emoticons: [
			{
				plain: ':)',
				regex: /((\s):-?\)|:-?\)(\s|$))/gm,
				image: 'Smiling.png'
			},
			{
				plain: ';)',
				regex: /((\s);-?\)|;-?\)(\s|$))/gm,
				image: 'Winking.png'
			},
			{
				plain: ':D',
				regex: /((\s):-?D|:-?D(\s|$))/gm,
				image: 'Grinning.png'
			},
			{
				plain: ';D',
				regex: /((\s);-?D|;-?D(\s|$))/gm,
				image: 'Grinning_Winking.png'
			},
			{
				plain: ':(',
				regex: /((\s):-?\(|:-?\((\s|$))/gm,
				image: 'Unhappy.png'
			},
			{
				plain: '^^',
				regex: /((\s)\^\^|\^\^(\s|$))/gm,
				image: 'Happy_3.png'
			},
			{
				plain: ':P',
				regex: /((\s):-?P|:-?P(\s|$))/igm,
				image: 'Tongue_Out.png'
			},
			{
				plain: ';P',
				regex: /((\s);-?P|;-?P(\s|$))/igm,
				image: 'Tongue_Out_Winking.png'
			},
			{
				plain: ':S',
				regex: /((\s):-?S|:-?S(\s|$))/igm,
				image: 'Confused.png'
			},
			{
				plain: ':/',
				regex: /((\s):-?\/|:-?\/(\s|$))/gm,
				image: 'Uncertain.png'
			},
			{
				plain: '8)',
				regex: /((\s)8-?\)|8-?\)(\s|$))/gm,
				image: 'Sunglasses.png'
			},
			{
				plain: '$)',
				regex: /((\s)\$-?\)|\$-?\)(\s|$))/gm,
				image: 'Greedy.png'
			},
			{
				plain: 'oO',
				regex: /((\s)oO|oO(\s|$))/gm,
				image: 'Huh.png'
			},
			{
				plain: ':x',
				regex: /((\s):x|:x(\s|$))/gm,
				image: 'Lips_Sealed.png'
			},
			{
				plain: ':666:',
				regex: /((\s):666:|:666:(\s|$))/gm,
				image: 'Devil.png'
			},
			{
				plain: '<3',
				regex: /((\s)&lt;3|&lt;3(\s|$))/gm,
				image: 'Heart.png'
			}
		],

		/** Function: emotify
		 * Replaces text-emoticons with their image equivalent.
		 *
		 * Parameters:
		 *   (String) text - Text to emotify
		 *
		 * Returns:
		 *   Emotified text
		 */
        emotify: function (text) {
			var i;
            for (i = this.emoticons.length - 1; i >= 0; i--) {
				text = text.replace(this.emoticons[i].regex, '$2<img class="emoticon" alt="$1" src="' + this._emoticonPath + this.emoticons[i].image + '" />$3');
			}
			return text;
		},

		/** Function: linkify
		 * Replaces URLs with a HTML-link.
		 *
		 * Parameters:
		 *   (String) text - Text to linkify
		 *
		 * Returns:
		 *   Linkified text
		 */
        linkify: function (text) {
			text = text.replace(/(^|[^\/])(www\.[^\.]+\.[\S]+(\b|$))/gi, '$1http://$2');
			return text.replace(/(\b(https?|ftp|file):\/\/[\-A-Z0-9+&@#\/%?=~_|!:,.;]*[\-A-Z0-9+&@#\/%=~_|])/ig, '<a href="$1" target="_blank">$1</a>');
		},

		/** Function: escape
		 * Escapes a text using a jQuery function (like htmlspecialchars in PHP)
		 *
		 * Parameters:
		 *   (String) text - Text to escape
		 *
		 * Returns:
		 *   Escaped text
		 */
        escape: function (text) {
			return $('<div/>').text(text).html();
		},

		/** Function: all
		 * Does everything of the parser: escaping, linkifying and emotifying.
		 *
		 * Parameters:
		 *   (String) text - Text to parse
		 *
		 * Returns:
		 *   Parsed text
		 */
        all: function (text) {
            if (text) {
				text = this.escape(text);
				text = this.linkify(text);
				text = this.emotify(text);
			}
			return text;
		}
	};

	return self;
}(Candy.Util || {}, jQuery));


/** Class: Candy.Util.Observable
 * A class can be extended with the observable to be able to notify observers
 */
Candy.Util.Observable = (function (self) {
	/** PrivateObject: _observers
	 * List of observers
	 */
	var _observers = {};

	/** Function: addObserver
	 * Add an observer to the observer list
	 *
	 * Parameters:
	 *   (String) key - The key the observer listens to
	 *   (Callback) obj - The observer callback
	 */
    self.addObserver = function (key, obj) {
		if (_observers[key] === undefined) {
			_observers[key] = [];
		}
		_observers[key].push(obj);
	};

	/** Function: deleteObserver
	 * Delete observer from list
	 *
	 * Parameters:
	 *   (String) key - Key in which the observer lies
	 *   (Callback) obj - The observer callback to be deleted
	 */
    self.deleteObserver = function (key, obj) {
		delete _observers[key][obj];
	};

	/** Function: clearObservers
	 * Deletes all observers in list
	 *
	 * Parameters:
	 *   (String) key - If defined, remove observers of this key, otherwise remove all including all keys.
	 */
    self.clearObservers = function (key) {
		if (key !== undefined) {
			_observers[key] = [];
		} else {
			_observers = {};
		}
	};

	/** Function: notifyObservers
	 * Notify all of its observers of a certain event.
	 *
	 * Parameters:
	 *   (String) key - Key to notify
	 *   (Object) arg - An argument passed to the update-method of the observers
	 */
    self.notifyObservers = function (key, arg) {
		var observer = _observers[key], i;
        for (i = observer.length - 1; i >= 0; i--) {
			observer[i].update(self, arg);
		}
	};

	return self;
}(Candy.Util.Observable || {}));
/** File: action.js
 * Candy - Chats are not dead yet.
 *
 * Authors:
 *   - Patrick Stadler <patrick.stadler@gmail.com>
 *   - Michael Weibel <michael.weibel@gmail.com>
 *
 * Copyright:
 *   (c) 2011 Amiado Group AG. All rights reserved.
 */

/** Class: Candy.Core.Action
 * Chat Actions (basicly a abstraction of Jabber commands)
 *
 * Parameters:
 *   (Candy.Core.Action) self - itself
 *   (Strophe) Strophe - Strophe
 *   (jQuery) $ - jQuery
 */
Candy.Core.Action = (function (self, Strophe, $) {
	/** Class: Candy.Core.Action.Jabber
	 * Jabber actions
	 */
	self.Jabber = {
		/** Function: Version
		 * Replies to a version request
		 *
		 * Parameters:
		 *   (jQuery.element) msg - jQuery element
		 */
        Version: function (msg) {
            Candy.Core.getConnection().send($iq({ type: 'result', to: msg.attr('from'), from: msg.attr('to'), id: msg.attr('id') }).c('query', { name: Candy.about.name, version: Candy.about.version, os: navigator.userAgent }));
		},

		/** Function: Roster
		 * Sends a request for a roster
		 */
        Roster: function () {
            Candy.Core.getConnection().send($iq({ type: 'get', xmlns: Strophe.NS.CLIENT }).c('query', { xmlns: Strophe.NS.ROSTER }).tree());
		},

		/** Function: Presence
		 * Sends a request for presence
		 *
		 * Parameters:
		 *   (Object) attr - Optional attributes
		 */
        Presence: function (attr) {
			Candy.Core.getConnection().send($pres(attr).tree());
		},

		/** Function: Services
		 * Sends a request for disco items
		 */
        Services: function () {
            Candy.Core.getConnection().send($iq({ type: 'get', xmlns: Strophe.NS.CLIENT }).c('query', { xmlns: Strophe.NS.DISCO_ITEMS }).tree());
		},

		/** Function: Autojoin
		 * When Candy.Core.getOptions().autojoin is true, request autojoin bookmarks (OpenFire)
		 *
		 * Otherwise, if Candy.Core.getOptions().autojoin is an array, join each channel specified.
		 */
        Autojoin: function () {
			// Request bookmarks
            if (Candy.Core.getOptions().autojoin === true) {
                Candy.Core.getConnection().send($iq({ type: 'get', xmlns: Strophe.NS.CLIENT }).c('query', { xmlns: Strophe.NS.PRIVATE }).c('storage', { xmlns: Strophe.NS.BOOKMARKS }).tree());
			// Join defined rooms
            } else if ($.isArray(Candy.Core.getOptions().autojoin)) {
                $.each(Candy.Core.getOptions().autojoin, function () {
					self.Jabber.Room.Join(this.valueOf());
				});
			}
		},

		/** Function: ResetIgnoreList
		 * Create new ignore privacy list (and reset the old one, if it exists).
		 */
        ResetIgnoreList: function () {
            Candy.Core.getConnection().send($iq({ type: 'set', from: Candy.Core.getUser().getJid(), id: 'set1' })
				.c('query', { xmlns: Strophe.NS.PRIVACY }).c('list', { name: 'ignore' }).c('item', { 'action': 'allow', 'order': '0' }).tree());
		},

		/** Function: RemoveIgnoreList
		 * Remove an existing ignore list.
		 */
        RemoveIgnoreList: function () {
            Candy.Core.getConnection().send($iq({ type: 'set', from: Candy.Core.getUser().getJid(), id: 'remove1' })
				.c('query', { xmlns: Strophe.NS.PRIVACY }).c('list', { name: 'ignore' }).tree());
		},

		/** Function: GetIgnoreList
		 * Get existing ignore privacy list when connecting.
		 */
        GetIgnoreList: function () {
            Candy.Core.getConnection().send($iq({ type: 'get', from: Candy.Core.getUser().getJid(), id: 'get1' })
				.c('query', { xmlns: Strophe.NS.PRIVACY }).c('list', { name: 'ignore' }).tree());
		},

		/** Function: SetIgnoreListActive
		 * Set ignore privacy list active
		 */
        SetIgnoreListActive: function () {
            Candy.Core.getConnection().send($iq({ type: 'set', from: Candy.Core.getUser().getJid(), id: 'set2' })
				.c('query', { xmlns: Strophe.NS.PRIVACY }).c('active', { name: 'ignore' }).tree());
		},

		/** Function: GetJidIfAnonymous
		 * On anonymous login, initially we don't know the jid and as a result, Candy.Core._user doesn't have a jid.
		 * Check if user doesn't have a jid and get it if necessary from the connection.
		 */
        GetJidIfAnonymous: function () {
			if (!Candy.Core.getUser().getJid()) {
				Candy.Core.log("[Jabber] Anonymous login");
				Candy.Core.getUser().data.jid = Candy.Core.getConnection().jid;
			}
		},

		/** Class: Candy.Core.Action.Jabber.Room
		 * Room-specific commands
		 */
		Room: {
			/** Function: Join
			 * Requests disco of specified room and joins afterwards.
			 *
			 * TODO:
			 *   maybe we should wait for disco and later join the room?
			 *   but what if we send disco but don't want/can join the room
			 *
			 * Parameters:
			 *   (String) roomJid - Room to join
			 *   (String) password - [optional] Password for the room
			 */
            Join: function (roomJid, password) {
				self.Jabber.Room.Disco(roomJid);
				Candy.Core.getConnection().muc.join(roomJid, Candy.Core.getUser().getNick(), null, null, password);
			},

			/** Function: Leave
			 * Leaves a room.
			 *
			 * Parameters:
			 *   (String) roomJid - Room to leave
			 */
            Leave: function (roomJid) {
                Candy.Core.getConnection().muc.leave(roomJid, Candy.Core.getRoom(roomJid).getUser().getNick(), function () { });
			},

			/** Function: Disco
			 * Requests <disco info of a room at http://xmpp.org/extensions/xep-0045.html#disco-roominfo>.
			 *
			 * Parameters:
			 *   (String) roomJid - Room to get info for
			 */
            Disco: function (roomJid) {
                Candy.Core.getConnection().send($iq({ type: 'get', from: Candy.Core.getUser().getJid(), to: roomJid, id: 'disco3' }).c('query', { xmlns: Strophe.NS.DISCO_INFO }).tree());
			},

			/** Function: Message
			 * Send message
			 *
			 * Parameters:
			 *   (String) roomJid - Room to which send the message into
			 *   (String) msg - Message
			 *   (String) type - "groupchat" or "chat" ("chat" is for private messages)
			 *
			 * Returns:
			 *   (Boolean) - true if message is not empty after trimming, false otherwise.
			 */
            Message: function (roomJid, msg, type) {
				// Trim message
				msg = $.trim(msg);
                if (msg === '') {
					return false;
				}
				Candy.Core.getConnection().muc.message(Candy.Util.escapeJid(roomJid), undefined, msg, type);
				return true;
			},

			/** Function: IgnoreUnignore
			 * Checks if the user is already ignoring the target user, if yes: unignore him, if no: ignore him.
			 *
			 * Uses the ignore privacy list set on connecting.
			 *
			 * Parameters:
			 *   (String) userJid - Target user jid
			 */
            IgnoreUnignore: function (userJid) {
				Candy.Core.getUser().addToOrRemoveFromPrivacyList('ignore', userJid);
				Candy.Core.Action.Jabber.Room.UpdatePrivacyList();
			},

			/** Function: UpdatePrivacyList
			 * Updates privacy list according to the privacylist in the currentUser
			 */
            UpdatePrivacyList: function () {
				var currentUser = Candy.Core.getUser(),
					iq = $iq({ type: 'set', from: currentUser.getJid(), id: 'edit1' })
						.c('query', { xmlns: 'jabber:iq:privacy' })
							.c('list', { name: 'ignore' }),
					privacyList = currentUser.getPrivacyList('ignore');
				if (privacyList.length > 0) {
                    $.each(privacyList, function (index, jid) {
                        iq.c('item', { type: 'jid', value: Candy.Util.escapeJid(jid), action: 'deny', order: index })
							.c('message').up().up();
					});
				} else {
                    iq.c('item', { action: 'allow', order: '0' });
				}
				Candy.Core.getConnection().send(iq.tree());
			},

			/** Class: Candy.Core.Action.Jabber.Room.Admin
			 * Room administration commands
			 */
			Admin: {
				/** Function: UserAction
				 * Kick or ban a user
				 *
				 * Parameters:
				 *   (String) roomJid - Room in which the kick/ban should be done
				 *   (String) userJid - Victim
				 *   (String) type - "kick" or "ban"
				 *   (String) msg - Reason
				 *
				 * Returns:
				 *   (Boolean) - true if sent successfully, false if type is not one of "kick" or "ban".
				 */
                UserAction: function (roomJid, userJid, type, reason) {
					var iqId,
						itemObj = { nick: Strophe.escapeNode(Strophe.getResourceFromJid(userJid)) };
                    switch (type) {
						case 'kick':
							iqId = 'kick1';
							itemObj.role = 'none';
							break;
						case 'ban':
							iqId = 'ban1';
							itemObj.affiliation = 'outcast';
							break;
						default:
							return false;
					}
                    Candy.Core.getConnection().send($iq({ type: 'set', from: Candy.Core.getUser().getJid(), to: roomJid, id: iqId }).c('query', { xmlns: Strophe.NS.MUC_ADMIN }).c('item', itemObj).c('reason').t(reason).tree());
					return true;
				},

				/** Function: SetSubject
				 * Sets subject (topic) of a room.
				 *
				 * Parameters:
				 *   (String) roomJid - Room
				 *   (String) subject - Subject to set
				 */
                SetSubject: function (roomJid, subject) {
					Candy.Core.getConnection().muc.setTopic(roomJid, subject);
				}
			}
		}
	};

	return self;
}(Candy.Core.Action || {}, Strophe, jQuery));
/** File: chatRoom.js
 * Candy - Chats are not dead yet.
 *
 * Authors:
 *   - Patrick Stadler <patrick.stadler@gmail.com>
 *   - Michael Weibel <michael.weibel@gmail.com>
 *
 * Copyright:
 *   (c) 2011 Amiado Group AG. All rights reserved.
 */

/** Class: Candy.Core.ChatRoom
 * Candy Chat Room
 *
 * Parameters:
 *   (String) roomJid - Room jid
 */
Candy.Core.ChatRoom = function (roomJid) {
	/** Object: room
	 * Object containing roomJid and name.
	 */
	this.room = {
		jid: roomJid,
		name: null
	};

	/** Variable: user
	 * Current local user of this room.
	 */
	this.user = null;

	/** Variable: Roster
	 * Candy.Core.ChatRoster instance
	 */
	this.roster = new Candy.Core.ChatRoster();

	/** Function: setUser
	 * Set user of this room.
	 *
	 * Parameters:
	 *   (Candy.Core.ChatUser) user - Chat user
	 */
    this.setUser = function (user) {
		this.user = user;
	};

	/** Function: getUser
	 * Get current local user
	 *
	 * Returns:
	 *   (Object) - Candy.Core.ChatUser instance or null
	 */
    this.getUser = function () {
		return this.user;
	};

	/** Function: getJid
	 * Get room jid
	 *
	 * Returns:
	 *   (String) - Room jid
	 */
    this.getJid = function () {
		return this.room.jid;
	};

	/** Function: setName
	 * Set room name
	 *
	 * Parameters:
	 *   (String) name - Room name
	 */
    this.setName = function (name) {
		this.room.name = name;
	};

	/** Function: getName
	 * Get room name
	 *
	 * Returns:
	 *   (String) - Room name
	 */
    this.getName = function () {
		return this.room.name;
	};

	/** Function: setRoster
	 * Set roster of room
	 *
	 * Parameters:
	 *   (Candy.Core.ChatRoster) roster - Chat roster
	 */
    this.setRoster = function (roster) {
		this.roster = roster;
	};

	/** Function: getRoster
	 * Get roster
	 *
	 * Returns
	 *   (Candy.Core.ChatRoster) - instance
	 */
    this.getRoster = function () {
		return this.roster;
	};
};
/** File: chatRoster.js
 * Candy - Chats are not dead yet.
 *
 * Authors:
 *   - Patrick Stadler <patrick.stadler@gmail.com>
 *   - Michael Weibel <michael.weibel@gmail.com>
 *
 * Copyright:
 *   (c) 2011 Amiado Group AG. All rights reserved.
 */

/** Class: Candy.Core.ChatRoster
 * Chat Roster
 */
Candy.Core.ChatRoster = function () {
	/** Object: items
	 * Roster items
	 */
	this.items = {};

	/** Function: add
	 * Add user to roster
	 *
	 * Parameters:
	 *   (Candy.Core.ChatUser) user - User to add
	 */
    this.add = function (user) {
		this.items[user.getJid()] = user;
	};

	/** Function: remove
	 * Remove user from roster
	 *
	 * Parameters:
	 *   (String) jid - User jid
	 */
    this.remove = function (jid) {
		delete this.items[jid];
	};

	/** Function: get
	 * Get user from roster
	 *
	 * Parameters:
	 *   (String) jid - User jid
	 *
	 * Returns:
	 *   (Candy.Core.ChatUser) - User
	 */
    this.get = function (jid) {
		return this.items[jid];
	};

	/** Function: getAll
	 * Get all items
	 *
	 * Returns:
	 *   (Object) - all roster items
	 */
    this.getAll = function () {
		return this.items;
	};
};
/** File: chatUser.js
 * Candy - Chats are not dead yet.
 *
 * Authors:
 *   - Patrick Stadler <patrick.stadler@gmail.com>
 *   - Michael Weibel <michael.weibel@gmail.com>
 *
 * Copyright:
 *   (c) 2011 Amiado Group AG. All rights reserved.
 */

/** Class: Candy.Core.ChatUser
 * Chat User
 */
Candy.Core.ChatUser = function (jid, nick, affiliation, role) {
	/** Constant: ROLE_MODERATOR
	 * Moderator role
	 */
    this.ROLE_MODERATOR = 'moderator';

	/** Constant: AFFILIATION_OWNER
	 * Affiliation owner
	 */
	this.AFFILIATION_OWNER = 'owner';

	/** Object: data
	 * User data containing:
	 * - jid
	 * - nick
	 * - affiliation
	 * - role
	 * - privacyLists
	 * - customData to be used by e.g. plugins
	 */
	this.data = {
		jid: jid,
		nick: Strophe.unescapeNode(nick),
		affiliation: affiliation,
		role: role,
		privacyLists: {},
		customData: {}
	};
	
	/** Function: getJid
	 * Gets an unescaped user jid
	 *
	 * See:
	 *   <Candy.Util.unescapeJid>
	 *
	 * Returns:
	 *   (String) - jid
	 */
    this.getJid = function () {
        if (this.data.jid) {
			return Candy.Util.unescapeJid(this.data.jid);
		}
		return;
	};
	
	/** Function: getEscapedJid
	 * Escapes the user's jid (node & resource get escaped)
	 *
	 * See:
	 *   <Candy.Util.escapeJid>
	 *
	 * Returns:
	 *   (String) - escaped jid
	 */
    this.getEscapedJid = function () {
		return Candy.Util.escapeJid(this.data.jid);
	};

	/** Function: getNick
	 * Gets user nick
	 *
	 * Returns:
	 *   (String) - nick
	 */
    this.getNick = function () {
		return Strophe.unescapeNode(this.data.nick);
	};

	/** Function: getRole
	 * Gets user role
	 *
	 * Returns:
	 *   (String) - role
	 */
    this.getRole = function () {
		return this.data.role;
	};

	/** Function: getAffiliation
	 * Gets user affiliation
	 *
	 * Returns:
	 *   (String) - affiliation
	 */
    this.getAffiliation = function () {
		return this.data.affiliation;
	};

	/** Function: isModerator
	 * Check if user is moderator. Depends on the room.
	 *
	 * Returns:
	 *   (Boolean) - true if user has role moderator or affiliation owner
	 */
    this.isModerator = function () {
		return this.getRole() === this.ROLE_MODERATOR || this.getAffiliation() === this.AFFILIATION_OWNER;
	};

	/** Function: addToOrRemoveFromPrivacyList
	 * Convenience function for adding/removing users from ignore list.
	 *
	 * Check if user is already in privacy list. If yes, remove it. If no, add it.
	 *
	 * Parameters:
	 *   (String) list - To which privacy list the user should be added / removed from. Candy supports curently only the "ignore" list.
	 *   (String) jid  - User jid to add/remove
	 *
	 * Returns:
	 *   (Array) - Current privacy list.
	 */
    this.addToOrRemoveFromPrivacyList = function (list, jid) {
		if (!this.data.privacyLists[list]) {
			this.data.privacyLists[list] = [];
		}
		var index = -1;
		if ((index = this.data.privacyLists[list].indexOf(jid)) !== -1) {
			this.data.privacyLists[list].splice(index, 1);
		} else {
			this.data.privacyLists[list].push(jid);
		}
		return this.data.privacyLists[list];
	};

	/** Function: getPrivacyList
	 * Returns the privacy list of the listname of the param.
	 *
	 * Parameters:
	 *   (String) list - To which privacy list the user should be added / removed from. Candy supports curently only the "ignore" list.
	 *
	 * Returns:
	 *   (Array) - Privacy List
	 */
    this.getPrivacyList = function (list) {
		if (!this.data.privacyLists[list]) {
			this.data.privacyLists[list] = [];
		}
		return this.data.privacyLists[list];
	};

	/** Function: isInPrivacyList
	 * Tests if this user ignores the user provided by jid.
	 *
	 * Parameters:
	 *   (String) list - Privacy list
	 *   (String) jid  - Jid to test for
	 *
	 * Returns:
	 *   (Boolean)
	 */
    this.isInPrivacyList = function (list, jid) {
		if (!this.data.privacyLists[list]) {
			return false;
		}
		return this.data.privacyLists[list].indexOf(jid) !== -1;
	};

	/** Function: setCustomData
	 * Stores custom data
	 *
	 *	Parameter:
	 *	  (Object) data - Object containing custom data
	 */
    this.setCustomData = function (data) {
		this.data.customData = data;
	};

	/** Function: getCustomData
	 * Retrieve custom data
	 *
	 *	Returns:
	 *	  (Object) - Object containing custom data
	 */
    this.getCustomData = function () {
		return this.data.customData;
	};
};
/** File: event.js
 * Candy - Chats are not dead yet.
 *
 * Authors:
 *   - Patrick Stadler <patrick.stadler@gmail.com>
 *   - Michael Weibel <michael.weibel@gmail.com>
 *
 * Copyright:
 *   (c) 2011 Amiado Group AG. All rights reserved.
 */

/** Class: Candy.Core.Event
 * Chat Events
 *
 * Parameters:
 *   (Candy.Core.Event) self - itself
 *   (Strophe) Strophe - Strophe
 *   (jQuery) $ - jQuery
 *   (Candy.Util.Observable) observable - Observable to mixin
 */
Candy.Core.Event = (function (self, Strophe, $, observable) {
	/**
	 * Mixin observable
	 */
	var i;
	for (i in observable) {
		if (observable.hasOwnProperty(i)) {
			self[i] = observable[i];
		}
	}

	/** Enum: KEYS
	 * Observer keys
	 *
	 * CHAT - Chat events
	 * PRESENCE - Presence events
	 * MESSAGE - Message events
	 * LOGIN - Login event
	 */
	self.KEYS = {
		CHAT: 1,
		PRESENCE: 2,
		MESSAGE: 3,
		LOGIN: 4,
		PRESENCE_ERROR: 5
	};

	/** Class: Candy.Core.Event.Strophe
	 * Strophe-related events
	 */
	self.Strophe = {
		/** Function: Connect
		 * Acts on strophe status events and notifies view.
		 *
		 * Parameters:
		 *   (Strophe.Status) status - Strophe statuses
		 */
        Connect: function (status) {
            switch (status) {
				case Strophe.Status.CONNECTED:
					Candy.Core.log('[Connection] Connected');
					Candy.Core.Action.Jabber.GetJidIfAnonymous();
					// fall through because the same things need to be done :)
				case Strophe.Status.ATTACHED:
					Candy.Core.log('[Connection] Attached');
					Candy.Core.Action.Jabber.Presence();
					Candy.Core.Action.Jabber.Autojoin();
					Candy.Core.Action.Jabber.GetIgnoreList();
					break;

				case Strophe.Status.DISCONNECTED:
					Candy.Core.log('[Connection] Disconnected');
					break;

				case Strophe.Status.AUTHFAIL:
					Candy.Core.log('[Connection] Authentication failed');
					break;

				case Strophe.Status.CONNECTING:
					Candy.Core.log('[Connection] Connecting');
					break;

				case Strophe.Status.DISCONNECTING:
					Candy.Core.log('[Connection] Disconnecting');
					break;

				case Strophe.Status.AUTHENTICATING:
					Candy.Core.log('[Connection] Authenticating');
					break;

				case Strophe.Status.ERROR:
				case Strophe.Status.CONNFAIL:
					Candy.Core.log('[Connection] Failed (' + status + ')');
					break;

				default:
					Candy.Core.log('[Connection] What?!');
					break;
			}

            self.notifyObservers(self.KEYS.CHAT, { type: 'connection', status: status });
		}
	};

	/** Function: Login
	 * Notify view that the login window should be displayed
	 *
	 * Parameters:
	 *   (String) presetJid - Preset user JID
	 */
    self.Login = function (presetJid) {
        self.notifyObservers(self.KEYS.LOGIN, { presetJid: presetJid });
	};

	/** Class: Candy.Core.Event.Jabber
	 * Jabber related events
	 */
	self.Jabber = {
		/** Function: Version
		 * Responds to a version request
		 *
		 * Parameters:
		 *   (String) msg - Raw XML Message
		 *
		 * Returns:
		 *   (Boolean) - true
		 */
        Version: function (msg) {
			Candy.Core.log('[Jabber] Version');
			Candy.Core.Action.Jabber.Version($(msg));
			return true;
		},

		/** Function: Presence
		 * Acts on a presence event
		 *
		 * Parameters:
		 *   (String) msg - Raw XML Message
		 *
		 * Returns:
		 *   (Boolean) - true
		 */
        Presence: function (msg) {
			Candy.Core.log('[Jabber] Presence');
			msg = $(msg);
            if (msg.children('x[xmlns^="' + Strophe.NS.MUC + '"]').length > 0) {
				if (msg.attr('type') === 'error') {
					self.Jabber.Room.PresenceError(msg);
				} else {
					self.Jabber.Room.Presence(msg);
				}
			}
			return true;
		},

		/** Function: Bookmarks
		 * Acts on a bookmarks event. When a bookmark has the attribute autojoin set, joins this room.
		 *
		 * Parameters:
		 *   (String) msg - Raw XML Message
		 *
		 * Returns:
		 *   (Boolean) - true
		 */
        Bookmarks: function (msg) {
			Candy.Core.log('[Jabber] Bookmarks');
			// Autojoin bookmarks (Openfire)
            $('conference', msg).each(function () {
				var item = $(this);
                if (item.attr('autojoin')) {
					Candy.Core.Action.Jabber.Room.Join(item.attr('jid'));
				}
			});
			return true;
		},

		/** Function: PrivacyList
		 * Acts on a privacy list event and sets up the current privacy list of this user.
		 *
		 * If no privacy list has been added yet, create the privacy list and listen again to this event.
		 *
		 * Parameters:
		 *   (String) msg - Raw XML Message
		 *
		 * Returns:
		 *   (Boolean) - false to disable the handler after first call.
		 */
        PrivacyList: function (msg) {
			Candy.Core.log('[Jabber] PrivacyList');
			var currentUser = Candy.Core.getUser();

            $('list[name="ignore"] item', msg).each(function () {
				var item = $(this);
				if (item.attr('action') === 'deny') {
					currentUser.addToOrRemoveFromPrivacyList('ignore', item.attr('value'));
				}
			});
			Candy.Core.Action.Jabber.SetIgnoreListActive();
			return false;
		},

		/** Function: PrivacyListError
		 * Acts when a privacy list error has been received.
		 *
		 * Currently only handles the case, when a privacy list doesn't exist yet and creates one.
		 *
		 * Parameters:
		 *   (String) msg - Raw XML Message
		 *
		 * Returns:
		 *   (Boolean) - false to disable the handler after first call.
		 */
        PrivacyListError: function (msg) {
			Candy.Core.log('[Jabber] PrivacyListError');
			// check if msg says that privacyList doesn't exist
			if ($('error[code="404"][type="cancel"] item-not-found', msg)) {
				Candy.Core.Action.Jabber.ResetIgnoreList();
				Candy.Core.Action.Jabber.SetIgnoreListActive();
			}
			return false;
		},

		/** Function: Message
		 * Acts on room, admin and server messages and notifies the view if required.
		 *
		 * Parameters:
		 *   (String) msg - Raw XML Message
		 *
		 * Returns:
		 *   (Boolean) - true
		 */
        Message: function (msg) {
			Candy.Core.log('[Jabber] Message');
			var msg = $(msg),
				fromJid = msg.attr('from'),
				type = msg.attr('type'),
				toJid = msg.attr('to');
			// Room message
            if (fromJid !== Strophe.getDomainFromJid(fromJid) && (type === 'groupchat' || type === 'chat' || type === 'error')) {
				self.Jabber.Room.Message(msg);
			// Admin message
            } else if (!toJid && fromJid === Strophe.getDomainFromJid(fromJid)) {
				self.notifyObservers(self.KEYS.CHAT, { type: (type || 'message'), message: msg.children('body').text() });
			// Server Message
            } else if (toJid && fromJid === Strophe.getDomainFromJid(fromJid)) {
				self.notifyObservers(self.KEYS.CHAT, { type: (type || 'message'), subject: msg.children('subject').text(), message: msg.children('body').text() });
			}
			return true;
		},

		/** Class: Candy.Core.Event.Jabber.Room
		 * Room specific events
		 */
		Room: {
			/** Function: Leave
			 * Leaves a room and cleans up related data and notifies view.
			 *
			 * Parameters:
			 *   (String) msg - Raw XML Message
			 *
			 * Returns:
			 *   (Boolean) - true
			 */
            Leave: function (msg) {
				Candy.Core.log('[Jabber:Room] Leave');
				var msg = $(msg),
					from = msg.attr('from'),
					roomJid = Strophe.getBareJidFromJid(from);

				// if room is not joined yet, ignore.
				if (!Candy.Core.getRoom(roomJid)) {
					return false;
				}

				var roomName = Candy.Core.getRoom(roomJid).getName(),
					item = msg.find('item'),
					type = 'leave',
					reason,
					actor;

				delete Candy.Core.getRooms()[roomJid];
				// if user gets kicked, role is none and there's a status code 307
                if (item.attr('role') === 'none') {
                    if (msg.find('status').attr('code') === '307') {
						type = 'kick';
                    } else if (msg.find('status').attr('code') === '301') {
						type = 'ban';
					}
					reason = item.find('reason').text();
                    actor = item.find('actor').attr('jid');
				}

				var user = new Candy.Core.ChatUser(from, Strophe.getResourceFromJid(from), item.attr('affiliation'), item.attr('role'));

                self.notifyObservers(self.KEYS.PRESENCE, { 'roomJid': roomJid, 'roomName': roomName, 'type': type, 'reason': reason, 'actor': actor, 'user': user });
				return true;
			},

			/** Function: Disco
			 * Sets informations to rooms according to the disco info received.
			 *
			 * Parameters:
			 *   (String) msg - Raw XML Message
			 *
			 * Returns:
			 *   (Boolean) - true
			 */
            Disco: function (msg) {
				Candy.Core.log('[Jabber:Room] Disco');
				var msg = $(msg),
					roomJid = Strophe.getBareJidFromJid(msg.attr('from'));

				// Client joined a room
                if (!Candy.Core.getRooms()[roomJid]) {
					Candy.Core.getRooms()[roomJid] = new Candy.Core.ChatRoom(roomJid);
				}
				// Room existed but room name was unknown
				var roomName = msg.find('identity').attr('name'),
					room = Candy.Core.getRoom(roomJid);
                if (room.getName() === null) {
					room.setName(roomName);
				// Room name changed
				}/*else if(room.getName() !== roomName && room.getUser() !== null) {
					// NOTE: We want to notify the View here but jabber doesn't send anything when the room name changes :-(
				}*/
				return true;
			},

			/** Function: Presence
			 * Acts on various presence messages (room leaving, room joining, error presence) and notifies view.
			 *
			 * Parameters:
			 *   (Object) msg - jQuery object of XML message
			 *
			 * Returns:
			 *   (Boolean) - true
			 */
            Presence: function (msg) {
				Candy.Core.log('[Jabber:Room] Presence');
				var from = Candy.Util.unescapeJid(msg.attr('from')),
					roomJid = Strophe.getBareJidFromJid(from),
					presenceType = msg.attr('type');

				// Client left a room
                if (Strophe.getResourceFromJid(from) === Candy.Core.getUser().getNick() && presenceType === 'unavailable') {
					self.Jabber.Room.Leave(msg);
					return true;
				}

				// Client joined a room
				var room = Candy.Core.getRoom(roomJid);
                if (!room) {
					Candy.Core.getRooms()[roomJid] = new Candy.Core.ChatRoom(roomJid);
					room = Candy.Core.getRoom(roomJid);
				}

				var roster = room.getRoster(),
					action, user,
					item = msg.find('item');
				// User joined a room
                if (presenceType !== 'unavailable') {
					var nick = Strophe.getResourceFromJid(from);
					user = new Candy.Core.ChatUser(from, nick, item.attr('affiliation'), item.attr('role'));
					// Room existed but client (myself) is not yet registered
                    if (room.getUser() === null && Candy.Core.getUser().getNick() === nick) {
						room.setUser(user);
					}
					roster.add(user);
					action = 'join';
				// User left a room
				} else {
					action = 'leave';
                    if (item.attr('role') === 'none') {
                        if (msg.find('status').attr('code') === '307') {
							action = 'kick';
                        } else if (msg.find('status').attr('code') === '301') {
							action = 'ban';
						}
					}
					user = roster.get(from);
					roster.remove(from);
				}

                self.notifyObservers(self.KEYS.PRESENCE, { 'roomJid': roomJid, 'roomName': room.getName(), 'user': user, 'action': action, 'currentUser': Candy.Core.getUser() });
				return true;
			},
			
			/** Function: PresenceError
			 * Acts when a presence of type error has been retrieved.
			 *
			 * Parameters:
			 *   (Object) msg - jQuery object of XML message
			 *
			 * Returns:
			 *   (Boolean) - true
			 */
            PresenceError: function (msg) {
				Candy.Core.log('[Jabber:Room] Presence Error');
				var from = Candy.Util.unescapeJid(msg.attr('from')),
					roomJid = Strophe.getBareJidFromJid(from),
					room = Candy.Core.getRooms()[roomJid],
					roomName = room.getName();
					
				// Presence error: Remove room from array to prevent error when disconnecting
				delete room;
				
                self.notifyObservers(self.KEYS.PRESENCE_ERROR, { 'msg': msg, 'type': msg.children('error').children()[0].tagName.toLowerCase(), 'roomJid': roomJid, 'roomName': roomName });
			},

			/** Function: Message
			 * Acts on various message events (subject changed, private chat message, multi-user chat message)
			 * and notifies view.
			 *
			 * Parameters:
			 *   (String) msg - jQuery object of XML message
			 *
			 * Returns:
			 *   (Boolean) - true
			 */
            Message: function (msg) {
				Candy.Core.log('[Jabber:Room] Message');
				// Room subject
				var roomJid, message;
                if (msg.children('subject').length > 0) {
					roomJid = Candy.Util.unescapeJid(Strophe.getBareJidFromJid(msg.attr('from')));
					message = { name: Strophe.getNodeFromJid(roomJid), body: msg.children('subject').text(), type: 'subject' };
				// Error messsage
                } else if (msg.attr('type') === 'error') {
					var error = msg.children('error');
                    if (error.attr('code') === '500' && error.children('text').length > 0) {
						roomJid = msg.attr('from');
						message = { type: 'info', body: error.children('text').text() };
					}
				// Chat message
                } else if (msg.children('body').length > 0) {
					// Private chat message
                    if (msg.attr('type') === 'chat') {
						roomJid = Candy.Util.unescapeJid(msg.attr('from'));
						var bareRoomJid = Strophe.getBareJidFromJid(roomJid),
							// if a 3rd-party client sends a direct message to this user (not via the room) then the username is the node and not the resource.
							isNoConferenceRoomJid = !Candy.Core.getRoom(bareRoomJid),
							name = isNoConferenceRoomJid ? Strophe.getNodeFromJid(roomJid) : Strophe.getResourceFromJid(roomJid);
						message = { name: name, body: msg.children('body').text(), type: msg.attr('type'), isNoConferenceRoomJid: isNoConferenceRoomJid };
					// Multi-user chat message
					} else {
						roomJid = Candy.Util.unescapeJid(Strophe.getBareJidFromJid(msg.attr('from')));
						var resource = Strophe.getResourceFromJid(msg.attr('from'));
						// Message from a user
                        if (resource) {
							resource = Strophe.unescapeNode(resource);
							message = { name: resource, body: msg.children('body').text(), type: msg.attr('type') };
						// Message from server (XEP-0045#registrar-statuscodes)
						} else {
							message = { name: '', body: msg.children('body').text(), type: 'info' };
						}
					}
				// Unhandled message
				} else {
					return true;
				}

				// besides the delayed delivery (XEP-0203), there exists also XEP-0091 which is the legacy delayed delivery.
				// the x[xmlns=jabber:x:delay] is the format in XEP-0091.
                var delay = msg.children('delay') ? msg.children('delay') : msg.children('x[xmlns="' + Strophe.NS.DELAY + '"]'),
					timestamp = delay !== undefined ? delay.attr('stamp') : null;

                self.notifyObservers(self.KEYS.MESSAGE, { roomJid: roomJid, message: message, timestamp: timestamp });
				return true;
			}
		}
	};

	return self;
}(Candy.Core.Event || {}, Strophe, jQuery, Candy.Util.Observable));
/** File: event.js
 * Candy - Chats are not dead yet.
 *
 * Authors:
 *   - Patrick Stadler <patrick.stadler@gmail.com>
 *   - Michael Weibel <michael.weibel@gmail.com>
 *
 * Copyright:
 *   (c) 2011 Amiado Group AG. All rights reserved.
 */

/** Class: Candy.View.Event
 * Empty hooks to capture events and inject custom code.
 *
 * Parameters:
 *   (Candy.View.Event) self - itself
 *   (jQuery) $ - jQuery
 */
Candy.View.Event = (function (self, $) {
	/** Class: Candy.View.Event.Chat
	 * Chat-related events
	 */
	self.Chat = {
		/** Function: onAdminMessage
		 * Called when receiving admin messages
		 *
		 * Parameters:
		 *   (Object) args - {subject, message}
		 */
        onAdminMessage: function (args) {
			return;
		},
		
		/** Function: onDisconnect
		 * Called when client disconnects
		 */
        onDisconnect: function () {
			return;
		},
		
		/** Function: onAuthfail
		 * Called when authentication fails
		 */
        onAuthfail: function () {
			return;
		}
	};

	/** Class: Candy.View.Event.Room
	 * Room-related events
	 */
	self.Room = {
		/** Function: onAdd
		 * Called when a new room gets added
		 *
		 * Parameters:
		 *   (Object) args - {roomJid, type=chat|groupchat, element}
		 */
        onAdd: function (args) {
			return;
		},

		/** Function: onShow
		 * Called when a room gets shown
		 *
		 * Parameters:
		 *   (Object) args - {roomJid, element}
		 */
        onShow: function (args) {
			return;
		},

		/** Function: onHide
		 * Called when a room gets hidden
		 *
		 * Parameters:
		 *   (Object) args - {roomJid, element}
		 */
        onHide: function (args) {
			return;
		},

		/** Function: onSubjectChange
		 * Called when a subject of a room gets changed
		 *
		 * Parameters:
		 *   (Object) args - {roomJid, element, subject}
		 */
        onSubjectChange: function (args) {
			return;
		},

		/** Function: onClose
		 * Called after a room has been left/closed
		 *
		 * Parameters:
		 *   (Object) args - {roomJid}
		 */
        onClose: function (args) {
			return;
		},
		
		/** Function: onPresenceChange
		 * Called when presence of user changes (kick, ban)
		 *
		 * Parameters:
		 *   (Object) args - {roomJid, user, reason, type}
		 */
        onPresenceChange: function (args) {
			return;
		}
	};

	/** Class: Candy.View.Event.Roster
	 * Roster-related events
	 */
	self.Roster = {
		/** Function: onUpdate
		 * Called after a user have been added to the roster
		 *
		 * Parameters:
		 *   (Object) args - {roomJid, user, action, element}
		 */
        onUpdate: function (args) {
			return;
		},

		/** Function: onContextMenu
		 * Called when a user clicks on the action menu arrow.
		 * The return value is getting appended to the menulinks.
		 *
		 * Parameters:
		 *   (Object) args - {roomJid, user}
		 *
		 * Returns:
		 *   (Object) - containing menulinks
		 */
        onContextMenu: function (args) {
			return {};
		},
		
		/** Function: afterContextMenu
		 * Called when after a the context menu is rendered
		 *
		 * Parameters:
		 *   (Object) args - {roomJid, element, user}
		 */
        afterContextMenu: function (args) {
			return;
		}
	};

	/** Class: Candy.View.Event.Message
	 * Message-related events
	 */
	self.Message = {
		/** Function: beforeShow
		 * Called before a new message will be shown.
		 *
		 * Parameters:
		 *   (Object) args - {roomJid, nick, message}
		 *
		 * Returns:
		 *   (String) message
		 */
        beforeShow: function (args) {
			return args.message;
		},
		
		/** Function: onShow
		 * Called after a new message has been shown
		 *
		 * Parameters:
		 *   (Object) args - {roomJid, element, nick, message}
		 */
        onShow: function (args) {
			return;
		},
		
		/** Function: beforeSend
		 * Called before a message get sent
		 *
		 * Parameters:
		 *   (String) message
		 *
		 * Returns:
		 *   (String) message
		 */
        beforeSend: function (message) {
			return message;
		}
	};

	return self;
}(Candy.View.Event || {}, jQuery));/** File: observer.js
 * Candy - Chats are not dead yet.
 *
 * Authors:
 *   - Patrick Stadler <patrick.stadler@gmail.com>
 *   - Michael Weibel <michael.weibel@gmail.com>
 *
 * Copyright:
 *   (c) 2011 Amiado Group AG. All rights reserved.
 */

/** Class: Candy.View.Observer
 * Observes Candy core events
 *
 * Parameters:
 *   (Candy.View.Observer) self - itself
 *   (jQuery) $ - jQuery
 */
Candy.View.Observer = (function (self, $) {
	/** Class: Candy.View.Observer.Chat
	 * Chat events
	 */
	self.Chat = {
		/** Function: update
		 * The update method gets called whenever an event to which "Chat" is subscribed.
		 *
		 * Currently listens for connection status updates & admin messages / motd
		 *
		 * Parameters:
		 *   (Candy.Core.Event) obj - Candy core event object
		 *   (Object) args - {type, connection or message & subject}
		 */
        update: function (obj, args) {
            if (args.type === 'connection') {
                switch (args.status) {
					case Strophe.Status.CONNECTING:
					case Strophe.Status.AUTHENTICATING:
						Candy.View.Pane.Chat.Modal.show($.i18n._('statusConnecting'), false, true);
						break;

					case Strophe.Status.ATTACHED:
					case Strophe.Status.CONNECTED:
						Candy.View.Pane.Chat.Modal.show($.i18n._('statusConnected'));
						Candy.View.Pane.Chat.Modal.hide();
						break;

					case Strophe.Status.DISCONNECTING:
						Candy.View.Pane.Chat.Modal.show($.i18n._('statusDisconnecting'), false, true);
						break;

					case Strophe.Status.DISCONNECTED:
						var presetJid = Candy.Core.isAnonymousConnection() ? Strophe.getDomainFromJid(Candy.Core.getUser().getJid()) : null;
						Candy.View.Pane.Chat.Modal.showLoginForm($.i18n._('statusDisconnected'), presetJid);
						Candy.View.Event.Chat.onDisconnect();
						break;

					case Strophe.Status.AUTHFAIL:
						Candy.View.Pane.Chat.Modal.showLoginForm($.i18n._('statusAuthfail'));
						Candy.View.Event.Chat.onAuthfail();
						break;

					default:
						Candy.View.Pane.Chat.Modal.show($.i18n._('status', args.status));
						break;
				}
            } else if (args.type === 'message') {
				Candy.View.Pane.Chat.adminMessage((args.subject || ''), args.message);
            } else if (args.type === 'chat' || args.type === 'groupchat') {
				// use onInfoMessage as infos from the server shouldn't be hidden by the infoMessage switch.
				Candy.View.Pane.Chat.onInfoMessage(Candy.View.getCurrent().roomJid, (args.subject || ''), args.message);
			}
		}
	};

	/** Class: Candy.View.Observer.Presence
	 * Presence update events
	 */
	self.Presence = {
		/** Function: update
		 * Every presence update gets dispatched from this method.
		 *
		 * Parameters:
		 *   (Candy.Core.Event) obj - Candy core event object
		 *   (Object) args - Arguments differ on each type
		 *
		 * Uses:
		 *   - <notifyPrivateChats>
		 */
        update: function (obj, args) {
			// Client left
            if (args.type === 'leave') {
				var user = Candy.View.Pane.Room.getUser(args.roomJid);
				Candy.View.Pane.Room.close(args.roomJid);
				self.Presence.notifyPrivateChats(user, args.type);
			// Client has been kicked or banned
			} else if (args.type === 'kick' || args.type === 'ban') {
				var actorName = args.actor ? Strophe.getNodeFromJid(args.actor) : null,
					actionLabel,
					translationParams = [args.roomName];

				if (actorName) {
					translationParams.push(actorName);
				}

                switch (args.type) {
					case 'kick':
						actionLabel = $.i18n._((actorName ? 'youHaveBeenKickedBy' : 'youHaveBeenKicked'), translationParams);
						break;
					case 'ban':
						actionLabel = $.i18n._((actorName ? 'youHaveBeenBannedBy' : 'youHaveBeenBanned'), translationParams);
						break;
				}
				Candy.View.Pane.Chat.Modal.show(Mustache.to_html(Candy.View.Template.Chat.Context.adminMessageReason, {
					reason: args.reason,
					_action: actionLabel,
					_reason: $.i18n._('reasonWas', [args.reason])
				}));
                setTimeout(function () {
                    Candy.View.Pane.Chat.Modal.hide(function () {
						Candy.View.Pane.Room.close(args.roomJid);
						self.Presence.notifyPrivateChats(args.user, args.type);
					});
				}, 5000);
				Candy.View.Event.Room.onPresenceChange({ type: args.type, reason: args.reason, roomJid: args.roomJid, user: args.user });
			// A user changed presence
			} else {
				// Initialize room if not yet existing
                if (!Candy.View.Pane.Chat.rooms[args.roomJid]) {
					Candy.View.Pane.Room.init(args.roomJid, args.roomName);
					Candy.View.Pane.Room.show(args.roomJid);
				}
				Candy.View.Pane.Roster.update(args.roomJid, args.user, args.action, args.currentUser);
				// Notify private user chats if existing
                if (Candy.View.Pane.Chat.rooms[args.user.getJid()]) {
					Candy.View.Pane.Roster.update(args.user.getJid(), args.user, args.action, args.currentUser);
					Candy.View.Pane.PrivateRoom.setStatus(args.user.getJid(), args.action);
				}
			}
		},

		/** Function: notifyPrivateChats
		 * Notify private user chats if existing
		 *
		 * Parameters:
		 *   (Candy.Core.chatUser) user - User which has done the event
		 *   (String) type - Event type (leave, join, kick/ban)
		 */
        notifyPrivateChats: function (user, type) {
			Candy.Core.log('[View:Observer] notify Private Chats');
			var roomJid;
            for (roomJid in Candy.View.Pane.Chat.rooms) {
                if (Candy.View.Pane.Chat.rooms.hasOwnProperty(roomJid) && Candy.View.Pane.Room.getUser(roomJid) && user.getJid() === Candy.View.Pane.Room.getUser(roomJid).getJid()) {
					Candy.View.Pane.Roster.update(roomJid, user, type, user);
					Candy.View.Pane.PrivateRoom.setStatus(roomJid, type);
				}
			}
		}
	};
	
	/** Class: Candy.View.Observer.PresenceError
	 * Presence error events
	 */
	self.PresenceError = {
		/** Function: update
		 * Presence errors get handled in this method
		 *
		 * Parameters:
		 *   (Candy.Core.Event) obj - Candy core event object
		 *   (Object) args - {msg, type, roomJid, roomName}
		 */
        update: function (obj, args) {
            switch (args.type) {
				case 'not-authorized':
					var message;
					if (args.msg.children('x').children('password').length > 0) {
						message = $.i18n._('passwordEnteredInvalid', [args.roomName]);
					}
					Candy.View.Pane.Chat.Modal.showEnterPasswordForm(args.roomJid, args.roomName, message);
					break;
				case 'conflict':
					Candy.View.Pane.Chat.Modal.showNicknameConflictForm(args.roomJid);
					break;
				case 'registration-required':
					Candy.View.Pane.Chat.Modal.showError('errorMembersOnly', [args.roomName]);
					break;
				case 'service-unavailable':
					Candy.View.Pane.Chat.Modal.showError('errorMaxOccupantsReached', [args.roomName]);
					break;
			}
		}
	}

	/** Class: Candy.View.Observer.Message
	 * Message related events
	 */
	self.Message = {
		/** Function: update
		 * Messages received get dispatched from this method.
		 *
		 * Parameters:
		 *   (Candy.Core.Event) obj - Candy core event object
		 *   (Object) args - {message, roomJid}
		 */
        update: function (obj, args) {
            if (args.message.type === 'subject') {
				if (!Candy.View.Pane.Chat.rooms[args.roomJid]) {
					Candy.View.Pane.Room.init(args.roomJid, args.message.name);
					Candy.View.Pane.Room.show(args.roomJid);
				}
				Candy.View.Pane.Room.setSubject(args.roomJid, args.message.body);
            } else if (args.message.type === 'info') {
				Candy.View.Pane.Chat.infoMessage(args.roomJid, args.message.body);
			} else {
				// Initialize room if it's a message for a new private user chat
                if (args.message.type === 'chat' && !Candy.View.Pane.Chat.rooms[args.roomJid]) {
					Candy.View.Pane.PrivateRoom.open(args.roomJid, args.message.name, false, args.message.isNoConferenceRoomJid);
				}
				Candy.View.Pane.Message.show(args.roomJid, args.message.name, args.message.body, args.timestamp);
			}
		}
	};

	/** Class: Candy.View.Observer.Login
	 * Handles when display login window should appear
	 */
	self.Login = {
		/** Function: update
		 * The login event gets dispatched to this method
		 *
		 * Parameters:
		 *   (Candy.Core.Event) obj - Candy core event object
		 *   (Object) args - {presetJid}
		 */
        update: function (obj, args) {
			Candy.View.Pane.Chat.Modal.showLoginForm(null, args.presetJid);
		}
	};

	return self;
}(Candy.View.Observer || {}, jQuery));/** File: pane.js
 * Candy - Chats are not dead yet.
 *
 * Authors:
 *   - Patrick Stadler <patrick.stadler@gmail.com>
 *   - Michael Weibel <michael.weibel@gmail.com>
 *
 * Copyright:
 *   (c) 2011 Amiado Group AG. All rights reserved.
 */

/** Class: Candy.View.Pane
 * Candy view pane handles everything regarding DOM updates etc.
 *
 * Parameters:
 *   (Candy.View.Pane) self - itself
 *   (jQuery) $ - jQuery
 */
Candy.View.Pane = (function (self, $) {

	/** Class: Candy.View.Pane.Window
	 * Window related view updates
	 */
	self.Window = {
		/** PrivateVariable: _hasFocus
		 * Window has focus
		 */
		_hasFocus: true,
		/** PrivateVariable: _plainTitle
		 * Document title
		 */
		_plainTitle: document.title,
		/** PrivateVariable: _unreadMessagesCount
		 * Unread messages count
		 */
		_unreadMessagesCount: 0,

		/** Variable: autoscroll
		 * Boolean whether autoscroll is enabled
		 */
		autoscroll: true,

		/** Function: hasFocus
		 * Checks if window has focus
		 *
		 * Returns:
		 *   (Boolean)
		 */
        hasFocus: function () {
			return self.Window._hasFocus;
		},

		/** Function: increaseUnreadMessages
		 * Increases unread message count in window title by one.
		 */
        increaseUnreadMessages: function () {
			self.Window.renderUnreadMessages(++self.Window._unreadMessagesCount);
		},

		/** Function: reduceUnreadMessages
		 * Reduce unread message count in window title by `num`.
		 *
		 * Parameters:
		 *   (Integer) num - Unread message count will be reduced by this value
		 */
        reduceUnreadMessages: function (num) {
			self.Window._unreadMessagesCount -= num;
            if (self.Window._unreadMessagesCount <= 0) {
				self.Window.clearUnreadMessages();
			} else {
				self.Window.renderUnreadMessages(self.Window._unreadMessagesCount);
			}
		},

		/** Function: clearUnreadMessages
		 * Clear unread message count in window title.
		 */
        clearUnreadMessages: function () {
			self.Window._unreadMessagesCount = 0;
			document.title = self.Window._plainTitle;
		},

		/** Function: renderUnreadMessages
		 * Update window title to show message count.
		 *
		 * Parameters:
		 *   (Integer) count - Number of unread messages to show in window title
		 */
        renderUnreadMessages: function (count) {
            // document.title = Candy.View.Template.Window.unreadmessages.replace('{{count}}', count).replace('{{title}}', self.Window._plainTitle);
		},

		/** Function: onFocus
		 * Window focus event handler.
		 */
        onFocus: function () {
			self.Window._hasFocus = true;
			if (Candy.View.getCurrent().roomJid) {
				self.Room.setFocusToForm(Candy.View.getCurrent().roomJid);
				self.Chat.clearUnreadMessages(Candy.View.getCurrent().roomJid);
			}
		},

		/** Function: onBlur
		 * Window blur event handler.
		 */
        onBlur: function () {
			self.Window._hasFocus = false;
		}
	};

	/** Class: Candy.View.Pane.Chat
	 * Chat-View related view updates
	 */
	self.Chat = {
		/** Variable: rooms
		 * Contains opened room elements
		 */
		rooms: [],

		/** Function: addTab
		 * Add a tab to the chat pane.
		 *
		 * Parameters:
		 *   (String) roomJid - JID of room
		 *   (String) roomName - Tab label
		 *   (String) roomType - Type of room: `groupchat` or `chat`
		 */
        addTab: function (roomJid, roomName, roomType) {
            var _roomName = roomName || Strophe.getNodeFromJid(roomJid);

            if (_roomName === "Take65") {
                _roomName = "Contact List";
                userCount = true;
            }

			var roomId = Candy.Util.jidToId(roomJid),
				html = Mustache.to_html(Candy.View.Template.Chat.tab, {
					roomJid: roomJid,
					roomId: roomId,
					name: _roomName,
				    privateUserChat: function () { return roomType === 'chat'; },
				    roomType: roomType,
				    countClass: userCount ? 'chat-usercount' : 'chat-unread'
				}),
				tab = $(html).appendTo('#chat-tabs');

			tab.click(self.Chat.tabClick);
			// TODO: maybe we find a better way to get the close element.
			$('a.close', tab).click(self.Chat.tabClose);

			self.Chat.fitTabs();


		},

		/** Function: getTab
		 * Get tab by JID.
		 *
		 * Parameters:
		 *   (String) roomJid - JID of room
		 *
		 * Returns:
		 *   (jQuery object) - Tab element
		 */
        getTab: function (roomJid) {
			return $('#chat-tabs').children('li[data-roomjid="' + roomJid + '"]');
        },

	    /** Function: getRoster
		 * Get tab by JID.
		 *
		 * Parameters:
		 *   (String) roomJid - JID of room
		 *
		 * Returns:
		 *   (jQuery object) - Roster element
		 */
        getRoster: function (roomJid) {
            return $('#chat-rooms .roomtype-groupchat .roster-pane .user').filter(function () {
                return $(this).data('jid') == roomJid;
            });
        },


		/** Function: removeTab
		 * Remove tab element.
		 *
		 * Parameters:
		 *   (String) roomJid - JID of room
		 */
        removeTab: function (roomJid) {
			self.Chat.getTab(roomJid).remove();
			self.Chat.fitTabs();
		},

		/** Function: setActiveTab
		 * Set the active tab.
		 *
		 * Add CSS classname `active` to the choosen tab and remove `active` from all other.
		 *
		 * Parameters:
		 *   (String) roomJid - JID of room
		 */
        setActiveTab: function (roomJid) {
            $('#chat-tabs').children().each(function () {
				var tab = $(this);
                if (tab.attr('data-roomjid') === roomJid) {
					tab.addClass('active');
				} else {
					tab.removeClass('active');
				}
			});
		},

		/** Function: increaseUnreadMessages
		 * Increase unread message count in a tab by one.
		 *
		 * Parameters:
		 *   (String) roomJid - JID of room
		 *
		 * Uses:
		 *   - <Window.increaseUnreadMessages>
		 */
        increaseUnreadMessages: function (roomJid) {
            var unreadElem = this.getRoster(roomJid).find('.chat-unread');

            unreadElem.show();
            if (unreadElem.text() === '')
                unreadElem.text(1);
            else
                unreadElem.text(parseInt(unreadElem.text(), 10) + 1);
			// only increase window unread messages in private chats
			if (self.Chat.rooms[roomJid].type === 'chat') {
				self.Window.increaseUnreadMessages();
			}
		},

		/** Function: clearUnreadMessages
		 * Clear unread message count in a tab.
		 *
		 * Parameters:
		 *   (String) roomJid - JID of room
		 *
		 * Uses:
		 *   - <Window.reduceUnreadMessages>
		 */
        clearUnreadMessages: function (roomJid) {
            var unreadElem = this.getRoster(roomJid).find('.chat-unread');
			self.Window.reduceUnreadMessages(unreadElem.text());
			unreadElem.text('').hide();
		},

		/** Function: tabClick
		 * Tab click event: show the room associated with the tab and stops the event from doing the default.
		 */
        tabClick: function (e) {
			// remember scroll position of current room
			// var currentRoomJid = Candy.View.getCurrent().roomJid;
			// self.Chat.rooms[currentRoomJid].scrollPosition = self.Room.getPane(currentRoomJid, '.message-pane-wrapper').scrollTop();

			// self.Room.show($(this).attr('data-roomjid'));
			e.preventDefault();
		},

		/** Function: tabClose
		 * Tab close (click) event: Leave the room (groupchat) or simply close the tab (chat).
		 *
		 * Parameters:
		 *   (DOMEvent) e - Event triggered
		 *
		 * Returns:
		 *   (Boolean) - false, this will stop the event from bubbling
		 */
        tabClose: function (e) {
			var roomJid = $(this).parent().attr('data-roomjid');
			// close private user tab
            if (self.Chat.rooms[roomJid].type === 'chat') {
				self.Room.close(roomJid);
			// close multi-user room tab
			} else {
				Candy.Core.Action.Jabber.Room.Leave(roomJid);
			}
			return false;
		},

		/** Function: allTabsClosed
		 * All tabs closed event: Disconnect from service. Hide sound control.
		 *
		 * TODO: Handle window close
		 *
		 * Returns:
		 *   (Boolean) - false, this will stop the event from bubbling
		 */
        allTabsClosed: function () {
			Candy.Core.disconnect();
			self.Chat.Toolbar.hide();
			return;
			// this is a workaround because browsers prevent to close non-js-opened windows
			/*if($.browser.msie) {
				this.focus();
				self.opener = this;
				self.close();
			} else {
				window.open(location.href, '_self');
				window.close();
			}*/
		},

		/** Function: fitTabs
		 * Fit tab size according to window size
		 */
        fitTabs: function () {
			var availableWidth = $('#chat-tabs').innerWidth(),
				tabsWidth = 0,
				tabs = $('#chat-tabs').children();
            tabs.each(function () {
				tabsWidth += $(this).css({ width: 'auto', overflow: 'visible' }).outerWidth(true);
			});
            if (tabsWidth > availableWidth) {
				// tabs.[outer]Width() measures the first element in `tabs`. It's no very readable but nearly two times faster than using :first
				var tabDiffToRealWidth = tabs.outerWidth(true) - tabs.width(),
					tabWidth = Math.floor((availableWidth) / tabs.length) - tabDiffToRealWidth;
				tabs.css({ width: tabWidth, overflow: 'hidden' });
			}
		},

		/** Function: updateToolbar
		 * Show toolbar
		 */
        updateToolbar: function (roomJid) {
            $('#chat-toolbar').find('.context').click(function (e) {
				self.Chat.Context.show(e.currentTarget, roomJid);
				e.stopPropagation();
			});
            // Candy.View.Pane.Chat.Toolbar.updateUsercount(Candy.View.Pane.Chat.rooms[roomJid].usercount);
            Candy.View.Pane.Chat.Toolbar.updateUsercount(Candy.View.Pane.Chat.rooms[_chatRoom].usercount);
		},

		/** Function: adminMessage
		 * Display admin message
		 *
		 * Parameters:
		 *   (String) subject - Admin message subject
		 *   (String) message - Message to be displayed
		 */
        adminMessage: function (subject, message) {
            if (Candy.View.getCurrent().roomJid) { // Simply dismiss admin message if no room joined so far. TODO: maybe we should show those messages on a dedicated pane?
                var html = Mustache.to_html(Candy.View.Template.Chat.adminMessage, {
                    subject: subject,
                    message: message,
                    sender: $.i18n._('administratorMessageSubject'),
                    time: Candy.Util.formatAMPM(new Date())
                });
                $('#chat-rooms').children().each(function () {
					self.Room.appendToMessagePane($(this).attr('data-roomjid'), html);
				});
				self.Room.scrollToBottom(Candy.View.getCurrent().roomJid);

                Candy.View.Event.Chat.onAdminMessage({ 'subject': subject, 'message': message });
			}
		},

		/** Function: infoMessage
		 * Display info message. This is a wrapper for <onInfoMessage> to be able to disable certain info messages.
		 *
		 * Parameters:
		 *   (String) roomJid - Room JID
		 *   (String) subject - Subject
		 *   (String) message - Message
		 */
        infoMessage: function (roomJid, subject, message) {
			self.Chat.onInfoMessage(roomJid, subject, message);
		},

		/** Function: onInfoMessage
		 * Display info message. Used by <infoMessage> and several other functions which do not wish that their info message
		 * can be disabled (such as kick/ban message or leave/join message in private chats).
		 *
		 * Parameters:
		 *   (String) roomJid - Room JID
		 *   (String) subject - Subject
		 *   (String) message - Message
		 */
        onInfoMessage: function (roomJid, subject, message) {
            if (Candy.View.getCurrent().roomJid) { // Simply dismiss info message if no room joined so far. TODO: maybe we should show those messages on a dedicated pane?
				var html = Mustache.to_html(Candy.View.Template.Chat.infoMessage, {
					subject: subject,
					message: $.i18n._(message),
					time: Candy.Util.formatAMPM(new Date())
				});
				self.Room.appendToMessagePane(roomJid, html);
				if (Candy.View.getCurrent().roomJid === roomJid) {
					self.Room.scrollToBottom(Candy.View.getCurrent().roomJid);
				}
			}
		},

		/** Class: Candy.View.Pane.Toolbar
		 * Chat toolbar for things like emoticons toolbar, room management etc.
		 */
		Toolbar: {
			/** Function: show
			 * Show toolbar.
			 */
            show: function () {
				// $('#chat-toolbar').show();
			},

			/** Function: hide
			 * Hide toolbar.
			 */
            hide: function () {
				// $('#chat-toolbar').hide();
			},

			/** Function: playSound
			 * Play sound (default method).
			 */
            playSound: function () {
				self.Chat.Toolbar.onPlaySound();
			},

			/** Function: onPlaySound
			 * Sound play event handler.
			 *
			 * Don't call this method directly. Call `playSound()` instead.
			 * `playSound()` will only call this method if sound is enabled.
			 */
            onPlaySound: function () {
				//var chatSoundPlayer = document.getElementById('chat-sound-player');
				//chatSoundPlayer.SetVariable('method:stop', '');
				//chatSoundPlayer.SetVariable('method:play', '');
			},

			/** Function: onSoundControlClick
			 * Sound control click event handler.
			 *
			 * Toggle sound (overwrite `playSound()`) and handle cookies.
			 */
            onSoundControlClick: function () {
				var control = $('#chat-sound-control');
                if (control.hasClass('checked')) {
                    self.Chat.Toolbar.playSound = function () { };
					Candy.Util.setCookie('candy-nosound', '1', 365);
				} else {
                    self.Chat.Toolbar.playSound = function () {
						self.Chat.Toolbar.onPlaySound();
					};
					Candy.Util.deleteCookie('candy-nosound');
				}
				control.toggleClass('checked');
			},

			/** Function: onAutoscrollControlClick
			 * Autoscroll control event handler.
			 *
			 * Toggle autoscroll
			 */
            onAutoscrollControlClick: function () {
				var control = $('#chat-autoscroll-control');
                if (control.hasClass('checked')) {
                    self.Room.scrollToBottom = function (roomJid) {
						self.Room.onScrollToStoredPosition(roomJid);
					};
					self.Window.autoscroll = false;
				} else {
                    self.Room.scrollToBottom = function (roomJid) {
						self.Room.onScrollToBottom(roomJid);
					};
					self.Room.scrollToBottom(Candy.View.getCurrent().roomJid);
					self.Window.autoscroll = true;
				}
				control.toggleClass('checked');
			},

			/** Function: onStatusMessageControlClick
			 * Status message control event handler.
			 *
			 * Toggle status message
			 */
            onStatusMessageControlClick: function () {
				var control = $('#chat-statusmessage-control');
                if (control.hasClass('checked')) {
                    self.Chat.infoMessage = function () { };
					Candy.Util.setCookie('candy-nostatusmessages', '1', 365);
				} else {
                    self.Chat.infoMessage = function (roomJid, subject, message) {
						self.Chat.onInfoMessage(roomJid, subject, message);
					};
					Candy.Util.deleteCookie('candy-nostatusmessages');
				}
				control.toggleClass('checked');
			},

			/** Function: updateUserCount
			 * Update usercount element with count.
			 *
			 * Parameters:
			 *   (Integer) count - Current usercount
			 */
            updateUsercount: function (count) {
				$('.chat-usercount').text(count - 1);
			}
		},

		/** Class: Candy.View.Pane.Modal
		 * Modal window
		 */
		Modal: {
			/** Function: show
			 * Display modal window
			 *
			 * Parameters:
			 *   (String) html - HTML code to put into the modal window
			 *   (Boolean) showCloseControl - set to true if a close button should be displayed [default false]
			 *   (Boolean) showSpinner - set to true if a loading spinner should be shown [default false]
			 */
            show: function (html, showCloseControl, showSpinner) {
                if (showCloseControl) {
					self.Chat.Modal.showCloseControl();
				} else {
					self.Chat.Modal.hideCloseControl();
				}
                if (showSpinner) {
					self.Chat.Modal.showSpinner();
				} else {
					self.Chat.Modal.hideSpinner();
				}
				$('#chat-modal').stop(false, true);
				$('#chat-modal-body').html(html);
				$('#chat-modal').fadeIn('fast');
				$('#chat-modal-overlay').show();
			},

			/** Function: hide
			 * Hide modal window
			 *
			 * Parameters:
			 *   (Function) callback - Calls the specified function after modal window has been hidden.
			 */
            hide: function (callback) {
                $('#chat-modal').fadeOut('fast', function () {
					$('#chat-modal-body').text('');	
					$('#chat-modal-overlay').hide();
				});
				// restore initial esc handling
                $(document).keydown(function (e) {
                    if (e.which === 27) {
						e.preventDefault();
					}
				});
				if (callback) {
					callback();
				}
			},

			/** Function: showSpinner
			 * Show loading spinner
			 */
            showSpinner: function () {
				$('#chat-modal-spinner').show();
			},

			/** Function: hideSpinner
			 * Hide loading spinner
			 */
            hideSpinner: function () {
				$('#chat-modal-spinner').hide();
			},

			/** Function: showCloseControl
			 * Show a close button
			 */
            showCloseControl: function () {
                $('#admin-message-cancel').show().click(function (e) {
					self.Chat.Modal.hide();
					// some strange behaviour on IE7 (and maybe other browsers) triggers onWindowUnload when clicking on the close button.
					// prevent this.
					e.preventDefault();
				});

				// enable esc to close modal
                $(document).keydown(function (e) {
                    if (e.which === 27) {
						self.Chat.Modal.hide();
						e.preventDefault();
					}
				});
			},

			/** Function: hideCloseControl
			 * Hide the close button
			 */
            hideCloseControl: function () {
                $('#admin-message-cancel').hide().click(function () { });
			},

			/** Function: showLoginForm
			 * Show the login form modal
			 *
			 * Parameters:
			 *  (String) message - optional message to display above the form
			 *	(String) presetJid - optional user jid. if set, the user will only be prompted for password.
			 */
            showLoginForm: function (message, presetJid) {
				self.Chat.Modal.show((message ? message : '') + Mustache.to_html(Candy.View.Template.Login.form, {
					_labelUsername: $.i18n._('labelUsername'),
					_labelPassword: $.i18n._('labelPassword'),
					_loginSubmit: $.i18n._('loginSubmit'),
					displayPassword: !Candy.Core.isAnonymousConnection(),
                    displayUsername: Candy.Core.isAnonymousConnection() || !presetJid,
					presetJid: presetJid ? presetJid : false
				}));
				$('#login-form').children()[0].focus();

				// register submit handler
                $('#login-form').submit(function (event) {
					var username = $('#username').val(),
						password = $('#password').val();

					if (!Candy.Core.isAnonymousConnection()) {
						// guess the input and create a jid out of it
						var jid = Candy.Core.getUser() && username.indexOf("@") < 0 ?
							username + '@' + Strophe.getDomainFromJid(Candy.Core.getUser().getJid()) : username;

                        if (jid.indexOf("@") < 0 && !Candy.Core.getUser()) {
							Candy.View.Pane.Chat.Modal.showLoginForm($.i18n._('loginInvalid'));
						} else {
							//Candy.View.Pane.Chat.Modal.hide();
							Candy.Core.connect(jid, password);
						}
					} else { // anonymous login
						Candy.Core.connect(presetJid, null, username);
					}
					return false;
				});
			},
			
			/** Function: showEnterPasswordForm
			 * Shows a form for entering room password
			 *
			 * Parameters:
			 *   (String) roomJid - Room jid to join
			 *   (String) roomName - Room name
			 *   (String) message - [optional] Message to show as the label
			 */
            showEnterPasswordForm: function (roomJid, roomName, message) {
				self.Chat.Modal.show(Mustache.to_html(Candy.View.Template.PresenceError.enterPasswordForm, {
					roomName: roomName,
					_labelPassword: $.i18n._('labelPassword'),
					_label: (message ? message : $.i18n._('enterRoomPassword', [roomName])),
					_joinSubmit: $.i18n._('enterRoomPasswordSubmit')
				}), true);
				$('#password').focus();
				
				// register submit handler
                $('#enter-password-form').submit(function () {
					var password = $('#password').val();
					
                    self.Chat.Modal.hide(function () {
						Candy.Core.Action.Jabber.Room.Join(roomJid, password);
					});
					return false;
				});
			},
			
			/** Function: showNicknameConflictForm
			 * Shows a form indicating that the nickname is already taken and
			 * for chosing a new nickname
			 *
			 * Parameters:
			 *   (String) roomJid - Room jid to join
			 */
            showNicknameConflictForm: function (roomJid) {
				self.Chat.Modal.show(Mustache.to_html(Candy.View.Template.PresenceError.nicknameConflictForm, {
					_labelNickname: $.i18n._('labelUsername'),
					_label: $.i18n._('nicknameConflict'),
					_loginSubmit: $.i18n._('loginSubmit')
				}));
				$('#nickname').focus();
				
				// register submit handler
                $('#nickname-conflict-form').submit(function () {
					var nickname = $('#nickname').val();

                    self.Chat.Modal.hide(function () {
						Candy.Core.getUser().data.nick = nickname;
						Candy.Core.Action.Jabber.Room.Join(roomJid);
					});
					return false;
				});
			},
			
			/** Function: showError
			 * Show modal containing error message
			 *
			 * Parameters:
			 *   (String) message - key of translation to display
			 *   (Array) replacements - array containing replacements for translation (%s)
			 */
            showError: function (message, replacements) {
				self.Chat.Modal.show(Mustache.to_html(Candy.View.Template.PresenceError.displayError, {
					_error: $.i18n._(message, replacements)
				}), true);
			}
		},

		/** Class: Candy.View.Pane.Tooltip
		 * Class to display tooltips over specific elements
		 */
		Tooltip: {
			/** Function: show
			 * Show a tooltip on event.currentTarget with content specified or content within the target's attribute data-tooltip.
			 *
			 * On mouseleave on the target, hide the tooltip.
			 *
			 * Parameters:
			 *   (Event) event - Triggered event
			 *   (String) content - Content to display [optional]
			 */
            show: function (event, content) {
				var tooltip = $('#tooltip'),
					target = $(event.currentTarget);

                if (!content) {
					content = target.attr('data-tooltip');
				}

                if (tooltip.length === 0) {
					var html = Mustache.to_html(Candy.View.Template.Chat.tooltip);
					$('#chat-pane').append(html);
					tooltip = $('#tooltip');
				}

				$('#context-menu').hide();

				tooltip.stop(false, true);
				tooltip.children('div').html(content);

				var candyPos = $('#candy').offset(),
                    pos = target.offset(),
					posLeft = Candy.Util.getPosLeftAccordingToWindowBounds(tooltip, pos.left - candyPos.left),
					posTop = Candy.Util.getPosTopAccordingToWindowBounds(tooltip, pos.top - candyPos.top);

                tooltip.css({ 'left': posLeft.px, 'top': posTop.px, backgroundPosition: posLeft.backgroundPositionAlignment + ' ' + posTop.backgroundPositionAlignment }).fadeIn('fast');

                target.mouseleave(function (event) {
					event.stopPropagation();
                    $('#tooltip').stop(false, true).fadeOut('fast', function () { $(this).css({ 'top': 0, 'left': 0 }); });
				});
			}
		},

		/** Class: Candy.View.Pane.Context
		 * Context menu for actions and settings
		 */
		Context: {
			/** Function: init
			 * Initialize context menu and setup mouseleave handler.
			 */
            init: function () {
				if ($('#context-menu').length === 0) {
					var html = Mustache.to_html(Candy.View.Template.Chat.Context.menu);
					$('#chat-pane').append(html);
                    $('#context-menu').mouseleave(function () {
						$(this).fadeOut('fast');
					});
				}
			},

			/** Function: show
			 * Show context menu (positions it according to the window height/width)
			 *
			 * Uses:
			 *   <getMenuLinks> for getting menulinks the user has access to
			 *   <Candy.Util.getPosLeftAccordingToWindowBounds> for positioning
			 *   <Candy.Util.getPosTopAccordingToWindowBounds> for positioning
			 *
			 * Calls:
			 *   <Candy.View.Event.Roster.afterContextMenu> after showing the context menu
			 *
			 * Parameters:
			 *   (Element) elem - On which element it should be shown
			 *   (String) roomJid - Room Jid of the room it should be shown
			 *   (Candy.Core.chatUser) user - User
			 */
            show: function (elem, roomJid, user) {
				elem = $(elem);
				var roomId = self.Chat.rooms[roomJid].id,
					menu = $('#context-menu'),
					links = $('ul li', menu);

				$('#tooltip').hide();

				// add specific context-user class if a user is available (when context menu should be opened next to a user)
                if (!user) {
					user = Candy.Core.getUser();
				}

				links.remove();

				var menulinks = this.getMenuLinks(roomJid, user, elem),
					id,
					clickHandler = function (roomJid, user) {
					    return function (event) {
							event.data.callback(event, roomJid, user);
							$('#context-menu').hide();
						};
					};

                for (id in menulinks) {
                    if (menulinks.hasOwnProperty(id)) {
						var link = menulinks[id],
							html = Mustache.to_html(Candy.View.Template.Chat.Context.menulinks, {
							    'roomId': roomId,
							    'class': link['class'],
							    'id': id,
							    'label': link.label
							});
						$('ul', menu).append(html);
						$('#context-menu-' + id).bind('click', link, clickHandler(roomJid, user));
					}
				}
				// if `id` is set the menu is not empty
                if (id) {
                    var candyPos = $('#candy').offset(),
                        pos = elem.offset(),
					    posLeft = Candy.Util.getPosLeftAccordingToWindowBounds(menu, pos.left - candyPos.left),
					    posTop = Candy.Util.getPosTopAccordingToWindowBounds(menu, pos.top - candyPos.top);

                    menu.css({ 'left': posLeft.px, 'top': posTop.px, backgroundPosition: posLeft.backgroundPositionAlignment + ' ' + posTop.backgroundPositionAlignment });
					menu.fadeIn('fast');

                    Candy.View.Event.Roster.afterContextMenu({ 'roomJid': roomJid, 'user': user, 'element': menu });

					return true;
				}
			},

			/** Function: getMenuLinks
			 * Extends <initialMenuLinks> with <Candy.View.Event.Roster.onContextMenu> links and returns those.
			 *
			 * Returns:
			 *   (Object) - object containing the extended menulinks.
			 */
            getMenuLinks: function (roomJid, user, elem) {
                var menulinks = $.extend(this.initialMenuLinks(elem), Candy.View.Event.Roster.onContextMenu({ 'roomJid': roomJid, 'user': user, 'elem': elem })),
					id;

                for (id in menulinks) {
                    if (menulinks.hasOwnProperty(id) && menulinks[id].requiredPermission !== undefined && !menulinks[id].requiredPermission(user, self.Room.getUser(roomJid), elem)) {
						delete menulinks[id];
					}
				}
				return menulinks;
			},

			/** Function: initialMenuLinks
			 * Returns initial menulinks. The following are initial:
			 *
			 * - Private Chat
			 * - Ignore
			 * - Unignore
			 * - Kick
			 * - Ban
			 * - Change Subject
			 *
			 * Returns:
			 *   (Object) - object containing those menulinks
			 */
            initialMenuLinks: function () {
				return {
					'private': {
                        requiredPermission: function (user, me) {
							return me.getNick() !== user.getNick() && Candy.Core.getRoom(Candy.View.getCurrent().roomJid) && !Candy.Core.getUser().isInPrivacyList('ignore', user.getJid());
						},
                        'class': 'private',
                        'label': $.i18n._('privateActionLabel'),
                        'callback': function (e, roomJid, user) {
							$('#user-' + Candy.Util.jidToId(roomJid) + '-' + Candy.Util.jidToId(user.getJid())).click();
						}
					},
					'ignore': {
                        requiredPermission: function (user, me) {
							return me.getNick() !== user.getNick() && !Candy.Core.getUser().isInPrivacyList('ignore', user.getJid());
						},
                        'class': 'ignore',
                        'label': $.i18n._('ignoreActionLabel'),
                        'callback': function (e, roomJid, user) {
							Candy.View.Pane.Room.ignoreUser(roomJid, user.getJid());
						}
					},
					'unignore': {
                        requiredPermission: function (user, me) {
							return me.getNick() !== user.getNick() && Candy.Core.getUser().isInPrivacyList('ignore', user.getJid());
						},
                        'class': 'unignore',
                        'label': $.i18n._('unignoreActionLabel'),
                        'callback': function (e, roomJid, user) {
							Candy.View.Pane.Room.unignoreUser(roomJid, user.getJid());
						}
					},
					'kick': {
                        requiredPermission: function (user, me) {
							return me.getNick() !== user.getNick() && me.isModerator() && !user.isModerator();
						},
                        'class': 'kick',
                        'label': $.i18n._('kickActionLabel'),
                        'callback': function (e, roomJid, user) {
							self.Chat.Modal.show(Mustache.to_html(Candy.View.Template.Chat.Context.contextModalForm, {
								_label: $.i18n._('reason'),
								_submit: $.i18n._('kickActionLabel')
							}), true);
							$('#context-modal-field').focus();
                            $('#context-modal-form').submit(function (event) {
								Candy.Core.Action.Jabber.Room.Admin.UserAction(roomJid, user.getJid(), 'kick', $('#context-modal-field').val());
								self.Chat.Modal.hide();
								return false; // stop propagation & preventDefault, as otherwise you get disconnected (wtf?)
							});
						}
					},
					'ban': {
                        requiredPermission: function (user, me) {
							return me.getNick() !== user.getNick() && me.isModerator() && !user.isModerator();
						},
                        'class': 'ban',
                        'label': $.i18n._('banActionLabel'),
                        'callback': function (e, roomJid, user) {
							self.Chat.Modal.show(Mustache.to_html(Candy.View.Template.Chat.Context.contextModalForm, {
								_label: $.i18n._('reason'),
								_submit: $.i18n._('banActionLabel')
							}), true);
							$('#context-modal-field').focus();
                            $('#context-modal-form').submit(function (e) {
								Candy.Core.Action.Jabber.Room.Admin.UserAction(roomJid, user.getJid(), 'ban', $('#context-modal-field').val());
								self.Chat.Modal.hide();
								return false; // stop propagation & preventDefault, as otherwise you get disconnected (wtf?)
							});
						}
					},
					'subject': {
                        requiredPermission: function (user, me) {
							return me.getNick() === user.getNick() && me.isModerator();
						},
						'class': 'subject',
                        'label': $.i18n._('setSubjectActionLabel'),
                        'callback': function (e, roomJid, user) {
							self.Chat.Modal.show(Mustache.to_html(Candy.View.Template.Chat.Context.contextModalForm, {
								_label: $.i18n._('subject'),
								_submit: $.i18n._('setSubjectActionLabel')
							}), true);
							$('#context-modal-field').focus();
                            $('#context-modal-form').submit(function (e) {
								Candy.Core.Action.Jabber.Room.Admin.SetSubject(roomJid, $('#context-modal-field').val());
								self.Chat.Modal.hide();
								e.preventDefault();
							});
						}
					}
				};
			},

			/** Function: showEmoticonsMenu
			 * Shows the special emoticons menu
			 *
			 * Parameters:
			 *   (Element) elem - Element on which it should be positioned to.
			 *
			 * Returns:
			 *   (Boolean) - true
			 */
            showEmoticonsMenu: function (elem) {
				elem = $(elem);
				var pos = elem.offset(),
					menu = $('#context-menu'),
					content = $('ul', menu),
					emoticons = '',
					i;

				$('#tooltip').hide();

				for (i = Candy.Util.Parser.emoticons.length - 1; i >= 0; i--) {
					emoticons = '<img src="' + Candy.Util.Parser._emoticonPath + Candy.Util.Parser.emoticons[i].image + '" alt="' + Candy.Util.Parser.emoticons[i].plain + '" />' + emoticons;
				}
				content.html('<li class="emoticons">' + emoticons + '</li>');
                content.find('img').click(function () {
					var input = Candy.View.Pane.Room.getPane(Candy.View.getCurrent().roomJid, '.message-form').children('.field'),
						value = input.val(),
						emoticon = $(this).attr('alt') + ' ';
					input.val(value ? value + ' ' + emoticon : emoticon).focus();
				});

                var candypos = $('#candy').offset(),
                    posLeft = Candy.Util.getPosLeftAccordingToWindowBounds(menu, pos.left - candypos.left - menu.width() + 20),
					posTop = Candy.Util.getPosTopAccordingToWindowBounds(menu, pos.top - candypos.top - menu.height() - 35);

                menu.css({ 'left': posLeft.px, 'top': posTop.px, backgroundPosition: 'bottom right'});
				menu.fadeIn('fast');

				return true;
			}
		}
	};

	/** Class: Candy.View.Pane.Room
	 * Everything which belongs to room view things belongs here.
	 */
	self.Room = {
		/** Function: init
		 * Initialize a new room and inserts the room html into the DOM
		 *
		 * Parameters:
		 *   (String) roomJid - Room JID
		 *   (String) roomName - Room name
		 *   (String) roomType - Type: either "groupchat" or "chat" (private chat)
		 *
		 * Uses:
		 *   - <Candy.Util.jidToId>
		 *   - <Candy.View.Pane.Chat.addTab>
		 *   - <getPane>
		 *
		 * Calls:
		 *   - <Candy.View.Event.Room.onAdd>
		 *
		 * Returns:
		 *   (String) - the room id of the element created.
		 */
        init: function (roomJid, roomName, roomType) {
			roomType = roomType || 'groupchat';
			// First room, show sound control
            if (Candy.Util.isEmptyObject(self.Chat.rooms)) {
				self.Chat.Toolbar.show();
			}

			var roomId = Candy.Util.jidToId(roomJid);
			self.Chat.rooms[roomJid] = { id: roomId, usercount: 0, name: roomName, type: roomType, messageCount: 0, scrollPosition: -1 };

			$('#chat-rooms').append(Mustache.to_html(Candy.View.Template.Room.pane, {
				roomId: roomId,
				roomJid: roomJid,
				roomType: roomType,
				form: {
					_messageSubmit: $.i18n._('messageSubmit')
				},
				roster: {
					_userOnline: $.i18n._('userOnline')
				}
			}, {
				roster: Candy.View.Template.Roster.pane,
				messages: Candy.View.Template.Message.pane,
                form: Candy.View.Template.Room.form//,
                // toolbar: Candy.View.Template.Room.toolbar
			}));
			self.Chat.addTab(roomJid, roomName, roomType);
			self.Room.getPane(roomJid, '.message-form').submit(self.Message.submit);

            Candy.View.Event.Room.onAdd({ 'roomJid': roomJid, 'type': roomType, 'element': self.Room.getPane(roomJid) });

			return roomId;
		},

		/** Function: show
		 * Show a specific room and hides the other rooms (if there are any)
		 *
		 * Parameters:
		 *   (String) roomJid - room jid to show
		 */
        show: function (roomJid) {
			var roomId = self.Chat.rooms[roomJid].id;
            $('.room-pane').each(function () {
				var elem = $(this);
                if (elem.attr('id') === ('chat-room-' + roomId)) {
					elem.show();
					Candy.View.getCurrent().roomJid = roomJid;
					self.Chat.updateToolbar(roomJid);
					self.Chat.setActiveTab(roomJid);
					self.Chat.clearUnreadMessages(roomJid);
					self.Room.setFocusToForm(roomJid);
					self.Room.scrollToBottom(roomJid);

                    Candy.View.Event.Room.onShow({ 'roomJid': roomJid, 'element': elem });
					
                } else if (elem.hasClass('roomtype-chat')) {
                    elem.hide();
                    Candy.View.Event.Room.onHide({ 'roomJid': roomJid, 'element': elem });
                }
				
			});
		},

		/** Function: setSubject
		 * Called when someone changes the subject in the channel
		 *
		 * Parameters:
		 *   (String) roomJid - Room Jid
		 *   (String) subject - The new subject
		 */
        setSubject: function (roomJid, subject) {
			var html = Mustache.to_html(Candy.View.Template.Room.subject, {
				subject: subject,
				roomName: self.Chat.rooms[roomJid].name,
				_roomSubject: $.i18n._('roomSubject'),
				time: Candy.Util.localizedTime(new Date().toGMTString())
			});
			self.Room.appendToMessagePane(roomJid, html);
			self.Room.scrollToBottom(roomJid);

            Candy.View.Event.Room.onSubjectChange({ 'roomJid': roomJid, 'element': self.Room.getPane(roomJid), 'subject': subject });
		},

		/** Function: close
		 * Close a room and remove everything in the DOM belonging to this room.
		 *
		 * NOTICE: There's a rendering bug in Opera when all rooms have been closed. (Take a look in the source for a more detailed description)
		 *
		 * Parameters:
		 *   (String) roomJid - Room to close
		 */
        close: function (roomJid) {
			self.Chat.removeTab(roomJid);
			self.Window.clearUnreadMessages();

			/* TODO:
				There's a rendering bug in Opera which doesn't redraw (remove) the message form.
				Only a cosmetical issue (when all tabs are closed) but it's annoying...
				This happens when form has no focus too. Maybe it's because of CSS positioning.
			*/
			self.Room.getPane(roomJid).remove();
			var openRooms = $('#chat-rooms').children();
            if (Candy.View.getCurrent().roomJid === roomJid) {
				Candy.View.getCurrent().roomJid = null;
                if (openRooms.length === 0) {
					self.Chat.allTabsClosed();
				} else {
					self.Room.show(openRooms.last().attr('data-roomjid'));
				}
			}
			delete self.Chat.rooms[roomJid];

            Candy.View.Event.Room.onClose({ 'roomJid': roomJid });
		},

		/** Function: appendToMessagePane
		 * Append a new message to the message pane.
		 *
		 * Parameters:
		 *   (String) roomJid - Room JID
		 *   (String) html - rendered message html
		 */
        appendToMessagePane: function (roomJid, html) {
			self.Room.getPane(roomJid, '.message-pane').append(html);
			self.Chat.rooms[roomJid].messageCount++;
			self.Room.sliceMessagePane(roomJid);
		},

		/** Function: sliceMessagePane
		 * Slices the message pane after the max amount of messages specified in the Candy View options (limit setting).
		 *
		 * This is done to hopefully prevent browsers from getting slow after a certain amount of messages in the DOM.
		 *
		 * The slice is only done when autoscroll is on, because otherwise someone might lose exactly the message he want to look for.
		 *
		 * Parameters:
		 *   (String) roomJid - Room JID
		 */
        sliceMessagePane: function (roomJid) {
			// Only clean if autoscroll is enabled
            if (self.Window.autoscroll) {
				var options = Candy.View.getOptions().messages;
                if (self.Chat.rooms[roomJid].messageCount > options.limit) {
                    self.Room.getPane(roomJid, '.message-pane').children().slice(0, options.remove * 2).remove();
					self.Chat.rooms[roomJid].messageCount -= options.remove;
				}
			}
		},

		/** Function: scrollToBottom
		 * Scroll to bottom wrapper for <onScrollToBottom> to be able to disable it by overwriting the function.
		 *
		 * Parameters:
		 *   (String) roomJid - Room JID
		 *
		 * Uses:
		 *   - <onScrollToBottom>
		 */
        scrollToBottom: function (roomJid) {
			self.Room.onScrollToBottom(roomJid);
		},

		/** Function: onScrollToBottom
		 * Scrolls to the latest message received/sent.
		 *
		 * Parameters:
		 *   (String) roomJid - Room JID
		 */
        onScrollToBottom: function (roomJid) {
			var messagePane = self.Room.getPane(roomJid, '.message-pane-wrapper');
			messagePane.scrollTop(messagePane.prop('scrollHeight'));
		},

		/** Function: onScrollToStoredPosition
		 * When autoscroll is off, the position where the scrollbar is has to be stored for each room, because it otherwise
		 * goes to the top in the message window.
		 *
		 * Parameters:
		 *   (String) roomJid - Room JID
		 */
        onScrollToStoredPosition: function (roomJid) {
			// This should only apply when entering a room...
			// ... therefore we set scrollPosition to -1 after execution.
            if (self.Chat.rooms[roomJid].scrollPosition > -1) {
				var messagePane = self.Room.getPane(roomJid, '.message-pane-wrapper');
				messagePane.scrollTop(self.Chat.rooms[roomJid].scrollPosition);
				self.Chat.rooms[roomJid].scrollPosition = -1;
			}
		},

		/** Function: setFocusToForm
		 * Set focus to the message input field within the message form.
		 *
		 * Parameters:
		 *   (String) roomJid - Room JID
		 */
        setFocusToForm: function (roomJid) {
			var pane = self.Room.getPane(roomJid, '.message-form');
			if (pane) {
				// IE8 will fail maybe, because the field isn't there yet.
				try {
					pane.children('.field')[0].focus();
                } catch (e) {
					// fail silently
				}
			}
		},

		/** Function: setUser
		 * Sets or updates the current user in the specified room (called by <Candy.View.Pane.Roster.update>) and set specific informations
		 * (roles and affiliations) on the room tab (chat-pane).
		 *
		 * Parameters:
		 *   (String) roomJid - Room in which the user is set to.
		 *   (Candy.Core.ChatUser) user - The user
		 */
        setUser: function (roomJid, user) {
			self.Chat.rooms[roomJid].user = user;
			var roomPane = self.Room.getPane(roomJid),
				chatPane = $('#chat-pane');

			roomPane.attr('data-userjid', user.getJid());
			// Set classes based on user role / affiliation
            if (user.isModerator()) {
				if (user.getRole() === user.ROLE_MODERATOR) {
					chatPane.addClass('role-moderator');
				}
				if (user.getAffiliation() === user.AFFILIATION_OWNER) {
					chatPane.addClass('affiliation-owner');
				}
			} else {
				chatPane.removeClass('role-moderator affiliation-owner');
			}
			self.Chat.Context.init();
		},

		/** Function: getUser
		 * Get the current user in the room specified with the jid
		 *
		 * Parameters:
		 *   (String) roomJid - Room of which the user should be returned from
		 *
		 * Returns:
		 *   (Candy.Core.ChatUser) - user
		 */
        getUser: function (roomJid) {
			return self.Chat.rooms[roomJid].user;
		},

		/** Function: ignoreUser
		 * Ignore specified user and add the ignore icon to the roster item of the user
		 *
		 * Parameters:
		 *   (String) roomJid - Room in which the user should be ignored
		 *   (String) userJid - User which should be ignored
		 */
        ignoreUser: function (roomJid, userJid) {
			Candy.Core.Action.Jabber.Room.IgnoreUnignore(userJid);
			Candy.View.Pane.Room.addIgnoreIcon(roomJid, userJid);
		},

		/** Function: unignoreUser
		 * Unignore an ignored user and remove the ignore icon of the roster item.
		 *
		 * Parameters:
		 *   (String) roomJid - Room in which the user should be unignored
		 *   (String) userJid - User which should be unignored
		 */
        unignoreUser: function (roomJid, userJid) {
			Candy.Core.Action.Jabber.Room.IgnoreUnignore(userJid);
			Candy.View.Pane.Room.removeIgnoreIcon(roomJid, userJid);
		},

		/** Function: addIgnoreIcon
		 * Add the ignore icon to the roster item of the specified user
		 *
		 * Parameters:
		 *   (String) roomJid - Room in which the roster item should be updated
		 *   (String) userJid - User of which the roster item should be updated
		 */
        addIgnoreIcon: function (roomJid, userJid) {
			if (Candy.View.Pane.Chat.rooms[userJid]) {
				$('#user-' + Candy.View.Pane.Chat.rooms[userJid].id + '-' + Candy.Util.jidToId(userJid)).addClass('status-ignored');
			}
			if (Candy.View.Pane.Chat.rooms[Strophe.getBareJidFromJid(roomJid)]) {
				$('#user-' + Candy.View.Pane.Chat.rooms[Strophe.getBareJidFromJid(roomJid)].id + '-' + Candy.Util.jidToId(userJid)).addClass('status-ignored');
			}
		},

		/** Function: removeIgnoreIcon
		 * Remove the ignore icon to the roster item of the specified user
		 *
		 * Parameters:
		 *   (String) roomJid - Room in which the roster item should be updated
		 *   (String) userJid - User of which the roster item should be updated
		 */
        removeIgnoreIcon: function (roomJid, userJid) {
			if (Candy.View.Pane.Chat.rooms[userJid]) {
				$('#user-' + Candy.View.Pane.Chat.rooms[userJid].id + '-' + Candy.Util.jidToId(userJid)).removeClass('status-ignored');
			}
			if (Candy.View.Pane.Chat.rooms[Strophe.getBareJidFromJid(roomJid)]) {
				$('#user-' + Candy.View.Pane.Chat.rooms[Strophe.getBareJidFromJid(roomJid)].id + '-' + Candy.Util.jidToId(userJid)).removeClass('status-ignored');
			}
		},

		/** Function: getPane
		 * Get the chat room pane or a subPane of it (if subPane is specified)
		 *
		 * Parameters:
		 *   (String) roomJid - Room in which the pane lies
		 *   (String) subPane - Sub pane of the chat room pane if needed [optional]
		 */
        getPane: function (roomJid, subPane) {
			if (self.Chat.rooms[roomJid]) {
                if (subPane) {
                    if (self.Chat.rooms[roomJid]['pane-' + subPane]) {
						return self.Chat.rooms[roomJid]['pane-' + subPane];
					} else {
						self.Chat.rooms[roomJid]['pane-' + subPane] = $('#chat-room-' + self.Chat.rooms[roomJid].id).find(subPane);
						return self.Chat.rooms[roomJid]['pane-' + subPane];
					}
				} else {
					return $('#chat-room-' + self.Chat.rooms[roomJid].id);
				}
			}
		}
	};

	/** Class: Candy.View.Pane.PrivateRoom
	 * Private room handling
	 */
	self.PrivateRoom = {
		/** Function: open
		 * Opens a new private room
		 *
		 * Parameters:
		 *   (String) roomJid - Room jid to open
		 *   (String) roomName - Room name
		 *   (Boolean) switchToRoom - If true, displayed room switches automatically to this room
		 *                            (e.g. when user clicks itself on another user to open a private chat)
		 *   (Boolean) isNoConferenceRoomJid - true if a 3rd-party client sends a direct message to this user (not via the room)
		 *										then the username is the node and not the resource. This param addresses this case.
		 *
		 * Calls:
		 *   - <Candy.View.Event.Room.onAdd>
		 */
        open: function (roomJid, roomName, switchToRoom, isNoConferenceRoomJid) {
			var user = isNoConferenceRoomJid ? Candy.Core.getUser() : self.Room.getUser(Strophe.getBareJidFromJid(roomJid));
			// if target user is in privacy list, don't open the private chat.
			if (Candy.Core.getUser().isInPrivacyList('ignore', roomJid)) {
				return false;
			}
            if (!self.Chat.rooms[roomJid]) {
				self.Room.init(roomJid, roomName, 'chat');
			}
            if (switchToRoom) {
				self.Room.show(roomJid);
			}
			self.Roster.update(roomJid, new Candy.Core.ChatUser(roomJid, roomName), 'join', user);
			self.Roster.update(roomJid, user, 'join', user);
			self.PrivateRoom.setStatus(roomJid, 'join');


			// We can't track the presence of a user if it's not a conference jid
            if (isNoConferenceRoomJid) {
				self.Chat.infoMessage(roomJid, $.i18n._('presenceUnknownWarningSubject'), $.i18n._('presenceUnknownWarning'));
			}

            Candy.View.Event.Room.onAdd({ 'roomJid': roomJid, type: 'chat', 'element': self.Room.getPane(roomJid) });
		},

		/** Function: setStatus
		 * Set offline or online status for private rooms (when one of the participants leaves the room)
		 *
		 * Parameters:
		 *   (String) roomJid - Private room jid
		 *   (String) status - "leave"/"join"
		 */
        setStatus: function (roomJid, status) {
			var messageForm = self.Room.getPane(roomJid, '.message-form');
            if (status === 'join') {
				self.Chat.getTab(roomJid).addClass('online').removeClass('offline');

				messageForm.children('.field').removeAttr('disabled');
				messageForm.children('.submit').removeAttr('disabled');

				self.Chat.getTab(roomJid);
			} else {
				self.Chat.getTab(roomJid).addClass('offline').removeClass('online');

				messageForm.children('.field').attr('disabled', true);
				messageForm.children('.submit').attr('disabled', true);
			}
		}
	};

	/** Class Candy.View.Pane.Roster
	 * Handles everyhing regarding roster updates.
	 */
	self.Roster = {
		/** Function: update
		 * Called by <Candy.View.Observer.Presence.update> to update the roster if needed.
		 * Adds/removes users from the roster list or updates informations on their items (roles, affiliations etc.)
		 *
		 * TODO: Refactoring, this method has too much LOC.
		 *
		 * Parameters:
		 *   (String) roomJid - Room JID in which the update happens
		 *   (Candy.Core.ChatUser) user - User on which the update happens
		 *   (String) action - one of "join", "leave", "kick" and "ban"
		 *   (Candy.Core.ChatUser) currentUser - Current user
		 */
        update: function (roomJid, user, action, currentUser) {
			var roomId = self.Chat.rooms[roomJid].id,
				userId = Candy.Util.jidToId(user.getJid()),
				usercountDiff = -1;

			// a user joined the room
            if (action === 'join') {
				usercountDiff = 1;
				var html = Mustache.to_html(Candy.View.Template.Roster.user, {
						roomId: roomId,
                        userId: userId,
						userJid: user.getJid(),
						nick: user.getNick(),
						displayNick: Candy.Util.crop(user.getNick(), Candy.View.getOptions().crop.roster.nickname),
						role: user.getRole(),
						affiliation: user.getAffiliation(),
						me: currentUser !== undefined && user.getNick() === currentUser.getNick(),
						tooltipRole: $.i18n._('tooltipRole'),
						tooltipIgnored: $.i18n._('tooltipIgnored')
					}),
					userElem = $('#user-' + roomId + '-' + userId);

                if (userElem.length < 1) {
					var userInserted = false,
						rosterPane = self.Room.getPane(roomJid, '.roster-pane');
					// there are already users in the roster
                    if (rosterPane.children().length > 0) {
						// insert alphabetically
						var userSortCompare = user.getNick().toUpperCase();
                        rosterPane.children().each(function () {
							var elem = $(this);
                            if (elem.attr('data-nick').toUpperCase() > userSortCompare) {
								elem.before(html);
								userInserted = true;
								return false;
							}
							return true;
						});
					}
					// first user in roster
                    if (!userInserted) {
						rosterPane.append(html);
					}

					self.Roster.joinAnimation('user-' + roomId + '-' + userId);
					// only show other users joining & don't show if there's no message in the room.
                    if (currentUser !== undefined && user.getNick() !== currentUser.getNick() && self.Room.getUser(roomJid)) {
						// always show join message in private room, even if status messages have been disabled
						if (self.Chat.rooms[roomJid].type === 'chat') {
							self.Chat.onInfoMessage(roomJid, $.i18n._('userJoinedRoom', [user.getNick()]));
						} else {
							self.Chat.infoMessage(roomJid, $.i18n._('userJoinedRoom', [user.getNick()]));
						}
					}
				// user is in room but maybe the affiliation/role has changed
				} else {
					usercountDiff = 0;
					userElem.replaceWith(html);
                    $('#user-' + roomId + '-' + userId).css({ opacity: 1 }).show();
				}

				// Presence of client
				if (currentUser !== undefined && currentUser.getNick() === user.getNick()) {
					self.Room.setUser(roomJid, user);
				// add click handler for private chat
				} else {
					$('#user-' + roomId + '-' + userId).click(self.Roster.userClick);
				}

                $('#user-' + roomId + '-' + userId + ' .context').click(function (e) {
					self.Chat.Context.show(e.currentTarget, roomJid, user);
					e.stopPropagation();
				});

				// check if current user is ignoring the user who has joined.
				if (currentUser !== undefined && currentUser.isInPrivacyList('ignore', user.getJid())) {
					Candy.View.Pane.Room.addIgnoreIcon(roomJid, user.getJid());
				}

			// a user left the room
            } else if (action === 'leave') {
				self.Roster.leaveAnimation('user-' + roomId + '-' + userId);
				// always show leave message in private room, even if status messages have been disabled
				if (self.Chat.rooms[roomJid].type === 'chat') {
					self.Chat.onInfoMessage(roomJid, $.i18n._('userLeftRoom', [user.getNick()]));
				} else {
					self.Chat.infoMessage(roomJid, $.i18n._('userLeftRoom', [user.getNick()]));
				}
			// user has been kicked
            } else if (action === 'kick') {
				self.Roster.leaveAnimation('user-' + roomId + '-' + userId);
				self.Chat.onInfoMessage(roomJid, $.i18n._('userHasBeenKickedFromRoom', [user.getNick()]));
			// user has been banned
            } else if (action === 'ban') {
				self.Roster.leaveAnimation('user-' + roomId + '-' + userId);
				self.Chat.onInfoMessage(roomJid, $.i18n._('userHasBeenBannedFromRoom', [user.getNick()]));
			}

			// Update user count
			Candy.View.Pane.Chat.rooms[roomJid].usercount += usercountDiff;

            if (roomJid === Candy.View.getCurrent().roomJid) {
                // Candy.View.Pane.Chat.Toolbar.updateUsercount(Candy.View.Pane.Chat.rooms[roomJid].usercount);
                Candy.View.Pane.Chat.Toolbar.updateUsercount(Candy.View.Pane.Chat.rooms[_chatRoom].usercount);
			}

            Candy.View.Event.Roster.onUpdate({ 'roomJid': roomJid, 'user': user, 'action': action, 'element': $('#user-' + roomId + '-' + userId) });
		},

		/** Function: userClick
		 * Click handler for opening a private room
		 */
        userClick: function () {
            var elem = $(this);
            $('.user.active').removeClass('active');
            elem.addClass('active');
            $('#chat-toolbar').addClass('active');
			self.PrivateRoom.open(elem.attr('data-jid'), elem.attr('data-nick'), true);
			self.Room.getPane(elem.attr('data-jid'), '.message-pane-wrapper').css({ display: 'block' });
			self.Room.getPane(elem.attr('data-jid'), '.message-form').css({ display: 'block' });
		},

		/** Function: joinAnimation
		 * Animates specified elementId on join
		 *
		 * Parameters:
		 *   (String) elementId - Specific element to do the animation on
		 */
        joinAnimation: function (elementId) {
            $('#' + elementId).stop(true).slideDown('normal', function () { $(this).animate({ opacity: 1 }); });
		},

		/** Function: leaveAnimation
		 * Leave animation for specified element id and removes the DOM element on completion.
		 *
		 * Parameters:
		 *   (String) elementId - Specific element to do the animation on
		 */
        leaveAnimation: function (elementId) {
			$('#' + elementId).stop(true).attr('id', '#' + elementId + '-leaving').animate({ opacity: 0 }, {
                complete: function () {
                    $(this).slideUp('normal', function () { $(this).remove(); });
				}
			});
		}
	};

	/** Class: Candy.View.Pane.Message
	 * Message submit/show handling
	 */
	self.Message = {
		/** Function: submit
		 * on submit handler for message field sends the message to the server and if it's a private chat, shows the message
		 * immediately because the server doesn't send back those message.
		 *
		 * Parameters:
		 *   (Event) event - Triggered event
		 */
        submit: function (event) {
			var roomType = Candy.View.Pane.Chat.rooms[Candy.View.getCurrent().roomJid].type,
				message = $(this).children('.field').val().substring(0, Candy.View.getOptions().crop.message.body);

			message = Candy.View.Event.Message.beforeSend(message);

			Candy.Core.Action.Jabber.Room.Message(Candy.View.getCurrent().roomJid, message, roomType);
			// Private user chat. Jabber won't notify the user who has sent the message. Just show it as the user hits the button...
            if (roomType === 'chat' && message) {
				self.Message.show(Candy.View.getCurrent().roomJid, self.Room.getUser(Candy.View.getCurrent().roomJid).getNick(), message);
			}
			// Clear input and set focus to it
			$(this).children('.field').val('').focus();
			event.preventDefault();
		},

		/** Function: show
		 * Show a message in the message pane
		 *
		 * Parameters:
		 *   (String) roomJid - room in which the message has been sent to
		 *   (String) name - Name of the user which sent the message
		 *   (String) message - Message
		 *   (String) timestamp - [optional] Timestamp of the message, if not present, current date.
		 */
        show: function (roomJid, name, message, timestamp) {
			message = Candy.Util.Parser.all(message.substring(0, Candy.View.getOptions().crop.message.body));
            message = Candy.View.Event.Message.beforeShow({ 'roomJid': roomJid, 'nick': name, 'message': message });
            if (!message) {
				return;
			}

			var html = Mustache.to_html(Candy.View.Template.Message.item, {
				name: name,
				displayName: Candy.Util.crop(name, Candy.View.getOptions().crop.message.nickname),
				message: message,
				me: name === Candy.Core.getUser().getNick(),
				time: Candy.Util.formatAMPM(timestamp ? new Date(timestamp) : new Date()) // Candy.Util.localizedTime(timestamp || new Date().toGMTString())
			});
			self.Room.appendToMessagePane(roomJid, html);
			var elem = self.Room.getPane(roomJid, '.message-pane').children().last();
			// click on username opens private chat
            elem.find('a.name').click(function (event) {
				event.preventDefault();
				// Check if user is online and not myself
                if (name !== self.Room.getUser(Candy.View.getCurrent().roomJid).getNick() && Candy.Core.getRoom(roomJid).getRoster().get(roomJid + '/' + name)) {
					Candy.View.Pane.PrivateRoom.open(roomJid + '/' + name, name, true);
				}
			});

			// Notify the user about a new private message
            if (Candy.View.getCurrent().roomJid !== roomJid || !self.Window.hasFocus()) {
				self.Chat.increaseUnreadMessages(roomJid);
                if (Candy.View.Pane.Chat.rooms[roomJid].type === 'chat' && !self.Window.hasFocus()) {
					self.Chat.Toolbar.playSound();
				}
			}
            if (Candy.View.getCurrent().roomJid === roomJid) {
				self.Room.scrollToBottom(roomJid);
			}

            Candy.View.Event.Message.onShow({ 'roomJid': roomJid, 'element': elem, 'nick': name, 'message': message });
		}
	};

	return self;
}(Candy.View.Pane || {}, jQuery));
/** File: template.js
 * Candy - Chats are not dead yet.
 *
 * Authors:
 *   - Patrick Stadler <patrick.stadler@gmail.com>
 *   - Michael Weibel <michael.weibel@gmail.com>
 *
 * Copyright:
 *   (c) 2011 Amiado Group AG. All rights reserved.
 */

/** Class: Candy.View.Template
 * Contains mustache.js templates
 */
Candy.View.Template = (function (self) {
	self.Window = {
		/**
		 * Unread messages - used to extend the window title
		 */
		unreadmessages: '({{count}}) {{title}}'
	};

	self.Chat = {
		pane: '<div id="chat-pane">{{> tabs}}{{> toolbar}}{{> rooms}}</div>{{> modal}}',
		rooms: '<div id="chat-rooms" class="rooms"></div>',
		tabs: '<ul id="chat-tabs"></ul>',
	    //tab: '<li class="roomtype-{{roomType}}" data-roomjid="{{roomJid}}" data-roomtype="{{roomType}}"><a href="#" class="label">{{#privateUserChat}}@{{/privateUserChat}}{{name}}</a><a href="#" class="transition"></a><a href="#" class="close">\u00D7</a><small class="unread"></small></li>',
		tab: '<li class="roomtype-{{roomType}}" data-roomjid="{{roomJid}}" data-roomtype="{{roomType}}"><a href="#" class="label">{{#privateUserChat}}@{{/privateUserChat}}{{name}}</a><small class="{{countClass}}"></small></li>',
		modal: '<div id="chat-modal"><a id="admin-message-cancel" class="close" href="#">\u00D7</a><span id="chat-modal-body"></span><img src="{{resourcesPath}}img/modal-spinner.gif" id="chat-modal-spinner" /></div><div id="chat-modal-overlay"></div>',
		adminMessage: '<dt><span class="label">{{sender}}</span> ({{time}}):</dt><dd class="adminmessage">{{subject}} {{message}}</dd>',
		infoMessage: '<dt>{{time}}</dt><dd class="infomessage">{{subject}} {{message}}</dd>',
	    //toolbar: '<ul id="chat-toolbar"><li id="emoticons-icon" data-tooltip="{{tooltipEmoticons}}"></li><li id="chat-sound-control" class="checked" data-tooltip="{{tooltipSound}}">{{> soundcontrol}}</li><li id="chat-autoscroll-control" class="checked" data-tooltip="{{tooltipAutoscroll}}"></li><li class="checked" id="chat-statusmessage-control" data-tooltip="{{tooltipStatusmessage}}"></li><li class="context" data-tooltip="{{tooltipAdministration}}"></li><li class="usercount" data-tooltip="{{tooltipUsercount}}"><span id="chat-usercount"></span></li></ul>',
	    toolbar: '<ul id="chat-toolbar"><li id="emoticons-icon" data-tooltip="{{tooltipEmoticons}}"></li></ul>',
        soundcontrol: '<script type="text/javascript">var audioplayerListener = new Object(); audioplayerListener.onInit = function() { };'
						+ '</script><object id="chat-sound-player" type="application/x-shockwave-flash" data="{{resourcesPath}}audioplayer.swf"'
						+ ' width="0" height="0"><param name="movie" value="{{resourcesPath}}audioplayer.swf" /><param name="AllowScriptAccess"'
						+ ' value="always" /><param name="FlashVars" value="listener=audioplayerListener&amp;mp3={{resourcesPath}}notify.mp3" />'
						+ '</object>',
		Context: {
			menu: '<div id="context-menu"><ul></ul></div>',
			menulinks: '<li class="{{class}}" id="context-menu-{{id}}">{{label}}</li>',
			contextModalForm: '<form action="#" id="context-modal-form"><label for="context-modal-label">{{_label}}</label><input type="text" name="contextModalField" id="context-modal-field" /><input type="submit" class="button" name="send" value="{{_submit}}" /></form>',
			adminMessageReason: '<a id="admin-message-cancel" class="close" href="#">×</a><p>{{_action}}</p>{{#reason}}<p>{{_reason}}</p>{{/reason}}'
		},
		tooltip: '<div id="tooltip"><div></div></div>'
	};

	self.Room = {
		pane: '<div class="room-pane roomtype-{{roomType}}" id="chat-room-{{roomId}}" data-roomjid="{{roomJid}}" data-roomtype="{{roomType}}">{{> roster}}{{> messages}}{{> form}}</div>',
		subject: '<dt>{{time}}</dt><dd class="subject"><span class="label">{{roomName}}</span>{{_roomSubject}} {{subject}}</dd>',
		//form: '<div class="message-form-wrapper"></div><form method="post" class="message-form"><input name="message" class="field" type="text" autocomplete="off" maxlength="1000" /><input type="submit" class="submit" name="submit" value="{{_messageSubmit}}" /></form>'
		form: '<form method="post" class="message-form"><input name="message" class="field" type="text" autocomplete="off" maxlength="1000" /><input type="submit" class="submit" name="submit" value="{{_messageSubmit}}" /></form>',
	    // toolbar: '<ul id="chat-toolbar"><li class="emoticons-icon" data-tooltip="{{tooltipEmoticons}}"></li></ul>',
        toolbar: ''
	};

	self.Roster = {
		pane: '<div class="roster-pane"></div>',
		user: '<div class="user role-{{role}} affiliation-{{affiliation}}{{#me}} me{{/me}}" id="user-{{roomId}}-{{userId}}" data-jid="{{userJid}}" data-nick="{{nick}}" data-role="{{role}}" data-affiliation="{{affiliation}}"><div class="label">{{displayNick}}</div><small class="chat-unread"></small><ul><li class="context" id="context-{{roomId}}-{{userId}}"></li><li class="role role-{{role}} affiliation-{{affiliation}}" data-tooltip="{{tooltipRole}}"></li><li class="ignore" data-tooltip="{{tooltipIgnored}}"></li></ul></div>'
	};

	self.Message = {
	    pane: '<div class="message-pane-wrapper"><dl class="message-pane"></dl></div>',
	    item: '<dt{{#me}} class="me"{{/me}}><a href="#" class="name">{{displayName}}</a> ({{time}}):</dt><dd><span class="label"></span>{{{message}}}</dd>'
	};

	self.Login = {
		form: '<form method="post" id="login-form" class="login-form">'
			+ '{{#displayUsername}}<label for="username">{{_labelUsername}}</label><input type="text" id="username" name="username"/>{{/displayUsername}}'
			+ '{{#presetJid}}<input type="hidden" id="username" name="username" value="{{presetJid}}"/>{{/presetJid}}'
			+ '{{#displayPassword}}<label for="password">{{_labelPassword}}</label><input type="password" id="password" name="password" />{{/displayPassword}}'
			+ '<input type="submit" class="button" value="{{_loginSubmit}}" /></form>'
	};
	
	self.PresenceError = {
		enterPasswordForm: '<strong>{{_label}}</strong>'
			+ '<form method="post" id="enter-password-form" class="enter-password-form">'
			+ '<label for="password">{{_labelPassword}}</label><input type="password" id="password" name="password" />'
			+ '<input type="submit" class="button" value="{{_joinSubmit}}" /></form>',
		nicknameConflictForm: '<strong>{{_label}}</strong>'
			+ '<form method="post" id="nickname-conflict-form" class="nickname-conflict-form">'
			+ '<label for="nickname">{{_labelNickname}}</label><input type="text" id="nickname" name="nickname" />'
			+ '<input type="submit" class="button" value="{{_loginSubmit}}" /></form>',
		displayError: '<strong>{{_error}}</strong>'
	};

	return self;
}(Candy.View.Template || {}));
/** File: translation.js
 * Candy - Chats are not dead yet.
 *
 * Authors:
 *   - Patrick Stadler <patrick.stadler@gmail.com>
 *   - Michael Weibel <michael.weibel@gmail.com>
 *
 * Copyright:
 *   (c) 2011 Amiado Group AG. All rights reserved.
 */

/** Class: Candy.View.Translation
 * Contains translations
 */
Candy.View.Translation = {
    'en': {
		'status': 'Status: %s',
		'statusConnecting': 'Connecting...',
        'statusConnected': 'Connected',
		'statusDisconnecting': 'Disconnecting...',
        'statusDisconnected': 'Disconnected',
		'statusAuthfail': 'Authentication failed',

        'roomSubject': 'Subject:',
		'messageSubmit': 'Send',

		'labelUsername': 'Username:',
		'labelPassword': 'Password:',
        'loginSubmit': 'Login',
        'loginInvalid': 'Invalid JID',

        'reason': 'Reason:',
        'subject': 'Subject:',
        'reasonWas': 'Reason was: %s.',
        'kickActionLabel': 'Kick',
        'youHaveBeenKickedBy': 'You have been kicked from %2$s by %1$s',
        'youHaveBeenKicked': 'You have been kicked from %s',
        'banActionLabel': 'Ban',
        'youHaveBeenBannedBy': 'You have been banned from %1$s by %2$s',
        'youHaveBeenBanned': 'You have been banned from %s',

        'privateActionLabel': 'Private chat',
        'ignoreActionLabel': 'Ignore',
        'unignoreActionLabel': 'Unignore',

		'setSubjectActionLabel': 'Change Subject',

        'administratorMessageSubject': 'Administrator',

        'userJoinedRoom': '%s joined the room.',
        'userLeftRoom': '%s left the room.',
		'userHasBeenKickedFromRoom': '%s has been kicked from the room.',
		'userHasBeenBannedFromRoom': '%s has been banned from the room.',

		'presenceUnknownWarningSubject': 'Notice:',
        'presenceUnknownWarning': 'This user might be offline. We can\'t track his presence.',

		'dateFormat': 'dd.mm.yyyy',
		'timeFormat': 'HH:MM:ss',

        'tooltipRole': 'Moderator',
        'tooltipIgnored': 'You ignore this user',
        'tooltipEmoticons': 'Emoticons',
        'tooltipSound': 'Play sound for new private messages',
        'tooltipAutoscroll': 'Autoscroll',
        'tooltipStatusmessage': 'Display status messages',
        'tooltipAdministration': 'Room Administration',
        'tooltipUsercount': 'Room Occupants',

        'enterRoomPassword': 'Room "%s" is password protected.',
        'enterRoomPasswordSubmit': 'Join room',
        'passwordEnteredInvalid': 'Invalid password for room "%s".',

		'nicknameConflict': 'Username already in use. Please choose another one.',

		'errorMembersOnly': 'You can\'t join room "%s": Insufficient rights.',
		'errorMaxOccupantsReached': 'You can\'t join room "%s": Too many occupants.',

        'antiSpamMessage': 'Please do not spam. You have been blocked for a short-time.'
	},
	
    'de': {
		'status': 'Status: %s',
		'statusConnecting': 'Verbinden...',
        'statusConnected': 'Verbunden',
		'statusDisconnecting': 'Verbindung trennen...',
        'statusDisconnected': 'Verbindung getrennt',
		'statusAuthfail': 'Authentifizierung fehlgeschlagen',

        'roomSubject': 'Thema:',
		'messageSubmit': 'Senden',

		'labelUsername': 'Benutzername:',
		'labelPassword': 'Passwort:',
        'loginSubmit': 'Anmelden',
        'loginInvalid': 'Ungültige JID',

        'reason': 'Begründung:',
        'subject': 'Titel:',
        'reasonWas': 'Begründung: %s.',
        'kickActionLabel': 'Kick',
        'youHaveBeenKickedBy': 'Du wurdest soeben aus dem Raum %1$s gekickt (%2$s)',
        'youHaveBeenKicked': 'Du wurdest soeben aus dem Raum %s gekickt',
        'banActionLabel': 'Ban',
        'youHaveBeenBannedBy': 'Du wurdest soeben aus dem Raum %1$s verbannt (%2$s)',
        'youHaveBeenBanned': 'Du wurdest soeben aus dem Raum %s verbannt',

        'privateActionLabel': 'Privater Chat',
        'ignoreActionLabel': 'Ignorieren',
        'unignoreActionLabel': 'Nicht mehr ignorieren',

		'setSubjectActionLabel': 'Thema ändern',

        'administratorMessageSubject': 'Administrator',

        'userJoinedRoom': '%s hat soeben den Raum betreten.',
        'userLeftRoom': '%s hat soeben den Raum verlassen.',
		'userHasBeenKickedFromRoom': '%s ist aus dem Raum gekickt worden.',
		'userHasBeenBannedFromRoom': '%s ist aus dem Raum verbannt worden.',

		'presenceUnknownWarningSubject': 'Hinweis:',
        'presenceUnknownWarning': 'Dieser Benutzer könnte bereits abgemeldet sein. Wir können seine Anwesenheit nicht verfolgen.',

		'dateFormat': 'dd.mm.yyyy',
		'timeFormat': 'HH:MM:ss',

        'tooltipRole': 'Moderator',
        'tooltipIgnored': 'Du ignorierst diesen Benutzer',
        'tooltipEmoticons': 'Smileys',
        'tooltipSound': 'Ton abspielen bei neuen privaten Nachrichten',
        'tooltipAutoscroll': 'Autoscroll',
        'tooltipStatusmessage': 'Statusnachrichten anzeigen',
        'tooltipAdministration': 'Raum Administration',
        'tooltipUsercount': 'Anzahl Benutzer im Raum',

        'enterRoomPassword': 'Raum "%s" ist durch ein Passwort geschützt.',
        'enterRoomPasswordSubmit': 'Raum betreten',
        'passwordEnteredInvalid': 'Inkorrektes Passwort für Raum "%s".',

		'nicknameConflict': 'Der Benutzername wird bereits verwendet. Bitte wähle einen anderen.',

		'errorMembersOnly': 'Du kannst den Raum "%s" nicht betreten: Ungenügende Rechte.',
		'errorMaxOccupantsReached': 'Du kannst den Raum "%s" nicht betreten: Benutzerlimit erreicht.',

        'antiSpamMessage': 'Bitte nicht spammen. Du wurdest für eine kurze Zeit blockiert.'
	},
	
    'fr': {
		'status': 'Status: %s',
		'statusConnecting': 'Connecter...',
        'statusConnected': 'Connecté.',
		'statusDisconnecting': 'Déconnecter....',
        'statusDisconnected': 'Déconnecté.',
		'statusAuthfail': 'Authentification a échoué',

        'roomSubject': 'Sujet:',
		'messageSubmit': 'Envoyer',

		'labelUsername': 'Nom d\'utilisateur:',
		'labelPassword': 'Mot de passe:',
        'loginSubmit': 'Inscription',
        'loginInvalid': 'JID invalide',

        'reason': 'Justification:',
        'subject': 'Titre:',
        'reasonWas': 'Justification: %s.',
        'kickActionLabel': 'Kick',
        'youHaveBeenKickedBy': 'Tu as été expulsé de le salon %1$s (%2$s)',
        'youHaveBeenKicked': 'Tu as été expulsé de le salon %s',
        'banActionLabel': 'Ban',
        'youHaveBeenBannedBy': 'Tu as été banni de le salon %1$s (%2$s)',
        'youHaveBeenBanned': 'Tu as été banni de le salon %s',

        'privateActionLabel': 'Chat privé',
        'ignoreActionLabel': 'Ignorer',
        'unignoreActionLabel': 'Ne plus ignorer',

		'setSubjectActionLabel': 'Changer le sujet',

        'administratorMessageSubject': 'Administrateur',

        'userJoinedRoom': '%s vient d\'entrer dans le salon.',
        'userLeftRoom': '%s vient de quitter le salon.',
		'userHasBeenKickedFromRoom': '%s a été expulsé du salon.',
		'userHasBeenBannedFromRoom': '%s a été banni du salon.',

		'presenceUnknownWarningSubject': 'Note:',
        'presenceUnknownWarning': 'Cet utilisateur n\'est malheureusement plus connecté, le message ne sera pas envoyé.',

		'dateFormat': 'dd.mm.yyyy',
		'timeFormat': 'HH:MM:ss',

        'tooltipRole': 'Modérateur',
        'tooltipIgnored': 'Tu ignores cette personne',
        'tooltipEmoticons': 'Smileys',
        'tooltipSound': 'Jouer un son lorsque tu reçois de nouveaux messages privés',
        'tooltipAutoscroll': 'Auto-defilement',
        'tooltipStatusmessage': 'Messages d\'état',
        'tooltipAdministration': 'Administrer le salon',
        'tooltipUsercount': 'Nombre d\'utilisateurs dans le salon',

        'enterRoomPassword': 'Le salon "%s" est protégé par un mot de passe.',
        'enterRoomPasswordSubmit': 'Entrer dans le salon',
        'passwordEnteredInvalid': 'Le mot de passe four le salon "%s" est invalide.',

		'nicknameConflict': 'Le nom d\'utilisateur est déjà utilisé. Choisi un autre.',

		'errorMembersOnly': 'Tu ne peut pas entrer de le salon "%s": droits insuffisants.',
		'errorMaxOccupantsReached': 'Tu ne peut pas entrer de le salon "%s": Limite d\'utilisateur atteint.',

        'antiSpamMessage': 'S\'il te plaît, pas de spam. Tu as été bloqué pendant une courte période..'
	},
	
    'nl': {
		'status': 'Status: %s',
		'statusConnecting': 'Verbinding maken...',
        'statusConnected': 'Verbinding is gereed',
		'statusDisconnecting': 'Verbinding verbreken...',
        'statusDisconnected': 'Verbinding is verbroken',
		'statusAuthfail': 'Authenticatie is mislukt',

        'roomSubject': 'Onderwerp:',
		'messageSubmit': 'Verstuur',

		'labelUsername': 'Gebruikersnaam:',
		'labelPassword': 'Wachtwoord:',
        'loginSubmit': 'Inloggen',
        'loginInvalid': 'JID is onjuist',

        'reason': 'Reden:',
        'subject': 'Onderwerp:',
        'reasonWas': 'De reden was: %s.',
        'kickActionLabel': 'Verwijderen',
        'youHaveBeenKickedBy': 'Je bent verwijderd van %1$s door %2$s',
        'youHaveBeenKicked': 'Je bent verwijderd van %s',
        'banActionLabel': 'Blokkeren',
        'youHaveBeenBannedBy': 'Je bent geblokkeerd van %1$s door %2$s',
        'youHaveBeenBanned': 'Je bent geblokkeerd van %s',

        'privateActionLabel': 'Prive gesprek',
        'ignoreActionLabel': 'Negeren',
        'unignoreActionLabel': 'Niet negeren',

		'setSubjectActionLabel': 'Onderwerp wijzigen',

        'administratorMessageSubject': 'Beheerder',

        'userJoinedRoom': '%s komt de chat binnen.',
        'userLeftRoom': '%s heeft de chat verlaten.',
		'userHasBeenKickedFromRoom': '%s is verwijderd.',
		'userHasBeenBannedFromRoom': '%s is geblokkeerd.',

		'presenceUnknownWarningSubject': 'Mededeling:',
        'presenceUnknownWarning': 'Deze gebruiker is waarschijnlijk offline, we kunnen zijn/haar aanwezigheid niet vaststellen.',

		'dateFormat': 'dd.mm.yyyy',
		'timeFormat': 'HH:MM:ss',

        'tooltipRole': 'Moderator',
        'tooltipIgnored': 'Je negeert deze gebruiker',
        'tooltipEmoticons': 'Emotie-iconen',
        'tooltipSound': 'Speel een geluid af bij nieuwe privé berichten.',
        'tooltipAutoscroll': 'Automatisch scrollen',
        'tooltipStatusmessage': 'Statusberichten weergeven',
        'tooltipAdministration': 'Instellingen',
        'tooltipUsercount': 'Gebruikers',

        'enterRoomPassword': 'De Chatroom "%s" is met een wachtwoord beveiligd.',
        'enterRoomPasswordSubmit': 'Ga naar Chatroom',
        'passwordEnteredInvalid': 'Het wachtwoord voor de Chatroom "%s" is onjuist.',

		'nicknameConflict': 'De gebruikersnaam is reeds in gebruik. Probeer a.u.b. een andere gebruikersnaam.',

		'errorMembersOnly': 'Je kunt niet deelnemen aan de Chatroom "%s": Je hebt onvoldoende rechten.',
		'errorMaxOccupantsReached': 'Je kunt niet deelnemen aan de Chatroom "%s": Het maximum aantal gebruikers is bereikt.',

        'antiSpamMessage': 'Het is niet toegestaan om veel berichten naar de server te versturen. Je bent voor een korte periode geblokkeerd.'
	},
	
	'es': {
		'status': 'Estado: %s',
		'statusConnecting': 'Conectando...',
        'statusConnected': 'Conectado',
		'statusDisconnecting': 'Desconectando...',
        'statusDisconnected': 'Desconectado',
		'statusAuthfail': 'Falló la autenticación',

        'roomSubject': 'Asunto:',
		'messageSubmit': 'Enviar',

		'labelUsername': 'Usuario:',
		'labelPassword': 'Clave:',
        'loginSubmit': 'Entrar',
        'loginInvalid': 'JID no válido',

        'reason': 'Razón:',
        'subject': 'Asunto:',
        'reasonWas': 'La razón fue: %s.',
        'kickActionLabel': 'Expulsar',
        'youHaveBeenKickedBy': 'Has sido expulsado de %1$s por %2$s',
        'youHaveBeenKicked': 'Has sido expulsado de %s',
        'banActionLabel': 'Prohibir',
        'youHaveBeenBannedBy': 'Has sido expulsado permanentemente de %1$s por %2$s',
        'youHaveBeenBanned': 'Has sido expulsado permanentemente de %s',

        'privateActionLabel': 'Chat privado',
        'ignoreActionLabel': 'Ignorar',
        'unignoreActionLabel': 'No ignorar',

		'setSubjectActionLabel': 'Cambiar asunto',

        'administratorMessageSubject': 'Administrador',

        'userJoinedRoom': '%s se ha unido a la sala.',
        'userLeftRoom': '%s ha dejado la sala.',
		'userHasBeenKickedFromRoom': '%s ha sido expulsado de la sala.',
		'userHasBeenBannedFromRoom': '%s ha sido expulsado permanentemente de la sala.',

		'presenceUnknownWarningSubject': 'Atención:',
        'presenceUnknownWarning': 'Éste usuario podría estar desconectado..',

		'dateFormat': 'dd.mm.yyyy',
		'timeFormat': 'HH:MM:ss',

        'tooltipRole': 'Moderador',
        'tooltipIgnored': 'Ignoras a éste usuario',
        'tooltipEmoticons': 'Emoticonos',
        'tooltipSound': 'Reproducir un sonido para nuevos mensajes privados',
        'tooltipAutoscroll': 'Desplazamiento automático',
        'tooltipStatusmessage': 'Mostrar mensajes de estado',
        'tooltipAdministration': 'Administración de la sala',
        'tooltipUsercount': 'Usuarios en la sala',

        'enterRoomPassword': 'La sala "%s" está protegida mediante contraseña.',
        'enterRoomPasswordSubmit': 'Unirse a la sala',
        'passwordEnteredInvalid': 'Contraseña incorrecta para la sala "%s".',

		'nicknameConflict': 'El nombre de usuario ya está siendo utilizado. Por favor elija otro.',

		'errorMembersOnly': 'No se puede unir a la sala "%s": no tiene privilegios suficientes.',
		'errorMaxOccupantsReached': 'No se puede unir a la sala "%s": demasiados participantes.',

        'antiSpamMessage': 'Por favor, no hagas spam. Has sido bloqueado temporalmente.'
	},

	'cn': {
		'status': '状态: %s',
		'statusConnecting': '连接中...',
		'statusConnected': '已连接',
		'statusDisconnecting': '断开连接中...',
		'statusDisconnected': '已断开连接',
		'statusAuthfail': '认证失败',

		'roomSubject': '主题:',
		'messageSubmit': '发送',

		'labelUsername': '用户名:',
		'labelPassword': '密码:',
		'loginSubmit': '登录',
		'loginInvalid': '用户名不合法',

		'reason': '原因:',
		'subject': '主题:',
		'reasonWas': '原因是: %s.',
		'kickActionLabel': '踢除',
		'youHaveBeenKickedBy': '你在 %1$s 被管理者 %2$s 请出房间',
		'banActionLabel': '禁言',
		'youHaveBeenBannedBy': '你在 %1$s 被管理者 %2$s 禁言',

		'privateActionLabel': '单独对话',
		'ignoreActionLabel': '忽略',
		'unignoreActionLabel': '不忽略',

		'setSubjectActionLabel': '变更主题',

		'administratorMessageSubject': '管理员',

		'userJoinedRoom': '%s 加入房间',
		'userLeftRoom': '%s 离开房间',
		'userHasBeenKickedFromRoom': '%s 被请出这个房间',
		'userHasBeenBannedFromRoom': '%s 被管理者禁言',

		'presenceUnknownWarningSubject': '注意:',
		'presenceUnknownWarning': '这个会员可能已经下线，不能追踪到他的连接信息',

		'dateFormat': 'dd.mm.yyyy',
		'timeFormat': 'HH:MM:ss',

		'tooltipRole': '管理',
		'tooltipIgnored': '你忽略了这个会员',
		'tooltipEmoticons': '表情',
		'tooltipSound': '新消息发音',
		'tooltipAutoscroll': '滚动条',
		'tooltipStatusmessage': '禁用状态消息',
		'tooltipAdministration': '房间管理',
		'tooltipUsercount': '房间占有者',

		'enterRoomPassword': '登录房间 "%s" 需要密码.',
		'enterRoomPasswordSubmit': '加入房间',
		'passwordEnteredInvalid': '登录房间 "%s" 的密码不正确',

		'nicknameConflict': '用户名已经存在，请另选一个',

		'errorMembersOnly': '您的权限不够，不能登录房间 "%s" ',
		'errorMaxOccupantsReached': '房间 "%s" 的人数已达上限，您不能登录',

		'antiSpamMessage': '因为您在短时间内发送过多的消息 服务器要阻止您一小段时间。'
	},
	
    'ja': {
        'status': 'ステータス: %s',
        'statusConnecting': '接続中…',
        'statusConnected': '接続されました',
        'statusDisconnecting': 'ディスコネクト中…',
        'statusDisconnected': 'ディスコネクトされました',
        'statusAuthfail': '認証に失敗しました',

        'roomSubject': 'トピック：',
        'messageSubmit': '送信',

        'labelUsername': 'ユーザーネーム：',
        'labelPassword': 'パスワード：',
        'loginSubmit': 'ログイン',
        'loginInvalid': 'ユーザーネームが正しくありません',

        'reason': '理由：',
        'subject': 'トピック：',
        'reasonWas': '理由: %s。',
        'kickActionLabel': 'キック',
        'youHaveBeenKickedBy': 'あなたは%2$sにより%1$sからキックされました。',
        'youHaveBeenKicked': 'あなたは%sからキックされました。',
        'banActionLabel': 'アカウントバン',
        'youHaveBeenBannedBy': 'あなたは%2$sにより%1$sからアカウントバンされました。',
        'youHaveBeenBanned': 'あなたは%sからアカウントバンされました。',

        'privateActionLabel': 'プライベートメッセージ',
        'ignoreActionLabel': '無視する',
        'unignoreActionLabel': '無視をやめる',

        'setSubjectActionLabel': 'トピックを変える',

        'administratorMessageSubject': '管理者',

        'userJoinedRoom': '%sは入室しました。',
        'userLeftRoom': '%sは退室しました。',
        'userHasBeenKickedFromRoom': '%sは部屋からキックされました。',
        'userHasBeenBannedFromRoom': '%sは部屋からアカウントバンされました。',

        'presenceUnknownWarningSubject': '忠告：',
        'presenceUnknownWarning': 'このユーザーのステータスは不明です。',

        'dateFormat': 'dd.mm.yyyy',
        'timeFormat': 'HH:MM:ss',

        'tooltipRole': 'モデレーター',
        'tooltipIgnored': 'このユーザーを無視設定にしている',
        'tooltipEmoticons': '絵文字',
        'tooltipSound': '新しいメッセージが届くたびに音を鳴らす',
        'tooltipAutoscroll': 'オートスクロール',
        'tooltipStatusmessage': 'ステータスメッセージを表示',
        'tooltipAdministration': '部屋の管理',
        'tooltipUsercount': 'この部屋の参加者の数',

        'enterRoomPassword': '"%s"の部屋に入るにはパスワードが必要です。',
        'enterRoomPasswordSubmit': '部屋に入る',
        'passwordEnteredInvalid': '"%s"のパスワードと異なるパスワードを入力しました。',

        'nicknameConflict': 'このユーザーネームはすでに利用されているため、別のユーザーネームを選んでください。',

        'errorMembersOnly': '"%s"の部屋に入ることができません: 利用権限を満たしていません。',
        'errorMaxOccupantsReached': '"%s"の部屋に入ることができません: 参加者の数はすでに上限に達しました。',

        'antiSpamMessage': 'スパムなどの行為はやめてください。あなたは一時的にブロックされました。'
	}
};
/**
 * BxSlider v4.1.1 - Fully loaded, responsive content slider
 * http://bxslider.com
 *
 * Copyright 2013, Steven Wanderski - http://stevenwanderski.com - http://bxcreative.com
 * Written while drinking Belgian ales and listening to jazz
 *
 * Released under the MIT license - http://opensource.org/licenses/MIT
 */
!function(t){var e={},s={mode:"horizontal",slideSelector:"",infiniteLoop:!0,hideControlOnEnd:!1,speed:500,easing:null,slideMargin:0,startSlide:0,randomStart:!1,captions:!1,ticker:!1,tickerHover:!1,adaptiveHeight:!1,adaptiveHeightSpeed:500,video:!1,useCSS:!0,preloadImages:"visible",responsive:!0,touchEnabled:!0,swipeThreshold:50,oneToOneTouch:!0,preventDefaultSwipeX:!0,preventDefaultSwipeY:!1,pager:!0,pagerType:"full",pagerShortSeparator:" / ",pagerSelector:null,buildPager:null,pagerCustom:null,controls:!0,nextText:"Next",prevText:"Prev",nextSelector:null,prevSelector:null,autoControls:!1,startText:"Start",stopText:"Stop",autoControlsCombine:!1,autoControlsSelector:null,auto:!1,pause:4e3,autoStart:!0,autoDirection:"next",autoHover:!1,autoDelay:0,minSlides:1,maxSlides:1,moveSlides:0,slideWidth:0,onSliderLoad:function(){},onSlideBefore:function(){},onSlideAfter:function(){},onSlideNext:function(){},onSlidePrev:function(){}};t.fn.bxSlider=function(n){if(0==this.length)return this;if(this.length>1)return this.each(function(){t(this).bxSlider(n)}),this;var o={},r=this;e.el=this;var a=t(window).width(),l=t(window).height(),d=function(){o.settings=t.extend({},s,n),o.settings.slideWidth=parseInt(o.settings.slideWidth),o.children=r.children(o.settings.slideSelector),o.children.length<o.settings.minSlides&&(o.settings.minSlides=o.children.length),o.children.length<o.settings.maxSlides&&(o.settings.maxSlides=o.children.length),o.settings.randomStart&&(o.settings.startSlide=Math.floor(Math.random()*o.children.length)),o.active={index:o.settings.startSlide},o.carousel=o.settings.minSlides>1||o.settings.maxSlides>1,o.carousel&&(o.settings.preloadImages="all"),o.minThreshold=o.settings.minSlides*o.settings.slideWidth+(o.settings.minSlides-1)*o.settings.slideMargin,o.maxThreshold=o.settings.maxSlides*o.settings.slideWidth+(o.settings.maxSlides-1)*o.settings.slideMargin,o.working=!1,o.controls={},o.interval=null,o.animProp="vertical"==o.settings.mode?"top":"left",o.usingCSS=o.settings.useCSS&&"fade"!=o.settings.mode&&function(){var t=document.createElement("div"),e=["WebkitPerspective","MozPerspective","OPerspective","msPerspective"];for(var i in e)if(void 0!==t.style[e[i]])return o.cssPrefix=e[i].replace("Perspective","").toLowerCase(),o.animProp="-"+o.cssPrefix+"-transform",!0;return!1}(),"vertical"==o.settings.mode&&(o.settings.maxSlides=o.settings.minSlides),r.data("origStyle",r.attr("style")),r.children(o.settings.slideSelector).each(function(){t(this).data("origStyle",t(this).attr("style"))}),c()},c=function(){r.wrap('<div class="bx-wrapper"><div class="bx-viewport"></div></div>'),o.viewport=r.parent(),o.loader=t('<div class="bx-loading" />'),o.viewport.prepend(o.loader),r.css({width:"horizontal"==o.settings.mode?100*o.children.length+215+"%":"auto",position:"relative"}),o.usingCSS&&o.settings.easing?r.css("-"+o.cssPrefix+"-transition-timing-function",o.settings.easing):o.settings.easing||(o.settings.easing="swing"),f(),o.viewport.css({width:"100%",overflow:"hidden",position:"relative"}),o.viewport.parent().css({maxWidth:v()}),o.settings.pager||o.viewport.parent().css({margin:"0 auto 0px"}),o.children.css({"float":"horizontal"==o.settings.mode?"left":"none",listStyle:"none",position:"relative"}),o.children.css("width",u()),"horizontal"==o.settings.mode&&o.settings.slideMargin>0&&o.children.css("marginRight",o.settings.slideMargin),"vertical"==o.settings.mode&&o.settings.slideMargin>0&&o.children.css("marginBottom",o.settings.slideMargin),"fade"==o.settings.mode&&(o.children.css({position:"absolute",zIndex:0,display:"none"}),o.children.eq(o.settings.startSlide).css({zIndex:50,display:"block"})),o.controls.el=t('<div class="bx-controls" />'),o.settings.captions&&P(),o.active.last=o.settings.startSlide==x()-1,o.settings.video&&r.fitVids();var e=o.children.eq(o.settings.startSlide);"all"==o.settings.preloadImages&&(e=o.children),o.settings.ticker?o.settings.pager=!1:(o.settings.pager&&T(),o.settings.controls&&C(),o.settings.auto&&o.settings.autoControls&&E(),(o.settings.controls||o.settings.autoControls||o.settings.pager)&&o.viewport.after(o.controls.el)),g(e,h)},g=function(e,i){var s=e.find("img, iframe").length;if(0==s)return i(),void 0;var n=0;e.find("img, iframe").each(function(){t(this).one("load",function(){++n==s&&i()}).each(function(){this.complete&&t(this).load()})})},h=function(){if(o.settings.infiniteLoop&&"fade"!=o.settings.mode&&!o.settings.ticker){var e="vertical"==o.settings.mode?o.settings.minSlides:o.settings.maxSlides,i=o.children.slice(0,e).clone().addClass("bx-clone"),s=o.children.slice(-e).clone().addClass("bx-clone");r.append(i).prepend(s)}o.loader.remove(),S(),"vertical"==o.settings.mode&&(o.settings.adaptiveHeight=!0),o.viewport.height(p()),r.redrawSlider(),o.settings.onSliderLoad(o.active.index),o.initialized=!0,o.settings.responsive&&t(window).bind("resize",B),o.settings.auto&&o.settings.autoStart&&H(),o.settings.ticker&&L(),o.settings.pager&&I(o.settings.startSlide),o.settings.controls&&W(),o.settings.touchEnabled&&!o.settings.ticker&&O()},p=function(){var e=0,s=t();if("vertical"==o.settings.mode||o.settings.adaptiveHeight)if(o.carousel){var n=1==o.settings.moveSlides?o.active.index:o.active.index*m();for(s=o.children.eq(n),i=1;i<=o.settings.maxSlides-1;i++)s=n+i>=o.children.length?s.add(o.children.eq(i-1)):s.add(o.children.eq(n+i))}else s=o.children.eq(o.active.index);else s=o.children;return"vertical"==o.settings.mode?(s.each(function(){e+=t(this).outerHeight()}),o.settings.slideMargin>0&&(e+=o.settings.slideMargin*(o.settings.minSlides-1))):e=Math.max.apply(Math,s.map(function(){return t(this).outerHeight(!1)}).get()),e},v=function(){var t="100%";return o.settings.slideWidth>0&&(t="horizontal"==o.settings.mode?o.settings.maxSlides*o.settings.slideWidth+(o.settings.maxSlides-1)*o.settings.slideMargin:o.settings.slideWidth),t},u=function(){var t=o.settings.slideWidth,e=o.viewport.width();return 0==o.settings.slideWidth||o.settings.slideWidth>e&&!o.carousel||"vertical"==o.settings.mode?t=e:o.settings.maxSlides>1&&"horizontal"==o.settings.mode&&(e>o.maxThreshold||e<o.minThreshold&&(t=(e-o.settings.slideMargin*(o.settings.minSlides-1))/o.settings.minSlides)),t},f=function(){var t=1;if("horizontal"==o.settings.mode&&o.settings.slideWidth>0)if(o.viewport.width()<o.minThreshold)t=o.settings.minSlides;else if(o.viewport.width()>o.maxThreshold)t=o.settings.maxSlides;else{var e=o.children.first().width();t=Math.floor(o.viewport.width()/e)}else"vertical"==o.settings.mode&&(t=o.settings.minSlides);return t},x=function(){var t=0;if(o.settings.moveSlides>0)if(o.settings.infiniteLoop)t=o.children.length/m();else for(var e=0,i=0;e<o.children.length;)++t,e=i+f(),i+=o.settings.moveSlides<=f()?o.settings.moveSlides:f();else t=Math.ceil(o.children.length/f());return t},m=function(){return o.settings.moveSlides>0&&o.settings.moveSlides<=f()?o.settings.moveSlides:f()},S=function(){if(o.children.length>o.settings.maxSlides&&o.active.last&&!o.settings.infiniteLoop){if("horizontal"==o.settings.mode){var t=o.children.last(),e=t.position();b(-(e.left-(o.viewport.width()-t.width())),"reset",0)}else if("vertical"==o.settings.mode){var i=o.children.length-o.settings.minSlides,e=o.children.eq(i).position();b(-e.top,"reset",0)}}else{var e=o.children.eq(o.active.index*m()).position();o.active.index==x()-1&&(o.active.last=!0),void 0!=e&&("horizontal"==o.settings.mode?b(-e.left,"reset",0):"vertical"==o.settings.mode&&b(-e.top,"reset",0))}},b=function(t,e,i,s){if(o.usingCSS){var n="vertical"==o.settings.mode?"translate3d(0, "+t+"px, 0)":"translate3d("+t+"px, 0, 0)";r.css("-"+o.cssPrefix+"-transition-duration",i/1e3+"s"),"slide"==e?(r.css(o.animProp,n),r.bind("transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd",function(){r.unbind("transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd"),D()})):"reset"==e?r.css(o.animProp,n):"ticker"==e&&(r.css("-"+o.cssPrefix+"-transition-timing-function","linear"),r.css(o.animProp,n),r.bind("transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd",function(){r.unbind("transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd"),b(s.resetValue,"reset",0),N()}))}else{var a={};a[o.animProp]=t,"slide"==e?r.animate(a,i,o.settings.easing,function(){D()}):"reset"==e?r.css(o.animProp,t):"ticker"==e&&r.animate(a,speed,"linear",function(){b(s.resetValue,"reset",0),N()})}},w=function(){for(var e="",i=x(),s=0;i>s;s++){var n="";o.settings.buildPager&&t.isFunction(o.settings.buildPager)?(n=o.settings.buildPager(s),o.pagerEl.addClass("bx-custom-pager")):(n=s+1,o.pagerEl.addClass("bx-default-pager")),e+='<div class="bx-pager-item"><a href="" data-slide-index="'+s+'" class="bx-pager-link">'+n+"</a></div>"}o.pagerEl.html(e)},T=function(){o.settings.pagerCustom?o.pagerEl=t(o.settings.pagerCustom):(o.pagerEl=t('<div class="bx-pager" />'),o.settings.pagerSelector?t(o.settings.pagerSelector).html(o.pagerEl):o.controls.el.addClass("bx-has-pager").append(o.pagerEl),w()),o.pagerEl.delegate("a","click",q)},C=function(){o.controls.next=t('<a class="bx-next" href="">'+o.settings.nextText+"</a>"),o.controls.prev=t('<a class="bx-prev" href="">'+o.settings.prevText+"</a>"),o.controls.next.bind("click",y),o.controls.prev.bind("click",z),o.settings.nextSelector&&t(o.settings.nextSelector).append(o.controls.next),o.settings.prevSelector&&t(o.settings.prevSelector).append(o.controls.prev),o.settings.nextSelector||o.settings.prevSelector||(o.controls.directionEl=t('<div class="bx-controls-direction" />'),o.controls.directionEl.append(o.controls.prev).append(o.controls.next),o.controls.el.addClass("bx-has-controls-direction").append(o.controls.directionEl))},E=function(){o.controls.start=t('<div class="bx-controls-auto-item"><a class="bx-start" href="">'+o.settings.startText+"</a></div>"),o.controls.stop=t('<div class="bx-controls-auto-item"><a class="bx-stop" href="">'+o.settings.stopText+"</a></div>"),o.controls.autoEl=t('<div class="bx-controls-auto" />'),o.controls.autoEl.delegate(".bx-start","click",k),o.controls.autoEl.delegate(".bx-stop","click",M),o.settings.autoControlsCombine?o.controls.autoEl.append(o.controls.start):o.controls.autoEl.append(o.controls.start).append(o.controls.stop),o.settings.autoControlsSelector?t(o.settings.autoControlsSelector).html(o.controls.autoEl):o.controls.el.addClass("bx-has-controls-auto").append(o.controls.autoEl),A(o.settings.autoStart?"stop":"start")},P=function(){o.children.each(function(){var e=t(this).find("img:first").attr("title");void 0!=e&&(""+e).length&&t(this).append('<div class="bx-caption"><span>'+e+"</span></div>")})},y=function(t){o.settings.auto&&r.stopAuto(),r.goToNextSlide(),t.preventDefault()},z=function(t){o.settings.auto&&r.stopAuto(),r.goToPrevSlide(),t.preventDefault()},k=function(t){r.startAuto(),t.preventDefault()},M=function(t){r.stopAuto(),t.preventDefault()},q=function(e){o.settings.auto&&r.stopAuto();var i=t(e.currentTarget),s=parseInt(i.attr("data-slide-index"));s!=o.active.index&&r.goToSlide(s),e.preventDefault()},I=function(e){var i=o.children.length;return"short"==o.settings.pagerType?(o.settings.maxSlides>1&&(i=Math.ceil(o.children.length/o.settings.maxSlides)),o.pagerEl.html(e+1+o.settings.pagerShortSeparator+i),void 0):(o.pagerEl.find("a").removeClass("active"),o.pagerEl.each(function(i,s){t(s).find("a").eq(e).addClass("active")}),void 0)},D=function(){if(o.settings.infiniteLoop){var t="";0==o.active.index?t=o.children.eq(0).position():o.active.index==x()-1&&o.carousel?t=o.children.eq((x()-1)*m()).position():o.active.index==o.children.length-1&&(t=o.children.eq(o.children.length-1).position()),"horizontal"==o.settings.mode?b(-t.left,"reset",0):"vertical"==o.settings.mode&&b(-t.top,"reset",0)}o.working=!1,o.settings.onSlideAfter(o.children.eq(o.active.index),o.oldIndex,o.active.index)},A=function(t){o.settings.autoControlsCombine?o.controls.autoEl.html(o.controls[t]):(o.controls.autoEl.find("a").removeClass("active"),o.controls.autoEl.find("a:not(.bx-"+t+")").addClass("active"))},W=function(){1==x()?(o.controls.prev.addClass("disabled"),o.controls.next.addClass("disabled")):!o.settings.infiniteLoop&&o.settings.hideControlOnEnd&&(0==o.active.index?(o.controls.prev.addClass("disabled"),o.controls.next.removeClass("disabled")):o.active.index==x()-1?(o.controls.next.addClass("disabled"),o.controls.prev.removeClass("disabled")):(o.controls.prev.removeClass("disabled"),o.controls.next.removeClass("disabled")))},H=function(){o.settings.autoDelay>0?setTimeout(r.startAuto,o.settings.autoDelay):r.startAuto(),o.settings.autoHover&&r.hover(function(){o.interval&&(r.stopAuto(!0),o.autoPaused=!0)},function(){o.autoPaused&&(r.startAuto(!0),o.autoPaused=null)})},L=function(){var e=0;if("next"==o.settings.autoDirection)r.append(o.children.clone().addClass("bx-clone"));else{r.prepend(o.children.clone().addClass("bx-clone"));var i=o.children.first().position();e="horizontal"==o.settings.mode?-i.left:-i.top}b(e,"reset",0),o.settings.pager=!1,o.settings.controls=!1,o.settings.autoControls=!1,o.settings.tickerHover&&!o.usingCSS&&o.viewport.hover(function(){r.stop()},function(){var e=0;o.children.each(function(){e+="horizontal"==o.settings.mode?t(this).outerWidth(!0):t(this).outerHeight(!0)});var i=o.settings.speed/e,s="horizontal"==o.settings.mode?"left":"top",n=i*(e-Math.abs(parseInt(r.css(s))));N(n)}),N()},N=function(t){speed=t?t:o.settings.speed;var e={left:0,top:0},i={left:0,top:0};"next"==o.settings.autoDirection?e=r.find(".bx-clone").first().position():i=o.children.first().position();var s="horizontal"==o.settings.mode?-e.left:-e.top,n="horizontal"==o.settings.mode?-i.left:-i.top,a={resetValue:n};b(s,"ticker",speed,a)},O=function(){o.touch={start:{x:0,y:0},end:{x:0,y:0}},o.viewport.bind("touchstart",X)},X=function(t){if(o.working)t.preventDefault();else{o.touch.originalPos=r.position();var e=t.originalEvent;o.touch.start.x=e.changedTouches[0].pageX,o.touch.start.y=e.changedTouches[0].pageY,o.viewport.bind("touchmove",Y),o.viewport.bind("touchend",V)}},Y=function(t){var e=t.originalEvent,i=Math.abs(e.changedTouches[0].pageX-o.touch.start.x),s=Math.abs(e.changedTouches[0].pageY-o.touch.start.y);if(3*i>s&&o.settings.preventDefaultSwipeX?t.preventDefault():3*s>i&&o.settings.preventDefaultSwipeY&&t.preventDefault(),"fade"!=o.settings.mode&&o.settings.oneToOneTouch){var n=0;if("horizontal"==o.settings.mode){var r=e.changedTouches[0].pageX-o.touch.start.x;n=o.touch.originalPos.left+r}else{var r=e.changedTouches[0].pageY-o.touch.start.y;n=o.touch.originalPos.top+r}b(n,"reset",0)}},V=function(t){o.viewport.unbind("touchmove",Y);var e=t.originalEvent,i=0;if(o.touch.end.x=e.changedTouches[0].pageX,o.touch.end.y=e.changedTouches[0].pageY,"fade"==o.settings.mode){var s=Math.abs(o.touch.start.x-o.touch.end.x);s>=o.settings.swipeThreshold&&(o.touch.start.x>o.touch.end.x?r.goToNextSlide():r.goToPrevSlide(),r.stopAuto())}else{var s=0;"horizontal"==o.settings.mode?(s=o.touch.end.x-o.touch.start.x,i=o.touch.originalPos.left):(s=o.touch.end.y-o.touch.start.y,i=o.touch.originalPos.top),!o.settings.infiniteLoop&&(0==o.active.index&&s>0||o.active.last&&0>s)?b(i,"reset",200):Math.abs(s)>=o.settings.swipeThreshold?(0>s?r.goToNextSlide():r.goToPrevSlide(),r.stopAuto()):b(i,"reset",200)}o.viewport.unbind("touchend",V)},B=function(){var e=t(window).width(),i=t(window).height();(a!=e||l!=i)&&(a=e,l=i,r.redrawSlider())};return r.goToSlide=function(e,i){if(!o.working&&o.active.index!=e)if(o.working=!0,o.oldIndex=o.active.index,o.active.index=0>e?x()-1:e>=x()?0:e,o.settings.onSlideBefore(o.children.eq(o.active.index),o.oldIndex,o.active.index),"next"==i?o.settings.onSlideNext(o.children.eq(o.active.index),o.oldIndex,o.active.index):"prev"==i&&o.settings.onSlidePrev(o.children.eq(o.active.index),o.oldIndex,o.active.index),o.active.last=o.active.index>=x()-1,o.settings.pager&&I(o.active.index),o.settings.controls&&W(),"fade"==o.settings.mode)o.settings.adaptiveHeight&&o.viewport.height()!=p()&&o.viewport.animate({height:p()},o.settings.adaptiveHeightSpeed),o.children.filter(":visible").fadeOut(o.settings.speed).css({zIndex:0}),o.children.eq(o.active.index).css("zIndex",51).fadeIn(o.settings.speed,function(){t(this).css("zIndex",50),D()});else{o.settings.adaptiveHeight&&o.viewport.height()!=p()&&o.viewport.animate({height:p()},o.settings.adaptiveHeightSpeed);var s=0,n={left:0,top:0};if(!o.settings.infiniteLoop&&o.carousel&&o.active.last)if("horizontal"==o.settings.mode){var a=o.children.eq(o.children.length-1);n=a.position(),s=o.viewport.width()-a.outerWidth()}else{var l=o.children.length-o.settings.minSlides;n=o.children.eq(l).position()}else if(o.carousel&&o.active.last&&"prev"==i){var d=1==o.settings.moveSlides?o.settings.maxSlides-m():(x()-1)*m()-(o.children.length-o.settings.maxSlides),a=r.children(".bx-clone").eq(d);n=a.position()}else if("next"==i&&0==o.active.index)n=r.find("> .bx-clone").eq(o.settings.maxSlides).position(),o.active.last=!1;else if(e>=0){var c=e*m();n=o.children.eq(c).position()}if("undefined"!=typeof n){var g="horizontal"==o.settings.mode?-(n.left-s):-n.top;b(g,"slide",o.settings.speed)}}},r.goToNextSlide=function(){if(o.settings.infiniteLoop||!o.active.last){var t=parseInt(o.active.index)+1;r.goToSlide(t,"next")}},r.goToPrevSlide=function(){if(o.settings.infiniteLoop||0!=o.active.index){var t=parseInt(o.active.index)-1;r.goToSlide(t,"prev")}},r.startAuto=function(t){o.interval||(o.interval=setInterval(function(){"next"==o.settings.autoDirection?r.goToNextSlide():r.goToPrevSlide()},o.settings.pause),o.settings.autoControls&&1!=t&&A("stop"))},r.stopAuto=function(t){o.interval&&(clearInterval(o.interval),o.interval=null,o.settings.autoControls&&1!=t&&A("start"))},r.getCurrentSlide=function(){return o.active.index},r.getSlideCount=function(){return o.children.length},r.redrawSlider=function(){o.children.add(r.find(".bx-clone")).outerWidth(u()),o.viewport.css("height",p()),o.settings.ticker||S(),o.active.last&&(o.active.index=x()-1),o.active.index>=x()&&(o.active.last=!0),o.settings.pager&&!o.settings.pagerCustom&&(w(),I(o.active.index))},r.destroySlider=function(){o.initialized&&(o.initialized=!1,t(".bx-clone",this).remove(),o.children.each(function(){void 0!=t(this).data("origStyle")?t(this).attr("style",t(this).data("origStyle")):t(this).removeAttr("style")}),void 0!=t(this).data("origStyle")?this.attr("style",t(this).data("origStyle")):t(this).removeAttr("style"),t(this).unwrap().unwrap(),o.controls.el&&o.controls.el.remove(),o.controls.next&&o.controls.next.remove(),o.controls.prev&&o.controls.prev.remove(),o.pagerEl&&o.pagerEl.remove(),t(".bx-caption",this).remove(),o.controls.autoEl&&o.controls.autoEl.remove(),clearInterval(o.interval),o.settings.responsive&&t(window).unbind("resize",B))},r.reloadSlider=function(t){void 0!=t&&(n=t),r.destroySlider(),d()},d(),this}}(jQuery);
/*!
	Colorbox v1.4.33 - 2013-10-31
	jQuery lightbox and modal window plugin
	(c) 2013 Jack Moore - http://www.jacklmoore.com/colorbox
	license: http://www.opensource.org/licenses/mit-license.php
*/
(function ($, document, window) {
	var
	// Default settings object.
	// See http://jacklmoore.com/colorbox for details.
	defaults = {
		// data sources
		html: false,
		photo: false,
		iframe: false,
		inline: false,

		// behavior and appearance
		transition: "elastic",
		speed: 300,
		fadeOut: 300,
		width: false,
		initialWidth: "600",
		innerWidth: false,
		maxWidth: false,
		height: false,
		initialHeight: "450",
		innerHeight: false,
		maxHeight: false,
		scalePhotos: true,
		scrolling: true,
		href: false,
		title: false,
		rel: false,
		opacity: 0.9,
		preloading: true,
		className: false,
		overlayClose: true,
		escKey: true,
		arrowKey: true,
		top: false,
		bottom: false,
		left: false,
		right: false,
		fixed: false,
		data: undefined,
		closeButton: true,
		fastIframe: true,
		open: false,
		reposition: true,
		loop: true,
		slideshow: false,
		slideshowAuto: true,
		slideshowSpeed: 2500,
		slideshowStart: "start slideshow",
		slideshowStop: "stop slideshow",
		photoRegex: /\.(gif|png|jp(e|g|eg)|bmp|ico|webp)((#|\?).*)?$/i,
        scrollTop: false,

		// alternate image paths for high-res displays
		retinaImage: false,
		retinaUrl: false,
		retinaSuffix: '@2x.$1',

		// internationalization
		current: "image {current} of {total}",
		previous: "previous",
		next: "next",
		close: "close",
		xhrError: "This content failed to load.",
		imgError: "This image failed to load.",

		// accessbility
		returnFocus: true,
		trapFocus: true,

		// callbacks
		onOpen: false,
		onLoad: false,
		onComplete: false,
		onCleanup: false,
		onClosed: false
	},
	
	// Abstracting the HTML and event identifiers for easy rebranding
	colorbox = 'colorbox',
	prefix = 'cbox',
	boxElement = prefix + 'Element',
	
	// Events
	event_open = prefix + '_open',
	event_load = prefix + '_load',
	event_complete = prefix + '_complete',
	event_cleanup = prefix + '_cleanup',
	event_closed = prefix + '_closed',
	event_purge = prefix + '_purge',

	// Cached jQuery Object Variables
	$overlay,
	$box,
	$wrap,
	$content,
	$topBorder,
	$leftBorder,
	$rightBorder,
	$bottomBorder,
	$related,
	$window,
	$loaded,
	$loadingBay,
	$loadingOverlay,
	$title,
	$current,
	$slideshow,
	$next,
	$prev,
	$close,
	$groupControls,
	$events = $('<a/>'), // $([]) would be prefered, but there is an issue with jQuery 1.4.2
	
	// Variables for cached values or use across multiple functions
	settings,
	interfaceHeight,
	interfaceWidth,
	loadedHeight,
	loadedWidth,
	element,
	index,
	photo,
	open,
	active,
	closing,
	loadingTimer,
	publicMethod,
	div = "div",
	className,
	requests = 0,
	previousCSS = {},
	init;

	// ****************
	// HELPER FUNCTIONS
	// ****************
	
	// Convenience function for creating new jQuery objects
	function $tag(tag, id, css) {
		var element = document.createElement(tag);

		if (id) {
			element.id = prefix + id;
		}

		if (css) {
			element.style.cssText = css;
		}

		return $(element);
	}
	
	// Get the window height using innerHeight when available to avoid an issue with iOS
	// http://bugs.jquery.com/ticket/6724
	function winheight() {
		return window.innerHeight ? window.innerHeight : $(window).height();
	}

	// Determine the next and previous members in a group.
	function getIndex(increment) {
		var
		max = $related.length,
		newIndex = (index + increment) % max;
		
		return (newIndex < 0) ? max + newIndex : newIndex;
	}

	// Convert '%' and 'px' values to integers
	function setSize(size, dimension) {
		return Math.round((/%/.test(size) ? ((dimension === 'x' ? $window.width() : winheight()) / 100) : 1) * parseInt(size, 10));
	}
	
	// Checks an href to see if it is a photo.
	// There is a force photo option (photo: true) for hrefs that cannot be matched by the regex.
	function isImage(settings, url) {
		return settings.photo || settings.photoRegex.test(url);
	}

	function retinaUrl(settings, url) {
		return settings.retinaUrl && window.devicePixelRatio > 1 ? url.replace(settings.photoRegex, settings.retinaSuffix) : url;
	}

	function trapFocus(e) {
		if ('contains' in $box[0] && !$box[0].contains(e.target)) {
			e.stopPropagation();
			$box.focus();
		}
	}

	// Assigns function results to their respective properties
	function makeSettings() {
		var i,
			data = $.data(element, colorbox);
		
		if (data == null) {
			settings = $.extend({}, defaults);
			if (console && console.log) {
				console.log('Error: cboxElement missing settings object');
			}
		} else {
			settings = $.extend({}, data);
		}
		
		for (i in settings) {
			if ($.isFunction(settings[i]) && i.slice(0, 2) !== 'on') { // checks to make sure the function isn't one of the callbacks, they will be handled at the appropriate time.
				settings[i] = settings[i].call(element);
			}
		}
		
		settings.rel = settings.rel || element.rel || $(element).data('rel') || 'nofollow';
		settings.href = settings.href || $(element).attr('href');
		settings.title = settings.title || element.title;
		
		if (typeof settings.href === "string") {
			settings.href = $.trim(settings.href);
		}
	}

	function trigger(event, callback) {
		// for external use
		$(document).trigger(event);

		// for internal use
		$events.triggerHandler(event);

		if ($.isFunction(callback)) {
			callback.call(element);
		}
	}


	var slideshow = (function(){
		var active,
			className = prefix + "Slideshow_",
			click = "click." + prefix,
			timeOut;

		function clear () {
			clearTimeout(timeOut);
		}

		function set() {
			if (settings.loop || $related[index + 1]) {
				clear();
				timeOut = setTimeout(publicMethod.next, settings.slideshowSpeed);
			}
		}

		function start() {
			$slideshow
				.html(settings.slideshowStop)
				.unbind(click)
				.one(click, stop);

			$events
				.bind(event_complete, set)
				.bind(event_load, clear);

			$box.removeClass(className + "off").addClass(className + "on");
		}

		function stop() {
			clear();
			
			$events
				.unbind(event_complete, set)
				.unbind(event_load, clear);

			$slideshow
				.html(settings.slideshowStart)
				.unbind(click)
				.one(click, function () {
					publicMethod.next();
					start();
				});

			$box.removeClass(className + "on").addClass(className + "off");
		}

		function reset() {
			active = false;
			$slideshow.hide();
			clear();
			$events
				.unbind(event_complete, set)
				.unbind(event_load, clear);
			$box.removeClass(className + "off " + className + "on");
		}

		return function(){
			if (active) {
				if (!settings.slideshow) {
					$events.unbind(event_cleanup, reset);
					reset();
				}
			} else {
				if (settings.slideshow && $related[1]) {
					active = true;
					$events.one(event_cleanup, reset);
					if (settings.slideshowAuto) {
						start();
					} else {
						stop();
					}
					$slideshow.show();
				}
			}
		};

	}());


	function launch(target) {
		if (!closing) {
			
			element = target;
			
			makeSettings();
			
			$related = $(element);
			
			index = 0;
			
			if (settings.rel !== 'nofollow') {
				$related = $('.' + boxElement).filter(function () {
					var data = $.data(this, colorbox),
						relRelated;

					if (data) {
						relRelated =  $(this).data('rel') || data.rel || this.rel;
					}
					
					return (relRelated === settings.rel);
				});
				index = $related.index(element);
				
				// Check direct calls to Colorbox.
				if (index === -1) {
					$related = $related.add(element);
					index = $related.length - 1;
				}
			}
			
			$overlay.css({
				opacity: parseFloat(settings.opacity),
				cursor: settings.overlayClose ? "pointer" : "auto",
				visibility: 'visible'
			}).show();
			

			if (className) {
				$box.add($overlay).removeClass(className);
			}
			if (settings.className) {
				$box.add($overlay).addClass(settings.className);
			}
			className = settings.className;

			if (settings.closeButton) {
				$close.html(settings.close).appendTo($content);
			} else {
				$close.appendTo('<div/>');
			}
			if (!open) {
				open = active = true; // Prevents the page-change action from queuing up if the visitor holds down the left or right keys.
				
				// Show colorbox so the sizes can be calculated in older versions of jQuery
				$box.css({visibility:'hidden', display:'block'});
				
				$loaded = $tag(div, 'LoadedContent', 'width:0; height:0; overflow:hidden');
				$content.css({width:'', height:''}).append($loaded);

				// Cache values needed for size calculations
				interfaceHeight = $topBorder.height() + $bottomBorder.height() + $content.outerHeight(true) - $content.height();
				interfaceWidth = $leftBorder.width() + $rightBorder.width() + $content.outerWidth(true) - $content.width();
				loadedHeight = $loaded.outerHeight(true);
				loadedWidth = $loaded.outerWidth(true);

				// Opens inital empty Colorbox prior to content being loaded.
				settings.w = setSize(settings.initialWidth, 'x');
				settings.h = setSize(settings.initialHeight, 'y');
				$loaded.css({width:'', height:settings.h});
				publicMethod.position();

				trigger(event_open, settings.onOpen);
				
				$groupControls.add($title).hide();

				$box.focus();
				
				if (settings.trapFocus) {
					// Confine focus to the modal
					// Uses event capturing that is not supported in IE8-
					if (document.addEventListener) {

						document.addEventListener('focus', trapFocus, true);
						
						$events.one(event_closed, function () {
							document.removeEventListener('focus', trapFocus, true);
						});
					}
				}

				// Return focus on closing
				if (settings.returnFocus) {
					$events.one(event_closed, function () {
						$(element).focus();
					});
				}
			}
			load();
		}
	}

	// Colorbox's markup needs to be added to the DOM prior to being called
	// so that the browser will go ahead and load the CSS background images.
	function appendHTML() {
		if (!$box && document.body) {
			init = false;
			$window = $(window);
			$box = $tag(div).attr({
				id: colorbox,
				'class': $.support.opacity === false ? prefix + 'IE' : '', // class for optional IE8 & lower targeted CSS.
				role: 'dialog',
				tabindex: '-1'
			}).hide();
			$overlay = $tag(div, "Overlay").hide();
			$loadingOverlay = $([$tag(div, "LoadingOverlay")[0],$tag(div, "LoadingGraphic")[0]]);
			$wrap = $tag(div, "Wrapper");
			$content = $tag(div, "Content").append(
				$title = $tag(div, "Title"),
				$current = $tag(div, "Current"),
				$prev = $('<button type="button"/>').attr({id:prefix+'Previous'}),
				$next = $('<button type="button"/>').attr({id:prefix+'Next'}),
				$slideshow = $tag('button', "Slideshow"),
				$loadingOverlay
			);

			$close = $('<button type="button" class="popup"/>').attr({id:prefix+'Close'});
			
			$wrap.append( // The 3x3 Grid that makes up Colorbox
				$tag(div).append(
					$tag(div, "TopLeft"),
					$topBorder = $tag(div, "TopCenter"),
					$tag(div, "TopRight")
				),
				$tag(div, false, 'clear:left').append(
					$leftBorder = $tag(div, "MiddleLeft"),
					$content,
					$rightBorder = $tag(div, "MiddleRight")
				),
				$tag(div, false, 'clear:left').append(
					$tag(div, "BottomLeft"),
					$bottomBorder = $tag(div, "BottomCenter"),
					$tag(div, "BottomRight")
				)
			).find('div div').css({'float': 'left'});
			
			$loadingBay = $tag(div, false, 'position:absolute; width:9999px; visibility:hidden; display:none; max-width:none;');
			
			$groupControls = $next.add($prev).add($current).add($slideshow);

			$(document.body).append($overlay, $box.append($wrap, $loadingBay));
		}
	}

	// Add Colorbox's event bindings
	function addBindings() {
		function clickHandler(e) {
			// ignore non-left-mouse-clicks and clicks modified with ctrl / command, shift, or alt.
			// See: http://jacklmoore.com/notes/click-events/
			if (!(e.which > 1 || e.shiftKey || e.altKey || e.metaKey || e.ctrlKey)) {
				e.preventDefault();
				launch(this);
			}
		}

		if ($box) {
			if (!init) {
				init = true;

				// Anonymous functions here keep the public method from being cached, thereby allowing them to be redefined on the fly.
				$next.click(function () {
					publicMethod.next();
				});
				$prev.click(function () {
					publicMethod.prev();
				});
				$close.click(function () {
					publicMethod.close();
				});
				$overlay.click(function () {
					if (settings.overlayClose) {
						publicMethod.close();
					}
				});
				
				// Key Bindings
				$(document).bind('keydown.' + prefix, function (e) {
					var key = e.keyCode;
					if (open && settings.escKey && key === 27) {
						e.preventDefault();
						publicMethod.close();
					}
					if (open && settings.arrowKey && $related[1] && !e.altKey) {
						if (key === 37) {
							e.preventDefault();
							$prev.click();
						} else if (key === 39) {
							e.preventDefault();
							$next.click();
						}
					}
				});

				if ($.isFunction($.fn.on)) {
					// For jQuery 1.7+
					$(document).on('click.'+prefix, '.'+boxElement, clickHandler);
				} else {
					// For jQuery 1.3.x -> 1.6.x
					// This code is never reached in jQuery 1.9, so do not contact me about 'live' being removed.
					// This is not here for jQuery 1.9, it's here for legacy users.
					$('.'+boxElement).live('click.'+prefix, clickHandler);
				}
			}
			return true;
		}
		return false;
	}

	// Don't do anything if Colorbox already exists.
	if ($.colorbox) {
		return;
	}

	// Append the HTML when the DOM loads
	$(appendHTML);


	// ****************
	// PUBLIC FUNCTIONS
	// Usage format: $.colorbox.close();
	// Usage from within an iframe: parent.jQuery.colorbox.close();
	// ****************
	
	publicMethod = $.fn[colorbox] = $[colorbox] = function (options, callback) {
		var $this = this;
		
		options = options || {};
		
		appendHTML();
		if (addBindings()) {
			if ($.isFunction($this)) { // assume a call to $.colorbox
			    $this = $('<a/>');
				options.open = true;
			} else if (!$this[0]) { // colorbox being applied to empty collection
				return $this;
			}
			
			if (callback) {
				options.onComplete = callback;
			}
			
			$this.each(function () {
				$.data(this, colorbox, $.extend({}, $.data(this, colorbox) || defaults, options));
			}).addClass(boxElement);
			
			if (($.isFunction(options.open) && options.open.call($this)) || options.open) {
				launch($this[0]);
			}
		}
		
		return $this;
	};

	publicMethod.position = function (speed, loadedCallback) {
		var
		css,
		top = 0,
		left = 0,
		offset = $box.offset(),
		scrollTop,
		scrollLeft;
		
		$window.unbind('resize.' + prefix);

		// remove the modal so that it doesn't influence the document width/height
		$box.css({top: -9e4, left: -9e4});

		scrollTop = $window.scrollTop();
		scrollLeft = $window.scrollLeft();

		if (settings.fixed) {
			offset.top -= scrollTop;
			offset.left -= scrollLeft;
			$box.css({position: 'fixed'});
		} else {
			top = scrollTop;
			left = scrollLeft;
			$box.css({position: 'absolute'});
		}

		// keeps the top and left positions within the browser's viewport.
		if (settings.right !== false) {
			left += Math.max($window.width() - settings.w - loadedWidth - interfaceWidth - setSize(settings.right, 'x'), 0);
		} else if (settings.left !== false) {
			left += setSize(settings.left, 'x');
		} else {
			left += Math.round(Math.max($window.width() - settings.w - loadedWidth - interfaceWidth, 0) / 2);
		}
		
		if (settings.bottom !== false) {
			top += Math.max(winheight() - settings.h - loadedHeight - interfaceHeight - setSize(settings.bottom, 'y'), 0);
		} else if (settings.top !== false) {
			top += setSize(settings.top, 'y');
		} else {
			top += Math.round(Math.max(winheight() - settings.h - loadedHeight - interfaceHeight, 0) / 2);
		}

		$box.css({top: offset.top, left: offset.left, visibility:'visible'});
		
		// this gives the wrapper plenty of breathing room so it's floated contents can move around smoothly,
		// but it has to be shrank down around the size of div#colorbox when it's done.  If not,
		// it can invoke an obscure IE bug when using iframes.
		$wrap[0].style.width = $wrap[0].style.height = "9999px";
		
		function modalDimensions() {
			$topBorder[0].style.width = $bottomBorder[0].style.width = $content[0].style.width = (parseInt($box[0].style.width,10) - interfaceWidth)+'px';
			$content[0].style.height = $leftBorder[0].style.height = $rightBorder[0].style.height = (parseInt($box[0].style.height,10) - interfaceHeight)+'px';
		}

		css = {width: settings.w + loadedWidth + interfaceWidth, height: settings.h + loadedHeight + interfaceHeight, top: top, left: left};

		if (settings.scrollTop) {
		    delete css.top;
		}
		// setting the speed to 0 if the content hasn't changed size or position
		if (speed) {
			var tempSpeed = 0;
			$.each(css, function(i){
				if (css[i] !== previousCSS[i]) {
					tempSpeed = speed;
					return;
				}
			});
			speed = tempSpeed;
		}

		previousCSS = css;

		if (!speed) {
			$box.css(css);
		}

		$box.dequeue().animate(css, {
			duration: speed || 0,
			complete: function () {
				modalDimensions();
				
				active = false;
				
				// shrink the wrapper down to exactly the size of colorbox to avoid a bug in IE's iframe implementation.
				$wrap[0].style.width = (settings.w + loadedWidth + interfaceWidth) + "px";
				$wrap[0].style.height = (settings.h + loadedHeight + interfaceHeight) + "px";
				
				if (settings.reposition) {
					setTimeout(function () {  // small delay before binding onresize due to an IE8 bug.
						$window.bind('resize.' + prefix, publicMethod.position);
					}, 1);
				}

				if (loadedCallback) {
					loadedCallback();
				}
			},
			step: modalDimensions
		});
	};

	publicMethod.resize = function (options) {
	    var scrolltop;
		open = true;
		if (open) {
			options = options || {};
			
			if (options.width) {
				settings.w = setSize(options.width, 'x') - loadedWidth - interfaceWidth;
			}

			if (options.innerWidth) {
				settings.w = setSize(options.innerWidth, 'x');
			}

			$loaded.css({width: settings.w});
			
			if (options.height) {
				settings.h = setSize(options.height, 'y') - loadedHeight - interfaceHeight;
			}

			if (options.innerHeight) {
				settings.h = setSize(options.innerHeight, 'y');
			}

			if (!options.innerHeight && !options.height) {
				scrolltop = $loaded.scrollTop();
				$loaded.css({height: "auto"});
				settings.h = $loaded.height();
			}

			$loaded.css({height: settings.h});

			if(scrolltop) {
				$loaded.scrollTop(scrolltop);
			}
			
			publicMethod.position(settings.transition === "none" ? 0 : settings.speed);
		}
	};

	publicMethod.prep = function (object) {
		if (!open) {
			return;
		}
		
		var callback, speed = settings.transition === "none" ? 0 : settings.speed;

		$loaded.empty().remove(); // Using empty first may prevent some IE7 issues.

		$loaded = $tag(div, 'LoadedContent').append(object);
		
		function getWidth() {
			settings.w = settings.w || $loaded.width();
			settings.w = settings.mw && settings.mw < settings.w ? settings.mw : settings.w;
			return settings.w;
		}
		function getHeight() {
			settings.h = settings.h || $loaded.height();
			settings.h = settings.mh && settings.mh < settings.h ? settings.mh : settings.h;
			return settings.h;
		}
		
		$loaded.hide()
		.appendTo($loadingBay.show())// content has to be appended to the DOM for accurate size calculations.
		.css({width: getWidth(), overflow: settings.scrolling ? 'auto' : 'hidden'})
		.css({height: getHeight()})// sets the height independently from the width in case the new width influences the value of height.
		.prependTo($content);
		
		$loadingBay.hide();
		
		// floating the IMG removes the bottom line-height and fixed a problem where IE miscalculates the width of the parent element as 100% of the document width.
		
		$(photo).css({'float': 'none'});

		callback = function () {
			var total = $related.length,
				iframe,
				frameBorder = 'frameBorder',
				allowTransparency = 'allowTransparency',
				complete;
			
			if (!open) {
				return;
			}
			
			function removeFilter() { // Needed for IE7 & IE8 in versions of jQuery prior to 1.7.2
				if ($.support.opacity === false) {
					$box[0].style.removeAttribute('filter');
				}
			}
			
			complete = function () {
				clearTimeout(loadingTimer);
				$loadingOverlay.hide();
				trigger(event_complete, settings.onComplete);
			};

			
			$title.html(settings.title).add($loaded).show();
			
			if (total > 1) { // handle grouping
				if (typeof settings.current === "string") {
					$current.html(settings.current.replace('{current}', index + 1).replace('{total}', total)).show();
				}
				
				$next[(settings.loop || index < total - 1) ? "show" : "hide"]().html(settings.next);
				$prev[(settings.loop || index) ? "show" : "hide"]().html(settings.previous);
				
				slideshow();
				
				// Preloads images within a rel group
				if (settings.preloading) {
					$.each([getIndex(-1), getIndex(1)], function(){
						var src,
							img,
							i = $related[this],
							data = $.data(i, colorbox);

						if (data && data.href) {
							src = data.href;
							if ($.isFunction(src)) {
								src = src.call(i);
							}
						} else {
							src = $(i).attr('href');
						}

						if (src && isImage(data, src)) {
							src = retinaUrl(data, src);
							img = document.createElement('img');
							img.src = src;
						}
					});
				}
			} else {
				$groupControls.hide();
			}
			
			if (settings.iframe) {
				iframe = $tag('iframe')[0];
				if (frameBorder in iframe) {
					iframe[frameBorder] = 0;
				}
				
				if (allowTransparency in iframe) {
					iframe[allowTransparency] = "true";
				}

				if (!settings.scrolling) {
					iframe.scrolling = "no";
				}
				
				$(iframe)
					.attr({
						src: settings.href,
						name: (new Date()).getTime(), // give the iframe a unique name to prevent caching
						'class': prefix + 'Iframe',
						allowFullScreen : true, // allow HTML5 video to go fullscreen
						webkitAllowFullScreen : true,
						mozallowfullscreen : true
					})
					.one('load', complete)
					.appendTo($loaded);
				
				$events.one(event_purge, function () {
					iframe.src = "//about:blank";
				});

				if (settings.fastIframe) {
					$(iframe).trigger('load');
				}
			} else {
				complete();
			}
			
			if (settings.transition === 'fade') {
				$box.fadeTo(speed, 1, removeFilter);
			} else {
				removeFilter();
			}
		};
		
		if (settings.transition === 'fade') {
			$box.fadeTo(speed, 0, function () {
				publicMethod.position(0, callback);
			});
		} else {
			publicMethod.position(speed, callback);
		}
	};

	function load () {
		var href, setResize, prep = publicMethod.prep, $inline, request = ++requests;
		
		active = true;
		
		photo = false;
		
		element = $related[index];
		
		makeSettings();
		
		trigger(event_purge);
		
		trigger(event_load, settings.onLoad);
		
		settings.h = settings.height ?
				setSize(settings.height, 'y') - loadedHeight - interfaceHeight :
				settings.innerHeight && setSize(settings.innerHeight, 'y');
		
		settings.w = settings.width ?
				setSize(settings.width, 'x') - loadedWidth - interfaceWidth :
				settings.innerWidth && setSize(settings.innerWidth, 'x');
		
		// Sets the minimum dimensions for use in image scaling
		settings.mw = settings.w;
		settings.mh = settings.h;
		
		// Re-evaluate the minimum width and height based on maxWidth and maxHeight values.
		// If the width or height exceed the maxWidth or maxHeight, use the maximum values instead.
		if (settings.maxWidth) {
			settings.mw = setSize(settings.maxWidth, 'x') - loadedWidth - interfaceWidth;
			settings.mw = settings.w && settings.w < settings.mw ? settings.w : settings.mw;
		}
		if (settings.maxHeight) {
			settings.mh = setSize(settings.maxHeight, 'y') - loadedHeight - interfaceHeight;
			settings.mh = settings.h && settings.h < settings.mh ? settings.h : settings.mh;
		}
		
		href = settings.href;
		
		loadingTimer = setTimeout(function () {
			$loadingOverlay.show();
		}, 100);
		
		if (settings.inline) {
			// Inserts an empty placeholder where inline content is being pulled from.
			// An event is bound to put inline content back when Colorbox closes or loads new content.
			$inline = $tag(div).hide().insertBefore($(href)[0]);

			$events.one(event_purge, function () {
				$inline.replaceWith($loaded.children());
			});

			prep($(href));
		} else if (settings.iframe) {
			// IFrame element won't be added to the DOM until it is ready to be displayed,
			// to avoid problems with DOM-ready JS that might be trying to run in that iframe.
			prep(" ");
		} else if (settings.html) {
			prep(settings.html);
		} else if (isImage(settings, href)) {

			href = retinaUrl(settings, href);

			photo = document.createElement('img');

			$(photo)
			.addClass(prefix + 'Photo')
			.bind('error',function () {
				settings.title = false;
				prep($tag(div, 'Error').html(settings.imgError));
			})
			.one('load', function () {
				var percent;

				if (request !== requests) {
					return;
				}

				$.each(['alt', 'longdesc', 'aria-describedby'], function(i,val){
					var attr = $(element).attr(val) || $(element).attr('data-'+val);
					if (attr) {
						photo.setAttribute(val, attr);
					}
				});

				if (settings.retinaImage && window.devicePixelRatio > 1) {
					photo.height = photo.height / window.devicePixelRatio;
					photo.width = photo.width / window.devicePixelRatio;
				}

				if (settings.scalePhotos) {
					setResize = function () {
						photo.height -= photo.height * percent;
						photo.width -= photo.width * percent;
					};
					if (settings.mw && photo.width > settings.mw) {
						percent = (photo.width - settings.mw) / photo.width;
						setResize();
					}
					if (settings.mh && photo.height > settings.mh) {
						percent = (photo.height - settings.mh) / photo.height;
						setResize();
					}
				}
				
				if (settings.h) {
					photo.style.marginTop = Math.max(settings.mh - photo.height, 0) / 2 + 'px';
				}
				
				if ($related[1] && (settings.loop || $related[index + 1])) {
					photo.style.cursor = 'pointer';
					photo.onclick = function () {
						publicMethod.next();
					};
				}

				photo.style.width = photo.width + 'px';
				photo.style.height = photo.height + 'px';

				setTimeout(function () { // A pause because Chrome will sometimes report a 0 by 0 size otherwise.
					prep(photo);
				}, 1);
			});
			
			setTimeout(function () { // A pause because Opera 10.6+ will sometimes not run the onload function otherwise.
				photo.src = href;
			}, 1);
		} else if (href) {
			$loadingBay.load(href, settings.data, function (data, status) {
				if (request === requests) {
					prep(status === 'error' ? $tag(div, 'Error').html(settings.xhrError) : $(this).contents());
				}
			});
		}
	}
		
	// Navigates to the next page/image in a set.
	publicMethod.next = function () {
		if (!active && $related[1] && (settings.loop || $related[index + 1])) {
			index = getIndex(1);
			launch($related[index]);
		}
	};
	
	publicMethod.prev = function () {
		if (!active && $related[1] && (settings.loop || index)) {
			index = getIndex(-1);
			launch($related[index]);
		}
	};

	// Note: to use this within an iframe use the following format: parent.jQuery.colorbox.close();
	publicMethod.close = function () {
		if (open && !closing) {
			
			closing = true;
			open = false;
			
			trigger(event_cleanup, settings.onCleanup);
			
			$window.unbind('.' + prefix);
			
			$overlay.fadeTo(settings.fadeOut || 0, 0);
			
			$box.stop().fadeTo(settings.fadeOut || 0, 0, function () {
			
				$box.add($overlay).css({'opacity': 1, cursor: 'auto'}).hide();
				
				trigger(event_purge);
				
				$loaded.empty().remove(); // Using empty first may prevent some IE7 issues.
				
				setTimeout(function () {
					closing = false;
					trigger(event_closed, settings.onClosed);
				}, 1);
			});
		}
	};

	// Removes changes Colorbox made to the document, but does not remove the plugin.
	publicMethod.remove = function () {
		if (!$box) { return; }

		$box.stop();
		$.colorbox.close();
		$box.stop().remove();
		$overlay.remove();
		closing = false;
		$box = null;
		$('.' + boxElement)
			.removeData(colorbox)
			.removeClass(boxElement);

		$(document).unbind('click.'+prefix);
	};

	// A method for fetching the current element Colorbox is referencing.
	// returns a jQuery object.
	publicMethod.element = function () {
		return $(element);
	};

	publicMethod.settings = defaults;

}(jQuery, document, window));

/*!
* jQuery Cycle2; build: v20131022
* http://jquery.malsup.com/cycle2/
* Copyright (c) 2013 M. Alsup; Dual licensed: MIT/GPL
*/

/*! core engine; version: 20131003 */
;(function($) {
"use strict";

var version = '20131003';

$.fn.cycle = function( options ) {
    // fix mistakes with the ready state
    var o;
    if ( this.length === 0 && !$.isReady ) {
        o = { s: this.selector, c: this.context };
        $.fn.cycle.log('requeuing slideshow (dom not ready)');
        $(function() {
            $( o.s, o.c ).cycle(options);
        });
        return this;
    }

    return this.each(function() {
        var data, opts, shortName, val;
        var container = $(this);
        var log = $.fn.cycle.log;

        if ( container.data('cycle.opts') )
            return; // already initialized

        if ( container.data('cycle-log') === false || 
            ( options && options.log === false ) ||
            ( opts && opts.log === false) ) {
            log = $.noop;
        }

        log('--c2 init--');
        data = container.data();
        for (var p in data) {
            // allow props to be accessed sans 'cycle' prefix and log the overrides
            if (data.hasOwnProperty(p) && /^cycle[A-Z]+/.test(p) ) {
                val = data[p];
                shortName = p.match(/^cycle(.*)/)[1].replace(/^[A-Z]/, lowerCase);
                log(shortName+':', val, '('+typeof val +')');
                data[shortName] = val;
            }
        }

        opts = $.extend( {}, $.fn.cycle.defaults, data, options || {});

        opts.timeoutId = 0;
        opts.paused = opts.paused || false; // #57
        opts.container = container;
        opts._maxZ = opts.maxZ;

        opts.API = $.extend ( { _container: container }, $.fn.cycle.API );
        opts.API.log = log;
        opts.API.trigger = function( eventName, args ) {
            opts.container.trigger( eventName, args );
            return opts.API;
        };

        container.data( 'cycle.opts', opts );
        container.data( 'cycle.API', opts.API );

        // opportunity for plugins to modify opts and API
        opts.API.trigger('cycle-bootstrap', [ opts, opts.API ]);

        opts.API.addInitialSlides();
        opts.API.preInitSlideshow();

        if ( opts.slides.length )
            opts.API.initSlideshow();
    });
};

$.fn.cycle.API = {
    opts: function() {
        return this._container.data( 'cycle.opts' );
    },
    addInitialSlides: function() {
        var opts = this.opts();
        var slides = opts.slides;
        opts.slideCount = 0;
        opts.slides = $(); // empty set
        
        // add slides that already exist
        slides = slides.jquery ? slides : opts.container.find( slides );

        if ( opts.random ) {
            slides.sort(function() {return Math.random() - 0.5;});
        }

        opts.API.add( slides );
    },

    preInitSlideshow: function() {
        var opts = this.opts();
        opts.API.trigger('cycle-pre-initialize', [ opts ]);
        var tx = $.fn.cycle.transitions[opts.fx];
        if (tx && $.isFunction(tx.preInit))
            tx.preInit( opts );
        opts._preInitialized = true;
    },

    postInitSlideshow: function() {
        var opts = this.opts();
        opts.API.trigger('cycle-post-initialize', [ opts ]);
        var tx = $.fn.cycle.transitions[opts.fx];
        if (tx && $.isFunction(tx.postInit))
            tx.postInit( opts );
    },

    initSlideshow: function() {
        var opts = this.opts();
        var pauseObj = opts.container;
        var slideOpts;
        opts.API.calcFirstSlide();

        if ( opts.container.css('position') == 'static' )
            opts.container.css('position', 'relative');

        $(opts.slides[opts.currSlide]).css('opacity',1).show();
        opts.API.stackSlides( opts.slides[opts.currSlide], opts.slides[opts.nextSlide], !opts.reverse );

        if ( opts.pauseOnHover ) {
            // allow pauseOnHover to specify an element
            if ( opts.pauseOnHover !== true )
                pauseObj = $( opts.pauseOnHover );

            pauseObj.hover(
                function(){ opts.API.pause( true ); }, 
                function(){ opts.API.resume( true ); }
            );
        }

        // stage initial transition
        if ( opts.timeout ) {
            slideOpts = opts.API.getSlideOpts( opts.currSlide );
            opts.API.queueTransition( slideOpts, slideOpts.timeout + opts.delay );
        }

        opts._initialized = true;
        opts.API.updateView( true );
        opts.API.trigger('cycle-initialized', [ opts ]);
        opts.API.postInitSlideshow();
    },

    pause: function( hover ) {
        var opts = this.opts(),
            slideOpts = opts.API.getSlideOpts(),
            alreadyPaused = opts.hoverPaused || opts.paused;

        if ( hover )
            opts.hoverPaused = true; 
        else
            opts.paused = true;

        if ( ! alreadyPaused ) {
            opts.container.addClass('cycle-paused');
            opts.API.trigger('cycle-paused', [ opts ]).log('cycle-paused');

            if ( slideOpts.timeout ) {
                clearTimeout( opts.timeoutId );
                opts.timeoutId = 0;
                
                // determine how much time is left for the current slide
                opts._remainingTimeout -= ( $.now() - opts._lastQueue );
                if ( opts._remainingTimeout < 0 || isNaN(opts._remainingTimeout) )
                    opts._remainingTimeout = undefined;
            }
        }
    },

    resume: function( hover ) {
        var opts = this.opts(),
            alreadyResumed = !opts.hoverPaused && !opts.paused,
            remaining;

        if ( hover )
            opts.hoverPaused = false; 
        else
            opts.paused = false;

    
        if ( ! alreadyResumed ) {
            opts.container.removeClass('cycle-paused');
            // #gh-230; if an animation is in progress then don't queue a new transition; it will
            // happen naturally
            if ( opts.slides.filter(':animated').length === 0 )
                opts.API.queueTransition( opts.API.getSlideOpts(), opts._remainingTimeout );
            opts.API.trigger('cycle-resumed', [ opts, opts._remainingTimeout ] ).log('cycle-resumed');
        }
    },

    add: function( slides, prepend ) {
        var opts = this.opts();
        var oldSlideCount = opts.slideCount;
        var startSlideshow = false;
        var len;

        if ( $.type(slides) == 'string')
            slides = $.trim( slides );

        $( slides ).each(function(i) {
            var slideOpts;
            var slide = $(this);

            if ( prepend )
                opts.container.prepend( slide );
            else
                opts.container.append( slide );

            opts.slideCount++;
            slideOpts = opts.API.buildSlideOpts( slide );

            if ( prepend )
                opts.slides = $( slide ).add( opts.slides );
            else
                opts.slides = opts.slides.add( slide );

            opts.API.initSlide( slideOpts, slide, --opts._maxZ );

            slide.data('cycle.opts', slideOpts);
            opts.API.trigger('cycle-slide-added', [ opts, slideOpts, slide ]);
        });

        opts.API.updateView( true );

        startSlideshow = opts._preInitialized && (oldSlideCount < 2 && opts.slideCount >= 1);
        if ( startSlideshow ) {
            if ( !opts._initialized )
                opts.API.initSlideshow();
            else if ( opts.timeout ) {
                len = opts.slides.length;
                opts.nextSlide = opts.reverse ? len - 1 : 1;
                if ( !opts.timeoutId ) {
                    opts.API.queueTransition( opts );
                }
            }
        }
    },

    calcFirstSlide: function() {
        var opts = this.opts();
        var firstSlideIndex;
        firstSlideIndex = parseInt( opts.startingSlide || 0, 10 );
        if (firstSlideIndex >= opts.slides.length || firstSlideIndex < 0)
            firstSlideIndex = 0;

        opts.currSlide = firstSlideIndex;
        if ( opts.reverse ) {
            opts.nextSlide = firstSlideIndex - 1;
            if (opts.nextSlide < 0)
                opts.nextSlide = opts.slides.length - 1;
        }
        else {
            opts.nextSlide = firstSlideIndex + 1;
            if (opts.nextSlide == opts.slides.length)
                opts.nextSlide = 0;
        }
    },

    calcNextSlide: function() {
        var opts = this.opts();
        var roll;
        if ( opts.reverse ) {
            roll = (opts.nextSlide - 1) < 0;
            opts.nextSlide = roll ? opts.slideCount - 1 : opts.nextSlide-1;
            opts.currSlide = roll ? 0 : opts.nextSlide+1;
        }
        else {
            roll = (opts.nextSlide + 1) == opts.slides.length;
            opts.nextSlide = roll ? 0 : opts.nextSlide+1;
            opts.currSlide = roll ? opts.slides.length-1 : opts.nextSlide-1;
        }
    },

    calcTx: function( slideOpts, manual ) {
        var opts = slideOpts;
        var tx;
        if ( manual && opts.manualFx )
            tx = $.fn.cycle.transitions[opts.manualFx];
        if ( !tx )
            tx = $.fn.cycle.transitions[opts.fx];

        if (!tx) {
            tx = $.fn.cycle.transitions.fade;
            opts.API.log('Transition "' + opts.fx + '" not found.  Using fade.');
        }
        return tx;
    },

    prepareTx: function( manual, fwd ) {
        var opts = this.opts();
        var after, curr, next, slideOpts, tx;

        if ( opts.slideCount < 2 ) {
            opts.timeoutId = 0;
            return;
        }
        if ( manual && ( !opts.busy || opts.manualTrump ) ) {
            opts.API.stopTransition();
            opts.busy = false;
            clearTimeout(opts.timeoutId);
            opts.timeoutId = 0;
        }
        if ( opts.busy )
            return;
        if ( opts.timeoutId === 0 && !manual )
            return;

        curr = opts.slides[opts.currSlide];
        next = opts.slides[opts.nextSlide];
        slideOpts = opts.API.getSlideOpts( opts.nextSlide );
        tx = opts.API.calcTx( slideOpts, manual );

        opts._tx = tx;

        if ( manual && slideOpts.manualSpeed !== undefined )
            slideOpts.speed = slideOpts.manualSpeed;

        // if ( opts.nextSlide === opts.currSlide )
        //     opts.API.calcNextSlide();

        // ensure that:
        //      1. advancing to a different slide
        //      2. this is either a manual event (prev/next, pager, cmd) or 
        //              a timer event and slideshow is not paused
        if ( opts.nextSlide != opts.currSlide && 
            (manual || (!opts.paused && !opts.hoverPaused && opts.timeout) )) { // #62

            opts.API.trigger('cycle-before', [ slideOpts, curr, next, fwd ]);
            if ( tx.before )
                tx.before( slideOpts, curr, next, fwd );

            after = function() {
                opts.busy = false;
                // #76; bail if slideshow has been destroyed
                if (! opts.container.data( 'cycle.opts' ) )
                    return;

                if (tx.after)
                    tx.after( slideOpts, curr, next, fwd );
                opts.API.trigger('cycle-after', [ slideOpts, curr, next, fwd ]);
                opts.API.queueTransition( slideOpts);
                opts.API.updateView( true );
            };

            opts.busy = true;
            if (tx.transition)
                tx.transition(slideOpts, curr, next, fwd, after);
            else
                opts.API.doTransition( slideOpts, curr, next, fwd, after);

            opts.API.calcNextSlide();
            opts.API.updateView();
        } else {
            opts.API.queueTransition( slideOpts );
        }
    },

    // perform the actual animation
    doTransition: function( slideOpts, currEl, nextEl, fwd, callback) {
        var opts = slideOpts;
        var curr = $(currEl), next = $(nextEl);
        var fn = function() {
            // make sure animIn has something so that callback doesn't trigger immediately
            next.animate(opts.animIn || { opacity: 1}, opts.speed, opts.easeIn || opts.easing, callback);
        };

        next.css(opts.cssBefore || {});
        curr.animate(opts.animOut || {}, opts.speed, opts.easeOut || opts.easing, function() {
            curr.css(opts.cssAfter || {});
            if (!opts.sync) {
                fn();
            }
        });
        if (opts.sync) {
            fn();
        }
    },

    queueTransition: function( slideOpts, specificTimeout ) {
        var opts = this.opts();
        var timeout = specificTimeout !== undefined ? specificTimeout : slideOpts.timeout;
        if (opts.nextSlide === 0 && --opts.loop === 0) {
            opts.API.log('terminating; loop=0');
            opts.timeout = 0;
            if ( timeout ) {
                setTimeout(function() {
                    opts.API.trigger('cycle-finished', [ opts ]);
                }, timeout);
            }
            else {
                opts.API.trigger('cycle-finished', [ opts ]);
            }
            // reset nextSlide
            opts.nextSlide = opts.currSlide;
            return;
        }
        if ( timeout ) {
            opts._lastQueue = $.now();
            if ( specificTimeout === undefined )
                opts._remainingTimeout = slideOpts.timeout;

            if ( !opts.paused && ! opts.hoverPaused ) {
                opts.timeoutId = setTimeout(function() { 
                    opts.API.prepareTx( false, !opts.reverse ); 
                }, timeout );
            }
        }
    },

    stopTransition: function() {
        var opts = this.opts();
        if ( opts.slides.filter(':animated').length ) {
            opts.slides.stop(false, true);
            opts.API.trigger('cycle-transition-stopped', [ opts ]);
        }

        if ( opts._tx && opts._tx.stopTransition )
            opts._tx.stopTransition( opts );
    },

    // advance slide forward or back
    advanceSlide: function( val ) {
        var opts = this.opts();
        clearTimeout(opts.timeoutId);
        opts.timeoutId = 0;
        opts.nextSlide = opts.currSlide + val;
        
        if (opts.nextSlide < 0)
            opts.nextSlide = opts.slides.length - 1;
        else if (opts.nextSlide >= opts.slides.length)
            opts.nextSlide = 0;

        opts.API.prepareTx( true,  val >= 0 );
        return false;
    },

    buildSlideOpts: function( slide ) {
        var opts = this.opts();
        var val, shortName;
        var slideOpts = slide.data() || {};
        for (var p in slideOpts) {
            // allow props to be accessed sans 'cycle' prefix and log the overrides
            if (slideOpts.hasOwnProperty(p) && /^cycle[A-Z]+/.test(p) ) {
                val = slideOpts[p];
                shortName = p.match(/^cycle(.*)/)[1].replace(/^[A-Z]/, lowerCase);
                opts.API.log('['+(opts.slideCount-1)+']', shortName+':', val, '('+typeof val +')');
                slideOpts[shortName] = val;
            }
        }

        slideOpts = $.extend( {}, $.fn.cycle.defaults, opts, slideOpts );
        slideOpts.slideNum = opts.slideCount;

        try {
            // these props should always be read from the master state object
            delete slideOpts.API;
            delete slideOpts.slideCount;
            delete slideOpts.currSlide;
            delete slideOpts.nextSlide;
            delete slideOpts.slides;
        } catch(e) {
            // no op
        }
        return slideOpts;
    },

    getSlideOpts: function( index ) {
        var opts = this.opts();
        if ( index === undefined )
            index = opts.currSlide;

        var slide = opts.slides[index];
        var slideOpts = $(slide).data('cycle.opts');
        return $.extend( {}, opts, slideOpts );
    },
    
    initSlide: function( slideOpts, slide, suggestedZindex ) {
        var opts = this.opts();
        slide.css( slideOpts.slideCss || {} );
        if ( suggestedZindex > 0 )
            slide.css( 'zIndex', suggestedZindex );

        // ensure that speed settings are sane
        if ( isNaN( slideOpts.speed ) )
            slideOpts.speed = $.fx.speeds[slideOpts.speed] || $.fx.speeds._default;
        if ( !slideOpts.sync )
            slideOpts.speed = slideOpts.speed / 2;

        slide.addClass( opts.slideClass );
    },

    updateView: function( isAfter, isDuring ) {
        var opts = this.opts();
        if ( !opts._initialized )
            return;
        var slideOpts = opts.API.getSlideOpts();
        var currSlide = opts.slides[ opts.currSlide ];

        if ( ! isAfter && isDuring !== true ) {
            opts.API.trigger('cycle-update-view-before', [ opts, slideOpts, currSlide ]);
            if ( opts.updateView < 0 )
                return;
        }

        if ( opts.slideActiveClass ) {
            opts.slides.removeClass( opts.slideActiveClass )
                .eq( opts.currSlide ).addClass( opts.slideActiveClass );
        }

        if ( isAfter && opts.hideNonActive )
            opts.slides.filter( ':not(.' + opts.slideActiveClass + ')' ).hide();

        if ( opts.updateView === 0 ) {
            setTimeout(function() {
                opts.API.trigger('cycle-update-view', [ opts, slideOpts, currSlide, isAfter ]);
            }, slideOpts.speed / (opts.sync ? 2 : 1) );
        }

        if ( opts.updateView !== 0 )
            opts.API.trigger('cycle-update-view', [ opts, slideOpts, currSlide, isAfter ]);
        
        if ( isAfter )
            opts.API.trigger('cycle-update-view-after', [ opts, slideOpts, currSlide ]);
    },

    getComponent: function( name ) {
        var opts = this.opts();
        var selector = opts[name];
        if (typeof selector === 'string') {
            // if selector is a child, sibling combinator, adjancent selector then use find, otherwise query full dom
            return (/^\s*[\>|\+|~]/).test( selector ) ? opts.container.find( selector ) : $( selector );
        }
        if (selector.jquery)
            return selector;
        
        return $(selector);
    },

    stackSlides: function( curr, next, fwd ) {
        var opts = this.opts();
        if ( !curr ) {
            curr = opts.slides[opts.currSlide];
            next = opts.slides[opts.nextSlide];
            fwd = !opts.reverse;
        }

        // reset the zIndex for the common case:
        // curr slide on top,  next slide beneath, and the rest in order to be shown
        $(curr).css('zIndex', opts.maxZ);

        var i;
        var z = opts.maxZ - 2;
        var len = opts.slideCount;
        if (fwd) {
            for ( i = opts.currSlide + 1; i < len; i++ )
                $( opts.slides[i] ).css( 'zIndex', z-- );
            for ( i = 0; i < opts.currSlide; i++ )
                $( opts.slides[i] ).css( 'zIndex', z-- );
        }
        else {
            for ( i = opts.currSlide - 1; i >= 0; i-- )
                $( opts.slides[i] ).css( 'zIndex', z-- );
            for ( i = len - 1; i > opts.currSlide; i-- )
                $( opts.slides[i] ).css( 'zIndex', z-- );
        }

        $(next).css('zIndex', opts.maxZ - 1);
    },

    getSlideIndex: function( el ) {
        return this.opts().slides.index( el );
    }

}; // API

// default logger
$.fn.cycle.log = function log() {
    /*global console:true */
    //if (window.console && console.log) commented by Rick
      //  console.log('[cycle2] ' + Array.prototype.join.call(arguments, ' ') ); commented by Rick
};

$.fn.cycle.version = function() { return 'Cycle2: ' + version; };

// helper functions

function lowerCase(s) {
    return (s || '').toLowerCase();
}

// expose transition object
$.fn.cycle.transitions = {
    custom: {
    },
    none: {
        before: function( opts, curr, next, fwd ) {
            opts.API.stackSlides( next, curr, fwd );
            opts.cssBefore = { opacity: 1, display: 'block' };
        }
    },
    fade: {
        before: function( opts, curr, next, fwd ) {
            var css = opts.API.getSlideOpts( opts.nextSlide ).slideCss || {};
            opts.API.stackSlides( curr, next, fwd );
            opts.cssBefore = $.extend(css, { opacity: 0, display: 'block' });
            opts.animIn = { opacity: 1 };
            opts.animOut = { opacity: 0 };
        }
    },
    fadeout: {
        before: function( opts , curr, next, fwd ) {
            var css = opts.API.getSlideOpts( opts.nextSlide ).slideCss || {};
            opts.API.stackSlides( curr, next, fwd );
            opts.cssBefore = $.extend(css, { opacity: 1, display: 'block' });
            opts.animOut = { opacity: 0 };
        }
    },
    scrollHorz: {
        before: function( opts, curr, next, fwd ) {
            opts.API.stackSlides( curr, next, fwd );
            var w = opts.container.css('overflow','hidden').width();
            opts.cssBefore = { left: fwd ? w : - w, top: 0, opacity: 1, display: 'block' };
            opts.cssAfter = { zIndex: opts._maxZ - 2, left: 0 };
            opts.animIn = { left: 0 };
            opts.animOut = { left: fwd ? -w : w };
        }
    }
};

// @see: http://jquery.malsup.com/cycle2/api
$.fn.cycle.defaults = {
    allowWrap:        true,
    autoSelector:     '.cycle-slideshow[data-cycle-auto-init!=false]',
    delay:            0,
    easing:           null,
    fx:              'fade',
    hideNonActive:    true,
    loop:             0,
    manualFx:         undefined,
    manualSpeed:      undefined,
    manualTrump:      true,
    maxZ:             100,
    pauseOnHover:     false,
    reverse:          false,
    slideActiveClass: 'cycle-slide-active',
    slideClass:       'cycle-slide',
    slideCss:         { position: 'absolute', top: 0, left: 0 },
    slides:          '> img',
    speed:            500,
    startingSlide:    0,
    sync:             true,
    timeout:          4000,
    updateView:       0
};

// automatically find and run slideshows
$(document).ready(function() {
    $( $.fn.cycle.defaults.autoSelector ).cycle();
});

})(jQuery);

/*! Cycle2 autoheight plugin; Copyright (c) M.Alsup, 2012; version: 20130304 */
(function($) {
"use strict";

$.extend($.fn.cycle.defaults, {
    autoHeight: 0 // setting this option to false disables autoHeight logic
});    

$(document).on( 'cycle-initialized', function( e, opts ) {
    var autoHeight = opts.autoHeight;
    var t = $.type( autoHeight );
    var resizeThrottle = null;
    var ratio;

    if ( t !== 'string' && t !== 'number' )
        return;

    // bind events
    opts.container.on( 'cycle-slide-added cycle-slide-removed', initAutoHeight );
    opts.container.on( 'cycle-destroyed', onDestroy );

    if ( autoHeight == 'container' ) {
        opts.container.on( 'cycle-before', onBefore );
    }
    else if ( t === 'string' && /\d+\:\d+/.test( autoHeight ) ) { 
        // use ratio
        ratio = autoHeight.match(/(\d+)\:(\d+)/);
        ratio = ratio[1] / ratio[2];
        opts._autoHeightRatio = ratio;
    }

    // if autoHeight is a number then we don't need to recalculate the sentinel
    // index on resize
    if ( t !== 'number' ) {
        // bind unique resize handler per slideshow (so it can be 'off-ed' in onDestroy)
        opts._autoHeightOnResize = function () {
            clearTimeout( resizeThrottle );
            resizeThrottle = setTimeout( onResize, 50 );
        };

        $(window).on( 'resize orientationchange', opts._autoHeightOnResize );
    }

    setTimeout( onResize, 30 );

    function onResize() {
        initAutoHeight( e, opts );
    }
});

function initAutoHeight( e, opts ) {
    var clone, height, sentinelIndex;
    var autoHeight = opts.autoHeight;

    if ( autoHeight == 'container' ) {
        height = $( opts.slides[ opts.currSlide ] ).outerHeight();
        opts.container.height( height );
    }
    else if ( opts._autoHeightRatio ) { 
        opts.container.height( opts.container.width() / opts._autoHeightRatio );
    }
    else if ( autoHeight === 'calc' || ( $.type( autoHeight ) == 'number' && autoHeight >= 0 ) ) {
        if ( autoHeight === 'calc' )
            sentinelIndex = calcSentinelIndex( e, opts );
        else if ( autoHeight >= opts.slides.length )
            sentinelIndex = 0;
        else 
            sentinelIndex = autoHeight;

        // only recreate sentinel if index is different
        if ( sentinelIndex == opts._sentinelIndex )
            return;

        opts._sentinelIndex = sentinelIndex;
        if ( opts._sentinel )
            opts._sentinel.remove();

        // clone existing slide as sentinel
        clone = $( opts.slides[ sentinelIndex ].cloneNode(true) );
        
        // #50; remove special attributes from cloned content
        clone.removeAttr( 'id name rel' ).find( '[id],[name],[rel]' ).removeAttr( 'id name rel' );

        clone.css({
            position: 'static',
            visibility: 'hidden',
            display: 'block'
        }).prependTo( opts.container ).addClass('cycle-sentinel cycle-slide').removeClass('cycle-slide-active');
        clone.find( '*' ).css( 'visibility', 'hidden' );

        opts._sentinel = clone;
    }
}    

function calcSentinelIndex( e, opts ) {
    var index = 0, max = -1;

    // calculate tallest slide index
    opts.slides.each(function(i) {
        var h = $(this).height();
        if ( h > max ) {
            max = h;
            index = i;
        }
    });
    return index;
}

function onBefore( e, opts, outgoing, incoming, forward ) {
    var h = $(incoming).outerHeight();
    var duration = opts.sync ? opts.speed / 2 : opts.speed;
    opts.container.animate( { height: h }, duration );
}

function onDestroy( e, opts ) {
    if ( opts._autoHeightOnResize ) {
        $(window).off( 'resize orientationchange', opts._autoHeightOnResize );
        opts._autoHeightOnResize = null;
    }
    opts.container.off( 'cycle-slide-added cycle-slide-removed', initAutoHeight );
    opts.container.off( 'cycle-destroyed', onDestroy );
    opts.container.off( 'cycle-before', onBefore );

    if ( opts._sentinel ) {
        opts._sentinel.remove();
        opts._sentinel = null;
    }
}

})(jQuery);

/*! caption plugin for Cycle2;  version: 20130306 */
(function($) {
"use strict";

$.extend($.fn.cycle.defaults, {
    caption:          '> .cycle-caption',
    captionTemplate:  '{{slideNum}} / {{slideCount}}',
    overlay:          '> .cycle-overlay',
    overlayTemplate:  '<div>{{title}}</div><div>{{desc}}</div>',
    captionModule:    'caption'
});    

$(document).on( 'cycle-update-view', function( e, opts, slideOpts, currSlide ) {
    if ( opts.captionModule !== 'caption' )
        return;
    var el;
    $.each(['caption','overlay'], function() {
        var name = this; 
        var template = slideOpts[name+'Template'];
        var el = opts.API.getComponent( name );
        if( el.length && template ) {
            el.html( opts.API.tmpl( template, slideOpts, opts, currSlide ) );
            el.show();
        }
        else {
            el.hide();
        }
    });
});

$(document).on( 'cycle-destroyed', function( e, opts ) {
    var el;
    $.each(['caption','overlay'], function() {
        var name = this, template = opts[name+'Template'];
        if ( opts[name] && template ) {
            el = opts.API.getComponent( 'caption' );
            el.empty();
        }
    });
});

})(jQuery);

/*! command plugin for Cycle2;  version: 20130707 */
(function($) {
"use strict";

var c2 = $.fn.cycle;

$.fn.cycle = function( options ) {
    var cmd, cmdFn, opts;
    var args = $.makeArray( arguments );

    if ( $.type( options ) == 'number' ) {
        return this.cycle( 'goto', options );
    }

    if ( $.type( options ) == 'string' ) {
        return this.each(function() {
            var cmdArgs;
            cmd = options;
            opts = $(this).data('cycle.opts');

            if ( opts === undefined ) {
                c2.log('slideshow must be initialized before sending commands; "' + cmd + '" ignored');
                return;
            }
            else {
                cmd = cmd == 'goto' ? 'jump' : cmd; // issue #3; change 'goto' to 'jump' internally
                cmdFn = opts.API[ cmd ];
                if ( $.isFunction( cmdFn )) {
                    cmdArgs = $.makeArray( args );
                    cmdArgs.shift();
                    return cmdFn.apply( opts.API, cmdArgs );
                }
                else {
                    c2.log( 'unknown command: ', cmd );
                }
            }
        });
    }
    else {
        return c2.apply( this, arguments );
    }
};

// copy props
$.extend( $.fn.cycle, c2 );

$.extend( c2.API, {
    next: function() {
        var opts = this.opts();
        if ( opts.busy && ! opts.manualTrump )
            return;
        
        var count = opts.reverse ? -1 : 1;
        if ( opts.allowWrap === false && ( opts.currSlide + count ) >= opts.slideCount )
            return;

        opts.API.advanceSlide( count );
        opts.API.trigger('cycle-next', [ opts ]).log('cycle-next');
    },

    prev: function() {
        var opts = this.opts();
        if ( opts.busy && ! opts.manualTrump )
            return;
        var count = opts.reverse ? 1 : -1;
        if ( opts.allowWrap === false && ( opts.currSlide + count ) < 0 )
            return;

        opts.API.advanceSlide( count );
        opts.API.trigger('cycle-prev', [ opts ]).log('cycle-prev');
    },

    destroy: function() {
        this.stop(); //#204

        var opts = this.opts();
        var clean = $.isFunction( $._data ) ? $._data : $.noop;  // hack for #184 and #201
        clearTimeout(opts.timeoutId);
        opts.timeoutId = 0;
        opts.API.stop();
        opts.API.trigger( 'cycle-destroyed', [ opts ] ).log('cycle-destroyed');
        opts.container.removeData();
        clean( opts.container[0], 'parsedAttrs', false );

        // #75; remove inline styles
        if ( ! opts.retainStylesOnDestroy ) {
            opts.container.removeAttr( 'style' );
            opts.slides.removeAttr( 'style' );
            opts.slides.removeClass( opts.slideActiveClass );
        }
        opts.slides.each(function() {
            $(this).removeData();
            clean( this, 'parsedAttrs', false );
        });
    },

    jump: function( index ) {
        // go to the requested slide
        var fwd;
        var opts = this.opts();
        if ( opts.busy && ! opts.manualTrump )
            return;
        var num = parseInt( index, 10 );
        if (isNaN(num) || num < 0 || num >= opts.slides.length) {
            opts.API.log('goto: invalid slide index: ' + num);
            return;
        }
        if (num == opts.currSlide) {
            opts.API.log('goto: skipping, already on slide', num);
            return;
        }
        opts.nextSlide = num;
        clearTimeout(opts.timeoutId);
        opts.timeoutId = 0;
        opts.API.log('goto: ', num, ' (zero-index)');
        fwd = opts.currSlide < opts.nextSlide;
        opts.API.prepareTx( true, fwd );
    },

    stop: function() {
        var opts = this.opts();
        var pauseObj = opts.container;
        clearTimeout(opts.timeoutId);
        opts.timeoutId = 0;
        opts.API.stopTransition();
        if ( opts.pauseOnHover ) {
            if ( opts.pauseOnHover !== true )
                pauseObj = $( opts.pauseOnHover );
            pauseObj.off('mouseenter mouseleave');
        }
        opts.API.trigger('cycle-stopped', [ opts ]).log('cycle-stopped');
    },

    reinit: function() {
        var opts = this.opts();
        opts.API.destroy();
        opts.container.cycle();
    },

    remove: function( index ) {
        var opts = this.opts();
        var slide, slideToRemove, slides = [], slideNum = 1;
        for ( var i=0; i < opts.slides.length; i++ ) {
            slide = opts.slides[i];
            if ( i == index ) {
                slideToRemove = slide;
            }
            else {
                slides.push( slide );
                $( slide ).data('cycle.opts').slideNum = slideNum;
                slideNum++;
            }
        }
        if ( slideToRemove ) {
            opts.slides = $( slides );
            opts.slideCount--;
            $( slideToRemove ).remove();
            if (index == opts.currSlide)
                opts.API.advanceSlide( 1 );
            else if ( index < opts.currSlide )
                opts.currSlide--;
            else
                opts.currSlide++;

            opts.API.trigger('cycle-slide-removed', [ opts, index, slideToRemove ]).log('cycle-slide-removed');
            opts.API.updateView();
        }
    }

});

// listen for clicks on elements with data-cycle-cmd attribute
$(document).on('click.cycle', '[data-cycle-cmd]', function(e) {
    // issue cycle command
    e.preventDefault();
    var el = $(this);
    var command = el.data('cycle-cmd');
    var context = el.data('cycle-context') || '.cycle-slideshow';
    $(context).cycle(command, el.data('cycle-arg'));
});


})(jQuery);

/*! hash plugin for Cycle2;  version: 20130905 */
(function($) {
"use strict";

$(document).on( 'cycle-pre-initialize', function( e, opts ) {
    onHashChange( opts, true );

    opts._onHashChange = function() {
        onHashChange( opts, false );
    };

    $( window ).on( 'hashchange', opts._onHashChange);
});

$(document).on( 'cycle-update-view', function( e, opts, slideOpts ) {
    if ( slideOpts.hash && ( '#' + slideOpts.hash ) != window.location.hash ) {
        opts._hashFence = true;
        window.location.hash = slideOpts.hash;
    }
});

$(document).on( 'cycle-destroyed', function( e, opts) {
    if ( opts._onHashChange ) {
        $( window ).off( 'hashchange', opts._onHashChange );
    }
});

function onHashChange( opts, setStartingSlide ) {
    var hash;
    if ( opts._hashFence ) {
        opts._hashFence = false;
        return;
    }
    
    hash = window.location.hash.substring(1);

    opts.slides.each(function(i) {
        if ( $(this).data( 'cycle-hash' ) == hash ) {
            if ( setStartingSlide === true ) {
                opts.startingSlide = i;
            }
            else {
                var fwd = opts.currSlide < i;
                opts.nextSlide = i;
                opts.API.prepareTx( true, fwd );
            }
            return false;
        }
    });
}

})(jQuery);

/*! loader plugin for Cycle2;  version: 20131020 */
(function($) {
"use strict";

$.extend($.fn.cycle.defaults, {
    loader: false
});

$(document).on( 'cycle-bootstrap', function( e, opts ) {
    var addFn;

    if ( !opts.loader )
        return;

    // override API.add for this slideshow
    addFn = opts.API.add;
    opts.API.add = add;

    function add( slides, prepend ) {
        var slideArr = [];
        if ( $.type( slides ) == 'string' )
            slides = $.trim( slides );
        else if ( $.type( slides) === 'array' ) {
            for (var i=0; i < slides.length; i++ )
                slides[i] = $(slides[i])[0];
        }

        slides = $( slides );
        var slideCount = slides.length;

        if ( ! slideCount )
            return;

        opts.eventualSlideCount = opts.slideCount + slideCount;

        slides.hide().appendTo('body').each(function(i) { // appendTo fixes #56
            var count = 0;
            var slide = $(this);
            var images = slide.is('img') ? slide : slide.find('img');
            slide.data('index', i);
            // allow some images to be marked as unimportant (and filter out images w/o src value)
            images = images.filter(':not(.cycle-loader-ignore)').filter(':not([src=""])');
            if ( ! images.length ) {
                --slideCount;
                slideArr.push( slide );
                return;
            }

            count = images.length;
            images.each(function() {
                // add images that are already loaded
                if ( this.complete ) {
                    imageLoaded();
                }
                else {
                    $(this).load(function() {
                        imageLoaded();
                    }).error(function() {
                        if ( --count === 0 ) {
                            // ignore this slide
                            opts.API.log('slide skipped; img not loaded:', this.src);
                            if ( --slideCount === 0 && opts.loader == 'wait') {
                                addFn.apply( opts.API, [ slideArr, prepend ] );
                            }
                        }
                    });
                }
            });

            function imageLoaded() {
                if ( --count === 0 ) {
                    --slideCount;
                    addSlide( slide );
                }
            }
        });

        if ( slideCount )
            opts.container.addClass('cycle-loading');
        

        function addSlide( slide ) {
            var curr;
            if ( opts.loader == 'wait' ) {
                slideArr.push( slide );
                if ( slideCount === 0 ) {
                    // #59; sort slides into original markup order
                    slideArr.sort( sorter );
                    addFn.apply( opts.API, [ slideArr, prepend ] );
                    opts.container.removeClass('cycle-loading');
                }
            }
            else {
                curr = $(opts.slides[opts.currSlide]);
                addFn.apply( opts.API, [ slide, prepend ] );
                curr.show();
                opts.container.removeClass('cycle-loading');
            }
        }

        function sorter(a, b) {
            return a.data('index') - b.data('index');
        }
    }
});

})(jQuery);

/*! pager plugin for Cycle2;  version: 20130525 */
(function($) {
"use strict";

$.extend($.fn.cycle.defaults, {
    pager:            '> .cycle-pager',
    pagerActiveClass: 'cycle-pager-active',
    pagerEvent:       'click.cycle',
    pagerTemplate:    '<span>&bull;</span>'
});    

$(document).on( 'cycle-bootstrap', function( e, opts, API ) {
    // add method to API
    API.buildPagerLink = buildPagerLink;
});

$(document).on( 'cycle-slide-added', function( e, opts, slideOpts, slideAdded ) {
    if ( opts.pager ) {
        opts.API.buildPagerLink ( opts, slideOpts, slideAdded );
        opts.API.page = page;
    }
});

$(document).on( 'cycle-slide-removed', function( e, opts, index, slideRemoved ) {
    if ( opts.pager ) {
        var pagers = opts.API.getComponent( 'pager' );
        pagers.each(function() {
            var pager = $(this);
            $( pager.children()[index] ).remove();
        });
    }
});

$(document).on( 'cycle-update-view', function( e, opts, slideOpts ) {
    var pagers;

    if ( opts.pager ) {
        pagers = opts.API.getComponent( 'pager' );
        pagers.each(function() {
           $(this).children().removeClass( opts.pagerActiveClass )
            .eq( opts.currSlide ).addClass( opts.pagerActiveClass );
        });
    }
});

$(document).on( 'cycle-destroyed', function( e, opts ) {
    var pager = opts.API.getComponent( 'pager' );

    if ( pager ) {
        pager.children().off( opts.pagerEvent ); // #202
        if ( opts.pagerTemplate )
            pager.empty();
    }
});

function buildPagerLink( opts, slideOpts, slide ) {
    var pagerLink;
    var pagers = opts.API.getComponent( 'pager' );
    pagers.each(function() {
        var pager = $(this);
        if ( slideOpts.pagerTemplate ) {
            var markup = opts.API.tmpl( slideOpts.pagerTemplate, slideOpts, opts, slide[0] );
            pagerLink = $( markup ).appendTo( pager );
        }
        else {
            pagerLink = pager.children().eq( opts.slideCount - 1 );
        }
        pagerLink.on( opts.pagerEvent, function(e) {
            e.preventDefault();
            opts.API.page( pager, e.currentTarget);
        });
    });
}

function page( pager, target ) {
    /*jshint validthis:true */
    var opts = this.opts();
    if ( opts.busy && ! opts.manualTrump )
        return;

    var index = pager.children().index( target );
    var nextSlide = index;
    var fwd = opts.currSlide < nextSlide;
    if (opts.currSlide == nextSlide) {
        return; // no op, clicked pager for the currently displayed slide
    }
    opts.nextSlide = nextSlide;
    opts.API.prepareTx( true, fwd );
    opts.API.trigger('cycle-pager-activated', [opts, pager, target ]);
}

})(jQuery);


/*! prevnext plugin for Cycle2;  version: 20130709 */
(function($) {
"use strict";

$.extend($.fn.cycle.defaults, {
    next:           '> .cycle-next',
    nextEvent:      'click.cycle',
    disabledClass:  'disabled',
    prev:           '> .cycle-prev',
    prevEvent:      'click.cycle',
    swipe:          false
});

$(document).on( 'cycle-initialized', function( e, opts ) {
    opts.API.getComponent( 'next' ).on( opts.nextEvent, function(e) {
        e.preventDefault();
        opts.API.next();
    });

    opts.API.getComponent( 'prev' ).on( opts.prevEvent, function(e) {
        e.preventDefault();
        opts.API.prev();
    });

    if ( opts.swipe ) {
        var nextEvent = opts.swipeVert ? 'swipeUp.cycle' : 'swipeLeft.cycle swipeleft.cycle';
        var prevEvent = opts.swipeVert ? 'swipeDown.cycle' : 'swipeRight.cycle swiperight.cycle';
        opts.container.on( nextEvent, function(e) {
            opts.API.next();
        });
        opts.container.on( prevEvent, function() {
            opts.API.prev();
        });
    }
});

$(document).on( 'cycle-update-view', function( e, opts, slideOpts, currSlide ) {
    if ( opts.allowWrap )
        return;

    var cls = opts.disabledClass;
    var next = opts.API.getComponent( 'next' );
    var prev = opts.API.getComponent( 'prev' );
    var prevBoundry = opts._prevBoundry || 0;
    var nextBoundry = (opts._nextBoundry !== undefined)?opts._nextBoundry:opts.slideCount - 1;

    if ( opts.currSlide == nextBoundry )
        next.addClass( cls ).prop( 'disabled', true );
    else
        next.removeClass( cls ).prop( 'disabled', false );

    if ( opts.currSlide === prevBoundry )
        prev.addClass( cls ).prop( 'disabled', true );
    else
        prev.removeClass( cls ).prop( 'disabled', false );
});


$(document).on( 'cycle-destroyed', function( e, opts ) {
    opts.API.getComponent( 'prev' ).off( opts.nextEvent );
    opts.API.getComponent( 'next' ).off( opts.prevEvent );
    opts.container.off( 'swipeleft.cycle swiperight.cycle swipeLeft.cycle swipeRight.cycle swipeUp.cycle swipeDown.cycle' );
});

})(jQuery);

/*! progressive loader plugin for Cycle2;  version: 20130315 */
(function($) {
"use strict";

$.extend($.fn.cycle.defaults, {
    progressive: false
});

$(document).on( 'cycle-pre-initialize', function( e, opts ) {
    if ( !opts.progressive )
        return;

    var API = opts.API;
    var nextFn = API.next;
    var prevFn = API.prev;
    var prepareTxFn = API.prepareTx;
    var type = $.type( opts.progressive );
    var slides, scriptEl;

    if ( type == 'array' ) {
        slides = opts.progressive;
    }
    else if ($.isFunction( opts.progressive ) ) {
        slides = opts.progressive( opts );
    }
    else if ( type == 'string' ) {
        scriptEl = $( opts.progressive );
        slides = $.trim( scriptEl.html() );
        if ( !slides )
            return;
        // is it json array?
        if ( /^(\[)/.test( slides ) ) {
            try {
                slides = $.parseJSON( slides );
            }
            catch(err) {
                API.log( 'error parsing progressive slides', err );
                return;
            }
        }
        else {
            // plain text, split on delimeter
            slides = slides.split( new RegExp( scriptEl.data('cycle-split') || '\n') );
            
            // #95; look for empty slide
            if ( ! slides[ slides.length - 1 ] )
                slides.pop();
        }
    }



    if ( prepareTxFn ) {
        API.prepareTx = function( manual, fwd ) {
            var index, slide;

            if ( manual || slides.length === 0 ) {
                prepareTxFn.apply( opts.API, [ manual, fwd ] );
                return;
            }

            if ( fwd && opts.currSlide == ( opts.slideCount-1) ) {
                slide = slides[ 0 ];
                slides = slides.slice( 1 );
                opts.container.one('cycle-slide-added', function(e, opts ) {
                    setTimeout(function() {
                        opts.API.advanceSlide( 1 );
                    },50);
                });
                opts.API.add( slide );
            }
            else if ( !fwd && opts.currSlide === 0 ) {
                index = slides.length-1;
                slide = slides[ index ];
                slides = slides.slice( 0, index );
                opts.container.one('cycle-slide-added', function(e, opts ) {
                    setTimeout(function() {
                        opts.currSlide = 1;
                        opts.API.advanceSlide( -1 );
                    },50);
                });
                opts.API.add( slide, true );
            }
            else {
                prepareTxFn.apply( opts.API, [ manual, fwd ] );
            }
        };
    }

    if ( nextFn ) {
        API.next = function() {
            var opts = this.opts();
            if ( slides.length && opts.currSlide == ( opts.slideCount - 1 ) ) {
                var slide = slides[ 0 ];
                slides = slides.slice( 1 );
                opts.container.one('cycle-slide-added', function(e, opts ) {
                    nextFn.apply( opts.API );
                    opts.container.removeClass('cycle-loading');
                });
                opts.container.addClass('cycle-loading');
                opts.API.add( slide );
            }
            else {
                nextFn.apply( opts.API );    
            }
        };
    }
    
    if ( prevFn ) {
        API.prev = function() {
            var opts = this.opts();
            if ( slides.length && opts.currSlide === 0 ) {
                var index = slides.length-1;
                var slide = slides[ index ];
                slides = slides.slice( 0, index );
                opts.container.one('cycle-slide-added', function(e, opts ) {
                    opts.currSlide = 1;
                    opts.API.advanceSlide( -1 );
                    opts.container.removeClass('cycle-loading');
                });
                opts.container.addClass('cycle-loading');
                opts.API.add( slide, true );
            }
            else {
                prevFn.apply( opts.API );
            }
        };
    }
});

})(jQuery);

/*! tmpl plugin for Cycle2;  version: 20121227 */
(function($) {
"use strict";

$.extend($.fn.cycle.defaults, {
    tmplRegex: '{{((.)?.*?)}}'
});

$.extend($.fn.cycle.API, {
    tmpl: function( str, opts /*, ... */) {
        var regex = new RegExp( opts.tmplRegex || $.fn.cycle.defaults.tmplRegex, 'g' );
        var args = $.makeArray( arguments );
        args.shift();
        return str.replace(regex, function(_, str) {
            var i, j, obj, prop, names = str.split('.');
            for (i=0; i < args.length; i++) {
                obj = args[i];
                if ( ! obj )
                    continue;
                if (names.length > 1) {
                    prop = obj;
                    for (j=0; j < names.length; j++) {
                        obj = prop;
                        prop = prop[ names[j] ] || str;
                    }
                } else {
                    prop = obj[str];
                }

                if ($.isFunction(prop))
                    return prop.apply(obj, args);
                if (prop !== undefined && prop !== null && prop != str)
                    return prop;
            }
            return str;
        });
    }
});    

})(jQuery);


/*! carousel transition plugin for Cycle2;  version: 20130528 */
(function ($) {
    "use strict";

    $(document).on('cycle-bootstrap', function (e, opts, API) {
        if (opts.fx !== 'carousel')
            return;

        API.getSlideIndex = function (el) {
            var slides = this.opts()._carouselWrap.children();
            var i = slides.index(el);
            return i % slides.length;
        };

        // override default 'next' function
        API.next = function () {
            var count = opts.reverse ? -1 : 1;
            if (opts.allowWrap === false && (opts.currSlide + count) > opts.slideCount - opts.carouselVisible)
                return;
            opts.API.advanceSlide(count);
            opts.API.trigger('cycle-next', [opts]).log('cycle-next');
        };

    });


    $.fn.cycle.transitions.carousel = {
        // transition API impl
        preInit: function (opts) {
            opts.hideNonActive = false;

            opts.container.on('cycle-destroyed', $.proxy(this.onDestroy, opts.API));
            // override default API implementation
            opts.API.stopTransition = this.stopTransition;

            // issue #10
            for (var i = 0; i < opts.startingSlide; i++) {
                opts.container.append(opts.slides[0]);
            }
        },

        // transition API impl
        postInit: function (opts) {
            var i, j, slide, pagerCutoffIndex, wrap;
            var vert = opts.carouselVertical;
            if (opts.carouselVisible && opts.carouselVisible > opts.slideCount)
                opts.carouselVisible = opts.slideCount - 1;
            var visCount = opts.carouselVisible || opts.slides.length;
            var slideCSS = { display: vert ? 'block' : 'inline-block', position: 'static' };

            // required styles
            opts.container.css({ position: 'relative', overflow: 'hidden' });
            opts.slides.css(slideCSS);

            opts._currSlide = opts.currSlide;

            // wrap slides in a div; this div is what is animated
            wrap = $('<div class="cycle-carousel-wrap"></div>')
                .prependTo(opts.container)
                .css({ margin: 0, padding: 0, top: 0, left: 0, position: 'absolute' })
                .append(opts.slides);

            opts._carouselWrap = wrap;

            if (!vert)
                wrap.css('white-space', 'nowrap');

            if (opts.allowWrap !== false) {
                // prepend and append extra slides so we don't see any empty space when we
                // near the end of the carousel.  for fluid containers, add even more clones
                // so there is plenty to fill the screen
                // @todo: optimzie this based on slide sizes

                for (j = 0; j < (opts.carouselVisible === undefined ? 2 : 1) ; j++) {
                    for (i = 0; i < opts.slideCount; i++) {
                        wrap.append(opts.slides[i].cloneNode(true));
                    }
                    i = opts.slideCount;
                    while (i--) { // #160, #209
                        wrap.prepend(opts.slides[i].cloneNode(true));
                    }
                }

                wrap.find('.cycle-slide-active').removeClass('cycle-slide-active');
                opts.slides.eq(opts.startingSlide).addClass('cycle-slide-active');
            }

            if (opts.pager && opts.allowWrap === false) {
                // hide "extra" pagers
                pagerCutoffIndex = opts.slideCount - visCount;
                $(opts.pager).children().filter(':gt(' + pagerCutoffIndex + ')').hide();
            }

            opts._nextBoundry = opts.slideCount - opts.carouselVisible;

            this.prepareDimensions(opts);
        },

        prepareDimensions: function (opts) {
            var dim, offset, pagerCutoffIndex, tmp;
            var vert = opts.carouselVertical;
            var visCount = opts.carouselVisible || opts.slides.length;

            if (opts.carouselFluid && opts.carouselVisible) {
                if (!opts._carouselResizeThrottle) {
                    // fluid container AND fluid slides; slides need to be resized to fit container
                    this.fluidSlides(opts);
                }
            }
            else if (opts.carouselVisible && opts.carouselSlideDimension) {
                dim = visCount * opts.carouselSlideDimension;
                opts.container[vert ? 'height' : 'width'](dim);
            }
            else if (opts.carouselVisible) {
                dim = visCount * $(opts.slides[0])[vert ? 'outerHeight' : 'outerWidth'](true);
                opts.container[vert ? 'height' : 'width'](dim);
            }
            // else {
            //     // fluid; don't size the container
            // }

            offset = (opts.carouselOffset || 0);
            if (opts.allowWrap !== false) {
                if (opts.carouselSlideDimension) {
                    offset -= ((opts.slideCount + opts.currSlide) * opts.carouselSlideDimension);
                }
                else {
                    // calculate offset based on actual slide dimensions
                    tmp = opts._carouselWrap.children();
                    for (var j = 0; j < (opts.slideCount + opts.currSlide) ; j++) {
                        offset -= $(tmp[j])[vert ? 'outerHeight' : 'outerWidth'](true);
                    }
                }
            }

            opts._carouselWrap.css(vert ? 'top' : 'left', offset);
        },

        fluidSlides: function (opts) {
            var timeout;
            var slide = opts.slides.eq(0);
            var adjustment = slide.outerWidth() - slide.width();
            var prepareDimensions = this.prepareDimensions;

            // throttle resize event
            $(window).on('resize', resizeThrottle);

            opts._carouselResizeThrottle = resizeThrottle;
            onResize();

            function resizeThrottle() {
                clearTimeout(timeout);
                timeout = setTimeout(onResize, 20);
            }

            function onResize() {
                opts._carouselWrap.stop(false, true);
                var slideWidth = opts.container.width() / opts.carouselVisible;
                slideWidth = Math.ceil(slideWidth - adjustment);
                opts._carouselWrap.children().width(slideWidth);
                if (opts._sentinel)
                    opts._sentinel.width(slideWidth);
                prepareDimensions(opts);
            }
        },

        // transition API impl
        transition: function (opts, curr, next, fwd, callback) {
            var moveBy, props = {};
            var hops = opts.nextSlide - opts.currSlide;
            var vert = opts.carouselVertical;
            var speed = opts.speed;

            // handle all the edge cases for wrapping & non-wrapping
            if (opts.allowWrap === false) {
                fwd = hops > 0;
                var currSlide = opts._currSlide;
                var maxCurr = opts.slideCount - opts.carouselVisible;
                if (hops > 0 && opts.nextSlide > maxCurr && currSlide == maxCurr) {
                    hops = 0;
                }
                else if (hops > 0 && opts.nextSlide > maxCurr) {
                    hops = opts.nextSlide - currSlide - (opts.nextSlide - maxCurr);
                }
                else if (hops < 0 && opts.currSlide > maxCurr && opts.nextSlide > maxCurr) {
                    hops = 0;
                }
                else if (hops < 0 && opts.currSlide > maxCurr) {
                    hops += opts.currSlide - maxCurr;
                }
                else
                    currSlide = opts.currSlide;

                moveBy = this.getScroll(opts, vert, currSlide, hops);
                opts.API.opts()._currSlide = opts.nextSlide > maxCurr ? maxCurr : opts.nextSlide;
            }
            else {
                if (fwd && opts.nextSlide === 0) {
                    // moving from last slide to first
                    moveBy = this.getDim(opts, opts.currSlide, vert);
                    callback = this.genCallback(opts, fwd, vert, callback);
                }
                else if (!fwd && opts.nextSlide == opts.slideCount - 1) {
                    // moving from first slide to last
                    moveBy = this.getDim(opts, opts.currSlide, vert);
                    callback = this.genCallback(opts, fwd, vert, callback);
                }
                else {
                    moveBy = this.getScroll(opts, vert, opts.currSlide, hops);
                }
            }

            props[vert ? 'top' : 'left'] = fwd ? ("-=" + moveBy) : ("+=" + moveBy);

            // throttleSpeed means to scroll slides at a constant rate, rather than
            // a constant speed
            if (opts.throttleSpeed)
                speed = (moveBy / $(opts.slides[0])[vert ? 'height' : 'width']()) * opts.speed;

            opts._carouselWrap.animate(props, speed, opts.easing, callback);
        },

        getDim: function (opts, index, vert) {
            var slide = $(opts.slides[index]);
            return slide[vert ? 'outerHeight' : 'outerWidth'](true);
        },

        getScroll: function (opts, vert, currSlide, hops) {
            var i, moveBy = 0;

            if (hops > 0) {
                for (i = currSlide; i < currSlide + hops; i++)
                    moveBy += this.getDim(opts, i, vert);
            }
            else {
                for (i = currSlide; i > currSlide + hops; i--)
                    moveBy += this.getDim(opts, i, vert);
            }
            return moveBy;
        },

        genCallback: function (opts, fwd, vert, callback) {
            // returns callback fn that resets the left/top wrap position to the "real" slides
            return function () {
                var pos = $(opts.slides[opts.nextSlide]).position();
                var offset = 0 - pos[vert ? 'top' : 'left'] + (opts.carouselOffset || 0);
                opts._carouselWrap.css(opts.carouselVertical ? 'top' : 'left', offset);
                callback();
            };
        },

        // core API override
        stopTransition: function () {
            var opts = this.opts();
            opts.slides.stop(false, true);
            opts._carouselWrap.stop(false, true);
        },

        // core API supplement
        onDestroy: function (e) {
            var opts = this.opts();
            if (opts._carouselResizeThrottle)
                $(window).off('resize', opts._carouselResizeThrottle);
            opts.slides.prependTo(opts.container);
            opts._carouselWrap.remove();
        }
    };

})(jQuery);


/*! swipe plugin for Cycle2;  version: 20121120 */
(function ($) {
    "use strict";

    // this script adds support for touch events.  the logic is lifted from jQuery Mobile.
    // if you have jQuery Mobile installed, you do NOT need this script

    var supportTouch = 'ontouchend' in document;

    $.event.special.swipe = $.event.special.swipe || {
        scrollSupressionThreshold: 10,   // More than this horizontal displacement, and we will suppress scrolling.
        durationThreshold: 1000,         // More time than this, and it isn't a swipe.
        horizontalDistanceThreshold: 30, // Swipe horizontal displacement must be more than this.
        verticalDistanceThreshold: 75,   // Swipe vertical displacement must be less than this.

        setup: function () {
            var $this = $(this);

            $this.bind('touchstart', function (event) {
                var data = event.originalEvent.touches ? event.originalEvent.touches[0] : event;
                var stop, start = {
                    time: (new Date()).getTime(),
                    coords: [data.pageX, data.pageY],
                    origin: $(event.target)
                };

                function moveHandler(event) {
                    if (!start)
                        return;

                    var data = event.originalEvent.touches ? event.originalEvent.touches[0] : event;

                    stop = {
                        time: (new Date()).getTime(),
                        coords: [data.pageX, data.pageY]
                    };

                    // prevent scrolling
                    if (Math.abs(start.coords[0] - stop.coords[0]) > $.event.special.swipe.scrollSupressionThreshold) {
                        event.preventDefault();
                    }
                }

                $this.bind('touchmove', moveHandler)
                    .one('touchend', function (event) {
                        $this.unbind('touchmove', moveHandler);

                        if (start && stop) {
                            if (stop.time - start.time < $.event.special.swipe.durationThreshold &&
                                    Math.abs(start.coords[0] - stop.coords[0]) > $.event.special.swipe.horizontalDistanceThreshold &&
                                    Math.abs(start.coords[1] - stop.coords[1]) < $.event.special.swipe.verticalDistanceThreshold) {

                                start.origin.trigger("swipe")
                                    .trigger(start.coords[0] > stop.coords[0] ? "swipeleft" : "swiperight");
                            }
                        }
                        start = stop = undefined;
                    });
            });
        }
    };

    $.event.special.swipeleft = $.event.special.swipeleft || {
        setup: function () {
            $(this).bind('swipe', $.noop);
        }
    };
    $.event.special.swiperight = $.event.special.swiperight || $.event.special.swipeleft;

})(jQuery);

/**** Plugin Form ****/
var styleForm = function () {
    return {
        init: function ($forms, not) {
            //this.checkbox($forms.find('input[type=checkbox]').not(not));
            //this.radio($forms.find('input[type=radio]').not(not));
            this.select($forms.find('select').not(not));
            //this.file($forms.find('input[type=file]').not(not));
            //this.inputFile($forms.find('input[type=file]'))

            $forms.find('button[type=reset], .btn-reset').click(function (e) {
                e.preventDefault();
                $forms[0].reset();
                styleForm.reloadSelect($forms);
            });

            return this;
        },
        file: function ($file, recipient) {
            $aFile = new Array();
            $file.each(function (i) {
                $aFile[i] = $(this).css('opacity', 0);

                //create custom control container
                $aFile[i]['upload'] = $('<div class="file-input"></div>');
                //create custom control feedback
                $aFile[i]['uploadFeedback'] = $('<span class="file-input-feedback" aria-hidden="true">No file selected...</span>').appendTo($aFile[i]['upload']);
                //create custom control button
                $aFile[i]['uploadButton'] = $('<span class="file-input-button" aria-hidden="true">Browse</span>').appendTo($aFile[i]['upload']);


                //on mousemove, keep file input under the cursor to steal click 
                $aFile[i]['upload'].insertAfter($aFile[i]); //insert after the input

                $aFile[i].appendTo($aFile[i]['upload']);

                $aFile[i].addClass('file-input')
                    .focus(function () {
                        $aFile[i]['upload'].addClass('file-input-focus');
                        $aFile[i].data('val', $aFile[i].val());
                    })
                    .blur(function () {
                        $aFile[i].removeClass('file-input');
                        $(this).trigger('checkChange');
                    })
                    .bind('checkChange', function () {
                        if ($aFile[i].val() && $aFile[i].val() != $aFile[i].data('val')) {
                            $aFile[i].trigger('change');
                        }
                    })
                    .bind('change', function () {
                        //get file name
                        var fileName = $(this).val().split(/\\/).pop();
                        //get file extension
                        var fileExt = 'file-input-ext-' + fileName.split('.').pop().toLowerCase();
                        //update the feedback
                        $aFile[i]['uploadFeedback']
                            .text(fileName) //set feedback text to filename
                            .removeClass($aFile[i]['uploadFeedback'].data('fileExt') || '') //remove any existing file extension class
                            .addClass(fileExt) //add file extension class
                            .data('fileExt', fileExt) //store file extension for class removal on next change
                            .addClass('file-input-feedback-populated'); //add class to show populated state
                        //change text of button
                        $aFile[i]['uploadButton'].text('Change');
                    })
                    .click(function () { //for IE and Opera, make sure change fires after choosing a file, using an async callback
                        $aFile[i].data('val', $aFile[i].val());
                        setTimeout(function () {
                            $aFile[i].trigger('checkChange');
                        }, 100);
                    });
            });
        },

        checkbox: function ($checkbox) {
            var $html, className, check, $el;
            var $checkboxArr = new Array;
            var $elArr = new Array;
            $checkbox.each(function (i) {
                $el = $(this);
                $checkboxArr[i] = $el;

                className = 'sCheckbox ';
                className += ($el.attr('class') != 'undefined') ? $el.attr('class') : '';
                className += ($el.is(':checked')) ? ' checked' : '';

                $el.hide(0);

                $html = $('<div class="' + className + '" id="' + $el.attr('name').replace(/$/gi, '_') + '"><span class="check"></span></div>');
                $elArr[i] = $html;

                $el.before($html);

                // Verifica se checkbox esta dentro de label, se estiver, label tera evento onclick, senao, elementro criado tera
                var $label = $('label[for="' + $el.attr('id') + '"]');
                if ($el.parent().is('label'))
                    $click = $el.parent();
                else if($label.length > 0)
                    $click = $($label).add($html);
                else
                    $click = $html;

                $click.on('click toggleCheck', function (e) {
                    e.preventDefault();
                    check = ($checkboxArr[i].is(':checked')) ? false : true;

                    //$checkboxArr[i].get(0).checked = check;
                    $checkboxArr[i].trigger('click').attr('checked', check);

                    if (check)
                        $elArr[i].addClass('checked');
                    else
                        $elArr[i].removeClass('checked');
                });
                $checkboxArr[i].on({
                    checked: function (e, checked) {
                        $checkboxArr[i].prop('checked', checked);
                        $elArr[i].removeClass('checked');
                    },
                    toggleCheck: function () {
                        check = ($checkboxArr[i].is(':checked')) ? false : true;

                        //$checkboxArr[i].get(0).checked = check;
                        $checkboxArr[i].trigger('click').attr('checked', check);

                        if (check)
                            $elArr[i].addClass('checked');
                        else
                            $elArr[i].removeClass('checked');
                    }
                });
            });
        },
        radio: function ($radio) {
            var $radioArr = new Array;
            var $elArr = new Array;
            $radio.each(function (i) {
                $radioArr[i] = $(this);
                className = 'sRadio ' + $radioArr[i].attr('name').replace(/\$/gi, '_') + ' ';
                className += ($radioArr[i].attr('class') != 'undefined') ? $radioArr[i].attr('class') : '';
                className += ($radioArr[i].is(':checked')) ? ' checked' : '';

                $radioArr[i].hide(0);

                $html = $('<div class="' + className + '" id="' + $radioArr[i].attr('name').replace(/\$/gi, '_') + i + '"><span class="check"></span></div>');
                $elArr[i] = $html;

                $radioArr[i].before($html).trigger('onclick');

                // Verifica se checkbox esta dentro de label, se estiver, label tera evento onclick, senao, elementro criado tera
                $click = ($radioArr[i].parent().is('label') || $radioArr[i].parent().find('label').length > 0) ? $radioArr[i].parent() : $html;

                $click.on({
                    click: function (e) {
                        e.preventDefault();

                        $radio.attr('checked', false);
                        $('.' + $radioArr[i].attr('name').replace(/\$/gi, '_')).removeClass('checked');

                        $radioArr[i].attr('checked', true);

                        $elArr[i].addClass('checked');
                    },
                    'mouseover focus': function () {
                        $elArr[i].toggleClass('hover');
                    },
                    'mouseout focusout': function () {
                        $elArr[i].toggleClass('hover');
                    }
                });
            });
        },
        select: function ($select) {
            var $selectArr = new Array;
            var $htmlArr = new Array;
            var nSelect = $select.length;

            $select.each(function (i) {
                $selectArr[i] = $(this).hide();
                var tSelected = ($selectArr[i].find('option:checked').length > 0) ? $selectArr[i].find('option:checked') : $selectArr[i].find('option').eq(0);
                var resizeOptions = false;

                className = 'sSelect ';
                className += ($selectArr[i].attr('class') != 'undefined') ? $selectArr[i].attr('class') : '';
                className += ($selectArr[i].attr('disabled')) ? ' disabled' : '';
                $htmlArr[i] = $("<div class='" + className + "' id='" + $selectArr[i].attr('name') + "' style='z-index: " + (nSelect - i) + "'>" +
                        "   <div class='select-arrow'></div>" +
						"	<a href='#'>" +
						"		<span class='select'>" + tSelected.text() + "</span>" +
						"		<span class='options'></span>" +
						"	</a>" +
						"</div>");

                $selectArr[i].find('option').each(function () {
                    $htmlArr[i].find('.options').css('display', 'none').append(
						$('<span>' + $(this).text() + '</span>')
							.attr('data-value', $(this).val())
							.addClass(($(this).val() == tSelected.val()) ? 'selected' : '')
					);
                });

                $selectArr[i].before($htmlArr[i]);

                $htmlArr[i].find('a').css('width', $htmlArr[i].width());
                if($htmlArr[i].css('width').indexOf('%') > 0) resizeOptions = true;
                
                $htmlArr[i].on({
                    mouseover: function () {
                        $(this).addClass('hover');
                    },
                    mouseout: function () {
                        $(this).removeClass('hover');
                    },
                    click: function (e) {
                        e.preventDefault();
                        var $this = $(this);
                        var $nextObj = $(this).find('.selected').next();

                        if (!$this.hasClass('disabled')) {
                            if(resizeOptions)
                                $htmlArr[i].find('a').css('width', $htmlArr[i].width() - (parseFloat($htmlArr[i].css('padding-left')) * 2));
                            console.log($htmlArr[i].width(), parseFloat($htmlArr[i].css('padding-left')) * 2)

                            $this.addClass('open').find('.options').slideDown(500, function () {
                                $(document).one('click', function () {
                                    $htmlArr[i].removeClass('open').find('.options').hide();
                                });

                                // Scrolla o select para o item seguinte do que está relacionado
                                $this.find('.options').scrollTop($nextObj.index() * $nextObj.height());

                            });
                        }

                    },
                    disabled: function () {
                        $(this).addClass('disabled');
                        $selectArr[i].attr('disabled', 'disabled');
                    },
                    enabled: function () {
                        $(this).removeClass('disabled');
                        $selectArr[i].removeAttr('disabled');
                    }
                });

                $htmlArr[i].find('.options span').on('click select', function () {
                    var $elLi = $(this);

                    $selectArr[i].val($elLi.data('value')).trigger('change');

                    $htmlArr[i]
						.find('.selected').removeClass('selected').end()
						.find('span.select').text($elLi.addClass('selected').text());
                })

                // Desabilita dragging de span caso esteja com barra de rolagem // Firefox
                $htmlArr[i].find('.options')[0].draggable = false;
                $htmlArr[i].find('.options')[0].onmousedown = function (event) {
                    return false;
                };

            });
        },
        reloadSelect: function ($forms) {
            $forms.find('select').each(function () {
                var $select = $(this);
                newSelected = ($select.find('option:checked').length > 0) ? $select.find('option:checked').text() : $select.find('option').eq(0).text();
                $('#' + $select.attr('name')).find('.select').text(newSelected);
            });
        },
        reformSelect: function ($forms) {
            $forms.find('.sSelect').remove();
            this.select($forms.find('select'));
        }
    }
}();
/*
 * jquery.coords
 * https://github.com/ducksboard/gridster.js
 * https://github.com/dustmoo/gridster.js
 * Copyright (c) 2012 ducksboard
 * Licensed under the MIT licenses.
 */

; (function ($, window, document, undefined) {
    /**
    * Creates objects with coordinates (x1, y1, x2, y2, cx, cy, width, height)
    * to simulate DOM elements on the screen.
    * Coords is used by Gridster to create a faux grid with any DOM element can
    * collide.
    *
    * @class Coords
    * @param {HTMLElement|Object} obj The jQuery HTMLElement or a object with: left,
    * top, width and height properties.
    * @return {Object} Coords instance.
    * @constructor
    */
    function Coords(obj) {
        if (obj[0] && $.isPlainObject(obj[0])) {
            this.data = obj[0];
        } else {
            this.el = obj;
        }

        this.isCoords = true;
        this.coords = {};
        this.init();
        return this;
    }


    var fn = Coords.prototype;


    fn.init = function () {
        this.set();
        this.original_coords = this.get();
    };


    fn.set = function (update, not_update_offsets) {
        var el = this.el;

        if (el && !update) {
            this.data = el.offset();
            this.data.width = el.width();
            this.data.height = el.height();
        }

        if (el && update && !not_update_offsets) {
            var offset = el.offset();
            this.data.top = offset.top;
            this.data.left = offset.left;
        }

        var d = this.data;

        this.coords.x1 = d.left;
        this.coords.y1 = d.top;
        this.coords.x2 = d.left + d.width;
        this.coords.y2 = d.top + d.height;
        this.coords.cx = d.left + (d.width / 2);
        this.coords.cy = d.top + (d.height / 2);
        this.coords.width = d.width;
        this.coords.height = d.height;
        this.coords.el = el || false;

        return this;
    };


    fn.update = function (data) {
        if (!data && !this.el) {
            return this;
        }

        if (data) {
            var new_data = $.extend({}, this.data, data);
            this.data = new_data;
            return this.set(true, true);
        }

        this.set(true);
        return this;
    };


    fn.get = function () {
        return this.coords;
    };


    //jQuery adapter
    $.fn.coords = function () {
        if (this.data('coords')) {
            return this.data('coords');
        }

        var ins = new Coords(this, arguments[0]);
        this.data('coords', ins);
        return ins;
    };

}(jQuery, window, document));

/*
 * jquery.collision
 * https://github.com/ducksboard/gridster.js
 *
 * Copyright (c) 2012 ducksboard
 * Licensed under the MIT licenses.
 */

; (function ($, window, document, undefined) {

    var defaults = {
        colliders_context: document.body
        // ,on_overlap: function(collider_data){},
        // on_overlap_start : function(collider_data){},
        // on_overlap_stop : function(collider_data){}
    };


    /**
    * Detects collisions between a DOM element against other DOM elements or
    * Coords objects.
    *
    * @class Collision
    * @uses Coords
    * @param {HTMLElement} el The jQuery wrapped HTMLElement.
    * @param {HTMLElement|Array} colliders Can be a jQuery collection
    *  of HTMLElements or an Array of Coords instances.
    * @param {Object} [options] An Object with all options you want to
    *        overwrite:
    *   @param {Function} [options.on_overlap_start] Executes a function the first
    *    time each `collider ` is overlapped.
    *   @param {Function} [options.on_overlap_stop] Executes a function when a
    *    `collider` is no longer collided.
    *   @param {Function} [options.on_overlap] Executes a function when the
    * mouse is moved during the collision.
    * @return {Object} Collision instance.
    * @constructor
    */
    function Collision(el, colliders, options) {
        this.options = $.extend(defaults, options);
        this.$element = el;
        this.last_colliders = [];
        this.last_colliders_coords = [];
        if (typeof colliders === 'string' || colliders instanceof jQuery) {
            this.$colliders = $(colliders,
                 this.options.colliders_context).not(this.$element);
        } else {
            this.colliders = $(colliders);
        }

        this.init();
    }


    var fn = Collision.prototype;


    fn.init = function () {
        this.find_collisions();
    };


    fn.overlaps = function (a, b) {
        var x = false;
        var y = false;

        if ((b.x1 >= a.x1 && b.x1 <= a.x2) ||
            (b.x2 >= a.x1 && b.x2 <= a.x2) ||
            (a.x1 >= b.x1 && a.x2 <= b.x2)
        ) { x = true; }

        if ((b.y1 >= a.y1 && b.y1 <= a.y2) ||
            (b.y2 >= a.y1 && b.y2 <= a.y2) ||
            (a.y1 >= b.y1 && a.y2 <= b.y2)
        ) { y = true; }

        return (x && y);
    };


    fn.detect_overlapping_region = function (a, b) {
        var regionX = '';
        var regionY = '';

        if (a.y1 > b.cy && a.y1 < b.y2) { regionX = 'N'; }
        if (a.y2 > b.y1 && a.y2 < b.cy) { regionX = 'S'; }
        if (a.x1 > b.cx && a.x1 < b.x2) { regionY = 'W'; }
        if (a.x2 > b.x1 && a.x2 < b.cx) { regionY = 'E'; }

        return (regionX + regionY) || 'C';
    };


    fn.calculate_overlapped_area_coords = function (a, b) {
        var x1 = Math.max(a.x1, b.x1);
        var y1 = Math.max(a.y1, b.y1);
        var x2 = Math.min(a.x2, b.x2);
        var y2 = Math.min(a.y2, b.y2);

        return $({
            left: x1,
            top: y1,
            width: (x2 - x1),
            height: (y2 - y1)
        }).coords().get();
    };


    fn.calculate_overlapped_area = function (coords) {
        return (coords.width * coords.height);
    };


    fn.manage_colliders_start_stop = function (new_colliders_coords, start_callback, stop_callback) {
        var last = this.last_colliders_coords;

        for (var i = 0, il = last.length; i < il; i++) {
            if ($.inArray(last[i], new_colliders_coords) === -1) {
                start_callback.call(this, last[i]);
            }
        }

        for (var j = 0, jl = new_colliders_coords.length; j < jl; j++) {
            if ($.inArray(new_colliders_coords[j], last) === -1) {
                stop_callback.call(this, new_colliders_coords[j]);
            }

        }
    };


    fn.find_collisions = function (player_data_coords) {
        var self = this;
        var colliders_coords = [];
        var colliders_data = [];
        var $colliders = (this.colliders || this.$colliders);
        var count = $colliders.length;
        var player_coords = self.$element.coords()
                             .update(player_data_coords || false).get();

        while (count--) {
            var $collider = self.$colliders ?
                             $($colliders[count]) : $colliders[count];
            var $collider_coords_ins = ($collider.isCoords) ?
                $collider : $collider.coords();
            var collider_coords = $collider_coords_ins.get();
            var overlaps = self.overlaps(player_coords, collider_coords);

            if (!overlaps) {
                continue;
            }

            var region = self.detect_overlapping_region(
                player_coords, collider_coords);

            //todo: make this an option
            if (region === 'C') {
                var area_coords = self.calculate_overlapped_area_coords(
                    player_coords, collider_coords);
                var area = self.calculate_overlapped_area(area_coords);
                var collider_data = {
                    area: area,
                    area_coords: area_coords,
                    region: region,
                    coords: collider_coords,
                    player_coords: player_coords,
                    el: $collider
                };

                if (self.options.on_overlap) {
                    self.options.on_overlap.call(this, collider_data);
                }
                colliders_coords.push($collider_coords_ins);
                colliders_data.push(collider_data);
            }
        }

        if (self.options.on_overlap_stop || self.options.on_overlap_start) {
            this.manage_colliders_start_stop(colliders_coords,
                self.options.on_overlap_start, self.options.on_overlap_stop);
        }

        this.last_colliders_coords = colliders_coords;

        return colliders_data;
    };


    fn.get_closest_colliders = function (player_data_coords) {
        var colliders = this.find_collisions(player_data_coords);

        colliders.sort(function (a, b) {
            /* if colliders are being overlapped by the "C" (center) region,
             * we have to set a lower index in the array to which they are placed
             * above in the grid. */
            if (a.region === 'C' && b.region === 'C') {
                if (a.coords.y1 < b.coords.y1 || a.coords.x1 < b.coords.x1) {
                    return -1;
                } else {
                    return 1;
                }
            }

            if (a.area < b.area) {
                return 1;
            }

            return 1;
        });
        return colliders;
    };


    //jQuery adapter
    $.fn.collision = function (collider, options) {
        return new Collision(this, collider, options);
    };


}(jQuery, window, document));

; (function (window, undefined) {
    /* Debounce and throttle functions taken from underscore.js */
    window.debounce = function (func, wait, immediate) {
        var timeout;
        return function () {
            var context = this, args = arguments;
            var later = function () {
                timeout = null;
                if (!immediate) func.apply(context, args);
            };
            if (immediate && !timeout) func.apply(context, args);
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    };


    window.throttle = function (func, wait) {
        var context, args, timeout, throttling, more, result;
        var whenDone = debounce(
            function () { more = throttling = false; }, wait);
        return function () {
            context = this; args = arguments;
            var later = function () {
                timeout = null;
                if (more) func.apply(context, args);
                whenDone();
            };
            if (!timeout) timeout = setTimeout(later, wait);
            if (throttling) {
                more = true;
            } else {
                result = func.apply(context, args);
            }
            whenDone();
            throttling = true;
            return result;
        };
    };

})(window);

/*
 * jquery.draggable
 * https://github.com/ducksboard/gridster.js
 *
 * Copyright (c) 2012 ducksboard
 * Licensed under the MIT licenses.
 */

; (function ($, window, document, undefined) {

    var defaults = {
        items: '.gs_w',
        distance: 1,
        limit: true,
        offset_left: 0,
        autoscroll: true,
        ignore_dragging: ['INPUT', 'TEXTAREA', 'SELECT', 'BUTTON'],
        handle: null
        // drag: function(e){},
        // start : function(e, ui){},
        // stop : function(e){}
    };

    var $window = $(window);
    var isTouch = !!('ontouchstart' in window);
    var pointer_events = {
        start: isTouch ? 'touchstart' : 'mousedown.draggable',
        move: isTouch ? 'touchmove' : 'mousemove.draggable',
        end: isTouch ? 'touchend' : 'mouseup.draggable'
    };

    /**
    * Basic drag implementation for DOM elements inside a container.
    * Provide start/stop/drag callbacks.
    *
    * @class Draggable
    * @param {HTMLElement} el The HTMLelement that contains all the widgets
    *  to be dragged.
    * @param {Object} [options] An Object with all options you want to
    *        overwrite:
    *    @param {HTMLElement|String} [options.items] Define who will
    *     be the draggable items. Can be a CSS Selector String or a
    *     collection of HTMLElements.
    *    @param {Number} [options.distance] Distance in pixels after mousedown
    *     the mouse must move before dragging should start.
    *    @param {Boolean} [options.limit] Constrains dragging to the width of
    *     the container
    *    @param {offset_left} [options.offset_left] Offset added to the item
    *     that is being dragged.
    *    @param {Number} [options.drag] Executes a callback when the mouse is
    *     moved during the dragging.
    *    @param {Number} [options.start] Executes a callback when the drag
    *     starts.
    *    @param {Number} [options.stop] Executes a callback when the drag stops.
    * @return {Object} Returns `el`.
    * @constructor
    */
    
    function Draggable(el, options) {
        this.options = $.extend({}, defaults, options);
        this.$body = $(document.body);
        this.$container = $(el);
        this.$dragitems = $(this.options.items, this.$container);
        this.is_dragging = false;
        this.player_min_left = 0 + this.options.offset_left;
        this.init();
    }

    var fn = Draggable.prototype;

    fn.init = function () {
        this.calculate_positions();
        this.$container.css('position', 'relative');
        this.disabled = false;
        this.events();

        this.on_window_resize = throttle($.proxy(this.calculate_positions, this), 200);
        $(window).bind('resize', this.on_window_resize);
    };

    fn.events = function () {
        this.proxied_on_select_start = $.proxy(this.on_select_start, this);
        this.$container.on('selectstart', this.proxied_on_select_start);

        this.proxied_drag_handler = $.proxy(this.drag_handler, this);
        this.$container.on(pointer_events.start, this.options.items, this.proxied_drag_handler);

        this.proxied_pointer_events_end = $.proxy(function (e) {
            this.is_dragging = false;
            if (this.disabled) { return; }
            this.$body.off(pointer_events.move);
            if (this.drag_start) {
                this.on_dragstop(e);
            }
        }, this);
        this.$body.on(pointer_events.end, this.proxied_pointer_events_end);
    };

    fn.get_actual_pos = function ($el) {
        var pos = $el.position();
        return pos;
    };


    fn.get_mouse_pos = function (e) {
        if (isTouch) {
            var oe = e.originalEvent;
            e = oe.touches.length ? oe.touches[0] : oe.changedTouches[0];
        }

        return {
            left: e.clientX,
            top: e.clientY
        };
    };


    fn.get_offset = function (e) {
        e.preventDefault();
        var mouse_actual_pos = this.get_mouse_pos(e);
        var diff_x = Math.round(
            mouse_actual_pos.left - this.mouse_init_pos.left);
        var diff_y = Math.round(mouse_actual_pos.top - this.mouse_init_pos.top);

        var left = Math.round(this.el_init_offset.left + diff_x - this.baseX);
        var top = Math.round(
            this.el_init_offset.top + diff_y - this.baseY + this.scrollOffset);

        if (this.options.limit) {
            if (left > this.player_max_left) {
                left = this.player_max_left;
            } else if (left < this.player_min_left) {
                left = this.player_min_left;
            }
        }

        return {
            left: left,
            top: top,
            mouse_left: mouse_actual_pos.left,
            mouse_top: mouse_actual_pos.top
        };
    };


    fn.manage_scroll = function (offset) {
        /* scroll document */
        var nextScrollTop;
        var scrollTop = $window.scrollTop();
        var min_window_y = scrollTop;
        var max_window_y = min_window_y + this.window_height;

        var mouse_down_zone = max_window_y - 50;
        var mouse_up_zone = min_window_y + 50;

        var abs_mouse_left = offset.mouse_left;
        var abs_mouse_top = min_window_y + offset.mouse_top;

        var max_player_y = (this.doc_height - this.window_height +
            this.player_height);

        if (abs_mouse_top >= mouse_down_zone) {
            nextScrollTop = scrollTop + 30;
            if (nextScrollTop < max_player_y) {
                $window.scrollTop(nextScrollTop);
                this.scrollOffset = this.scrollOffset + 30;
            }
        }

        if (abs_mouse_top <= mouse_up_zone) {
            nextScrollTop = scrollTop - 30;
            if (nextScrollTop > 0) {
                $window.scrollTop(nextScrollTop);
                this.scrollOffset = this.scrollOffset - 30;
            }
        }
    };


    fn.calculate_positions = function (e) {
        this.window_height = $window.height();
    };


    fn.drag_handler = function (e) {
        var node = e.target.nodeName;
        if (this.disabled || e.which !== 1 && !isTouch) {
            return;
        }

        if (this.ignore_drag(e)) {
            return;
        }

        var self = this;
        var first = true;
        this.$player = $(e.currentTarget);

        this.el_init_pos = this.get_actual_pos(this.$player);
        this.mouse_init_pos = this.get_mouse_pos(e);
        this.offsetY = this.mouse_init_pos.top - this.el_init_pos.top;

        this.on_pointer_events_move = function (mme) {
            var mouse_actual_pos = self.get_mouse_pos(mme);
            var diff_x = Math.abs(
                mouse_actual_pos.left - self.mouse_init_pos.left);
            var diff_y = Math.abs(
                mouse_actual_pos.top - self.mouse_init_pos.top);
            if (!(diff_x > self.options.distance ||
                diff_y > self.options.distance)
                ) {
                return false;
            }

            if (first) {
                first = false;
                self.on_dragstart.call(self, mme);
                return false;
            }

            if (self.is_dragging === true) {
                self.on_dragmove.call(self, mme);
            }

            return false;
        };

        this.$body.on(pointer_events.move, this.on_pointer_events_move);

        return false;
    };


    fn.on_dragstart = function (e) {
        e.preventDefault();
        this.drag_start = true;
        this.is_dragging = true;
        var offset = this.$container.offset();
        this.baseX = Math.round(offset.left);
        this.baseY = Math.round(offset.top);
        this.doc_height = $(document).height();

        if (this.options.helper === 'clone') {
            this.$helper = this.$player.clone()
                .appendTo(this.$container).addClass('helper');
            this.helper = true;
        } else {
            this.helper = false;
        }
        this.scrollOffset = 0;
        this.el_init_offset = this.$player.offset();
        this.player_width = this.$player.width();
        this.player_height = this.$player.height();
        this.player_max_left = (this.$container.width() - this.player_width +
            this.options.offset_left);

        if (this.options.start) {
            this.options.start.call(this.$player, e, {
                helper: this.helper ? this.$helper : this.$player
            });
        }
        return false;
    };


    fn.on_dragmove = function (e) {
        var offset = this.get_offset(e);

        this.options.autoscroll && this.manage_scroll(offset);

        (this.helper ? this.$helper : this.$player).css({
            'position': 'absolute',
            'left': offset.left,
            'top': offset.top
        });

        var ui = {
            'position': {
                'left': offset.left,
                'top': offset.top
            }
        };

        if (this.options.drag) {
            this.options.drag.call(this.$player, e, ui);
        }
        return false;
    };


    fn.on_dragstop = function (e) {
        var offset = this.get_offset(e);
        this.drag_start = false;

        var ui = {
            'position': {
                'left': offset.left,
                'top': offset.top
            }
        };

        if (this.options.stop) {
            this.options.stop.call(this.$player, e, ui);
        }

        if (this.helper) {
            this.$helper.remove();
        }

        return false;
    };

    fn.on_select_start = function (e) {
        if (this.disabled) { return; }

        if (this.ignore_drag(e)) {
            return;
        }

        return false;
    };

    fn.enable = function () {
        this.disabled = false;
    };

    fn.disable = function () {
        this.disabled = true;
    };

    
    fn.destroy = function () {
        this.disable();

        this.$container.off('selectstart', this.proxied_on_select_start);
        this.$container.off(pointer_events.start, this.proxied_drag_handler);
        this.$body.off(pointer_events.end, this.proxied_pointer_events_end);
        this.$body.off(pointer_events.move, this.on_pointer_events_move);
        $(window).unbind('resize', this.on_window_resize);

        $.removeData(this.$container, 'drag');
    };

    fn.ignore_drag = function (event) {
        if (this.options.handle) {
            return !$(event.target).is(this.options.handle);
        }

        return $.inArray(event.target.nodeName, this.options.ignore_dragging) >= 0;
    };

    //jQuery adapter
    $.fn.dragg = function (options) {
        return this.each(function () {
            if (!$.data(this, 'drag')) {
                $.data(this, 'drag', new Draggable(this, options));
            }
        });
    };


}(jQuery, window, document));

/*
 * jquery.gridster
 * https://github.com/ducksboard/gridster.js
 *
 * Copyright (c) 2012 ducksboard
 * Licensed under the MIT licenses.
 */
; (function ($, window, document, undefined) {

    //ToDo Max_cols and Max_size_x conflict.. need to unify
    var defaults = {
        namespace: '',
        widget_selector: 'li',
        static_class: 'static',
        widget_margins: [10, 10],
        widget_base_dimensions: [400, 225],
        extra_rows: 0,
        extra_cols: 0,
        min_cols: 1,
        max_cols: 60,
        min_rows: 15,
        max_rows: 15,
        max_size_x: 6,
        autogenerate_stylesheet: true,
        avoid_overlapped_widgets: true,
        shift_larger_widgets_down: true,
        serialize_params: function ($w, wgd) {
            return {
                col: wgd.col,
                row: wgd.row,
                size_x: wgd.size_x,
                size_y: wgd.size_y
            };
        },
        collision: {},
        draggable: {
            distance: 4,
            items: ".gs_w:not(.static)"
        }
    };


    /**
    * @class Gridster
    * @uses Draggable
    * @uses Collision
    * @param {HTMLElement} el The HTMLelement that contains all the widgets.
    * @param {Object} [options] An Object with all options you want to
    *        overwrite:
    *    @param {HTMLElement|String} [options.widget_selector] Define who will
    *     be the draggable widgets. Can be a CSS Selector String or a
    *     collection of HTMLElements
    *    @param {Array} [options.widget_margins] Margin between widgets.
    *     The first index for the horizontal margin (left, right) and
    *     the second for the vertical margin (top, bottom).
    *    @param {Array} [options.widget_base_dimensions] Base widget dimensions
    *     in pixels. The first index for the width and the second for the
    *     height.
    *    @param {Number} [options.extra_cols] Add more columns in addition to
    *     those that have been calculated.
    *    @param {Number} [options.extra_rows] Add more rows in addition to
    *     those that have been calculated.
    *    @param {Number} [options.min_cols] The minimum required columns.
    *    @param {Number} [options.min_rows] The minimum required rows.
    *    @param {Number} [options.max_size_x] The maximum number of columns
    *     that a widget can span.
    *    @param {Boolean} [options.autogenerate_stylesheet] If true, all the
    *     CSS required to position all widgets in their respective columns
    *     and rows will be generated automatically and injected to the
    *     `<head>` of the document. You can set this to false, and write
    *     your own CSS targeting rows and cols via data-attributes like so:
    *     `[data-col="1"] { left: 10px; }`
    *    @param {Boolean} [options.avoid_overlapped_widgets] Avoid that widgets loaded
    *     from the DOM can be overlapped. It is helpful if the positions were
    *     bad stored in the database or if there was any conflict.
    *    @param {Function} [options.serialize_params] Return the data you want
    *     for each widget in the serialization. Two arguments are passed:
    *     `$w`: the jQuery wrapped HTMLElement, and `wgd`: the grid
    *     coords object (`col`, `row`, `size_x`, `size_y`).
    *    @param {Object} [options.collision] An Object with all options for
    *     Collision class you want to overwrite. See Collision docs for
    *     more info.
    *    @param {Object} [options.draggable] An Object with all options for
    *     Draggable class you want to overwrite. See Draggable docs for more
    *     info.
    *
    * @constructor
    */
    function Gridster(el, options) {
        this.options = $.extend(true, defaults, options);
        this.$el = $(el);
        this.$wrapper = this.$el.parent();
        this.$widgets = this.$el.children(this.options.widget_selector).addClass('gs_w');
        this.widgets = [];
        this.$changed = $([]);
        this.w_queue = {};
        this.wrapper_width = this.$wrapper.width();
        this.min_widget_width = (this.options.widget_margins[0] * 2) +
          this.options.widget_base_dimensions[0];
        this.min_widget_height = (this.options.widget_margins[1] * 2) +
          this.options.widget_base_dimensions[1];

        this.$style_tags = $([]);

        this.init();
    }

    Gridster.generated_stylesheets = [];

    var fn = Gridster.prototype;

    fn.init = function () {
        this.generate_grid_and_stylesheet();
        this.get_widgets_from_DOM();
        this.set_dom_grid_height();
        this.$wrapper.addClass('ready');
        this.draggable();

        $(window).bind(
            'resize', throttle($.proxy(this.recalculate_faux_grid, this), 200));
    };

    /**
     * Destroy this gridster by removing any sign of its presence, making it easy to avoid memory leaks
     *
     * @method destroy
     * @param {Boolean} remove If true, remove gridster from DOM.
     * @return {Object} Returns the instance of the Gridster class.
     */
    fn.destroyRemove = function (remove) {
        this.$el.removeData('gridster');

        // remove bound callback on window resize
        $(window).unbind('.gridster');

        if (this.drag_api) {
            this.drag_api.destroy();
        }

        this.remove_style_tags();

        remove && this.$el.remove();

        return this;
    };

    /**
    * Remove the style tag with the associated id from the head of the document
    *
    * @method  remove_style_tag
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.remove_style_tags = function () {
        var all_styles = Gridster.generated_stylesheets;
        var ins_styles = this.generated_stylesheets;

        this.$style_tags.remove();

        Gridster.generated_stylesheets = $.map(all_styles, function (s) {
            if ($.inArray(s, ins_styles) === -1) { return s; }
        });
    };

    /**
    * Disables dragging.
    *
    * @method disable
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.disable = function () {
        this.$wrapper.find('.player-revert').removeClass('player-revert');
        this.drag_api.disable();
        return this;
    };


    /**
    * Enables dragging.
    *
    * @method enable
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.enable = function () {
        this.drag_api.enable();
        return this;
    };


    /**
    * Add a new widget to the grid.
    *
    * @method add_widget
    * @param {String|HTMLElement} html The string representing the HTML of the widget
    *  or the HTMLElement.
    * @param {Number} [size_x] The nº of rows the widget occupies horizontally.
    * @param {Number} [size_y] The nº of columns the widget occupies vertically.
    * @param {Number} [col] The column the widget should start in.
    * @param {Number} [row] The row the widget should start in.
    * @return {HTMLElement} Returns the jQuery wrapped HTMLElement representing.
    *  the widget that was just created.
    */
    fn.add_widget = function (html, size_x, size_y, col, row) {
        var pos;
        size_x || (size_x = 1);
        size_y || (size_y = 1);

        if (!col & !row) {
            pos = this.next_position(size_x, size_y);
        } else {
            pos = {
                col: col,
                row: row
            };

            this.empty_cells(col, row, size_x, size_y);
        }

        var $w = $(html).attr({
            'data-col': pos.col,
            'data-row': pos.row,
            'data-sizex': size_x,
            'data-sizey': size_y
        }).addClass('gs_w').appendTo(this.$el).hide();

        this.$widgets = this.$widgets.add($w);
        this.$changed = this.$changed.add($w);

        this.register_widget($w);

        this.add_faux_rows(pos.size_y);
        //this.add_faux_cols(pos.size_x);

        this.set_dom_grid_height();

        return $w.fadeIn();
    };



    /**
    * Change the size of a widget.
    *
    * @method resize_widget
    * @param {HTMLElement} $widget The jQuery wrapped HTMLElement
    *  representing the widget.
    * @param {Number} size_x The number of columns that will occupy the widget.
    * @param {Number} size_y The number of rows that will occupy the widget.
    * @return {HTMLElement} Returns $widget.
    */
    fn.resize_widget = function ($widget, size_x, size_y) {
        var wgd = $widget.coords().grid;
        size_x || (size_x = wgd.size_x);
        size_y || (size_y = wgd.size_y);

        if (size_x > this.cols) {
            size_x = this.cols;
        }

        var old_cells_occupied = this.get_cells_occupied(wgd);
        var old_size_x = wgd.size_x;
        var old_size_y = wgd.size_y;
        var old_col = wgd.col;
        var new_col = old_col;
        var wider = size_x > old_size_x;
        var taller = size_y > old_size_y;

        if (old_col + size_x - 1 > this.cols) {
            var diff = old_col + (size_x - 1) - this.cols;
            var c = old_col - diff;
            new_col = Math.max(1, c);
        }

        var new_grid_data = {
            col: new_col,
            row: wgd.row,
            size_x: size_x,
            size_y: size_y
        };

        var new_cells_occupied = this.get_cells_occupied(new_grid_data);

        var empty_cols = [];
        $.each(old_cells_occupied.cols, function (i, col) {
            if ($.inArray(col, new_cells_occupied.cols) === -1) {
                empty_cols.push(col);
            }
        });

        var occupied_cols = [];
        $.each(new_cells_occupied.cols, function (i, col) {
            if ($.inArray(col, old_cells_occupied.cols) === -1) {
                occupied_cols.push(col);
            }
        });

        var empty_rows = [];
        $.each(old_cells_occupied.rows, function (i, row) {
            if ($.inArray(row, new_cells_occupied.rows) === -1) {
                empty_rows.push(row);
            }
        });

        var occupied_rows = [];
        $.each(new_cells_occupied.rows, function (i, row) {
            if ($.inArray(row, old_cells_occupied.rows) === -1) {
                occupied_rows.push(row);
            }
        });

        this.remove_from_gridmap(wgd);

        if (occupied_cols.length) {
            var cols_to_empty = [
                new_col, wgd.row, size_x, Math.min(old_size_y, size_y), $widget
            ];
            this.empty_cells.apply(this, cols_to_empty);
        }

        if (occupied_rows.length) {
            var rows_to_empty = [new_col, wgd.row, size_x, size_y, $widget];
            this.empty_cells.apply(this, rows_to_empty);
        }

        wgd.col = new_col;
        wgd.size_x = size_x;
        wgd.size_y = size_y;
        this.add_to_gridmap(new_grid_data, $widget);

        //update coords instance attributes
        $widget.data('coords').update({
            width: (size_x * this.options.widget_base_dimensions[0] +
                ((size_x - 1) * this.options.widget_margins[0]) * 2),
            height: (size_y * this.options.widget_base_dimensions[1] +
                ((size_y - 1) * this.options.widget_margins[1]) * 2)
        });

        if (size_y > old_size_y) {
            this.add_faux_rows(size_y - old_size_y);
        }

        if (size_x > old_size_x) {
            this.add_faux_cols(size_x - old_size_x);
        }

        $widget.attr({
            'data-col': new_col,
            'data-sizex': size_x,
            'data-sizey': size_y
        });

        if (empty_cols.length) {
            var cols_to_remove_holes = [
                empty_cols[0], wgd.row,
                empty_cols.length,
                Math.min(old_size_y, size_y),
                $widget
            ];

            this.remove_empty_cells.apply(this, cols_to_remove_holes);
        }

        if (empty_rows.length) {
            var rows_to_remove_holes = [
                new_col, wgd.row, size_x, size_y, $widget
            ];
            this.remove_empty_cells.apply(this, rows_to_remove_holes);
        }

        return $widget;
    };

    /**
    * Move down widgets in cells represented by the arguments col, row, size_x,
    * size_y
    *
    * @method empty_cells
    * @param {Number} col The column where the group of cells begin.
    * @param {Number} row The row where the group of cells begin.
    * @param {Number} size_x The number of columns that the group of cells
    * occupy.
    * @param {Number} size_y The number of rows that the group of cells
    * occupy.
    * @param {HTMLElement} $exclude Exclude widgets from being moved.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.empty_cells = function (col, row, size_x, size_y, $exclude) {
        var $nexts = this.widgets_below({
            col: col,
            row: row - size_y,
            size_x: size_x,
            size_y: size_y
        });

        $nexts.not($exclude).each($.proxy(function (i, w) {
            var wgd = $(w).coords().grid;
            if (!(wgd.row <= (row + size_y - 1))) { return; }
            var diff = (row + size_y) - wgd.row;
            this.move_widget_down($(w), diff);
        }, this));

        this.set_dom_grid_height();

        return this;
    };


    /**
    * Move up widgets below cells represented by the arguments col, row, size_x,
    * size_y.
    *
    * @method remove_empty_cells
    * @param {Number} col The column where the group of cells begin.
    * @param {Number} row The row where the group of cells begin.
    * @param {Number} size_x The number of columns that the group of cells
    * occupy.
    * @param {Number} size_y The number of rows that the group of cells
    * occupy.
    * @param {HTMLElement} $exclude Exclude widgets from being moved.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.remove_empty_cells = function (col, row, size_x, size_y, exclude) {
        var $nexts = this.widgets_below({
            col: col,
            row: row,
            size_x: size_x,
            size_y: size_y
        });

        /*
        $nexts.not(exclude).each($.proxy(function(i, widget) {
            console.log("from_remove")
            this.move_widget_up( $(widget), size_y );
        }, this));
        */

        this.set_dom_grid_height();

        return this;
    };


    /**
    * Get the most left column below to add a new widget.
    *
    * @method next_position
    * @param {Number} size_x The nº of rows the widget occupies horizontally.
    * @param {Number} size_y The nº of columns the widget occupies vertically.
    * @return {Object} Returns a grid coords object representing the future
    *  widget coords.
    */
    fn.next_position = function (size_x, size_y) {
        size_x || (size_x = 1);
        size_y || (size_y = 1);
        var ga = this.gridmap;
        var cols_l = ga.length;
        var valid_pos = [];
        var rows_l;

        for (var c = 1; c < cols_l; c++) {
            rows_l = ga[c].length;
            for (var r = 1; r <= rows_l; r++) {
                var can_move_to = this.can_move_to({
                    size_x: size_x,
                    size_y: size_y
                }, c, r);

                if (can_move_to) {
                    valid_pos.push({
                        col: c,
                        row: r,
                        size_y: size_y,
                        size_x: size_x
                    });
                }
            }
        }

        if (valid_pos.length) {
            return this.sort_by_row_and_col_asc(valid_pos)[0];
        }
        return false;
    };

    fn.remove_by_grid = function (col, row) {
        var $w = this.is_widget(col, row);
        if ($w) {
            this.remove_widget($w);
        }
    }


    /**
    * Remove a widget from the grid.
    *
    * @method remove_widget
    * @param {HTMLElement} el The jQuery wrapped HTMLElement you want to remove.
    * @param {Boolean|Function} silent If true, widgets below the removed one
    * will not move up. If a Function is passed it will be used as callback.
    * @param {Function} callback Function executed when the widget is removed.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.remove_widget = function (el, silent, callback) {
        var $el = el instanceof jQuery ? el : $(el);
        var wgd = $el.coords().grid;

        // if silent is a function assume it's a callback
        if ($.isFunction(silent)) {
            callback = silent;
            silent = false;
        }

        this.cells_occupied_by_placeholder = {};
        this.$widgets = this.$widgets.not($el);

        var $nexts = this.widgets_below($el);

        this.remove_from_gridmap(wgd);

        $el.fadeOut($.proxy(function () {
            $el.remove();

            if (!silent) {
                $nexts.each($.proxy(function (i, widget) {
                    this.move_widget_up($(widget), wgd.size_y);
                }, this));
            }

            this.set_dom_grid_height();

            if (callback) {
                callback.call(this, el);
            }
        }, this));
    };


    /**
    * Remove all widgets from the grid.
    *
    * @method remove_all_widgets
    * @param {Function} callback Function executed for each widget removed.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.remove_all_widgets = function (callback) {
        this.$widgets.each($.proxy(function (i, el) {
            this.remove_widget(el, true, callback);
        }, this));

        return this;
    };


    /**
    * Returns a serialized array of the widgets in the grid.
    *
    * @method serialize
    * @param {HTMLElement} [$widgets] The collection of jQuery wrapped
    *  HTMLElements you want to serialize. If no argument is passed all widgets
    *  will be serialized.
    * @return {Array} Returns an Array of Objects with the data specified in
    *  the serialize_params option.
    */
    fn.serialize = function ($widgets) {
        $widgets || ($widgets = this.$widgets);
        var result = [];
        $widgets.each($.proxy(function (i, widget) {
            if (typeof ($(widget).coords().grid) != "undefined") {
                result.push(this.options.serialize_params(
                $(widget), $(widget).coords().grid));
            }
        }, this));

        return result;
    };

    /**
    * Returns a serialized array of the widgets that have changed their
    *  position.
    *
    * @method serialize_changed
    * @return {Array} Returns an Array of Objects with the data specified in
    *  the serialize_params option.
    */
    fn.serialize_changed = function () {
        return this.serialize(this.$changed);
    };


    /**
    * Creates the grid coords object representing the widget a add it to the
    * mapped array of positions.
    *
    * @method register_widget
    * @return {Array} Returns the instance of the Gridster class.
    */
    fn.register_widget = function ($el) {

        var wgd = {
            'col': parseInt($el.attr('data-col'), 10),
            'row': parseInt($el.attr('data-row'), 10),
            'size_x': parseInt($el.attr('data-sizex'), 10),
            'size_y': parseInt($el.attr('data-sizey'), 10),
            'el': $el
        };

        if (this.options.avoid_overlapped_widgets &&
            !this.can_move_to(
             { size_x: wgd.size_x, size_y: wgd.size_y }, wgd.col, wgd.row)
        ) {
            /*if(!$el.hasClass('.disp_ad')){
                $el.remove();
                return false;
            }*/
            wgd = this.next_position(wgd.size_x, wgd.size_y);
            wgd.el = $el;
            $el.attr({
                'data-col': wgd.col,
                'data-row': wgd.row,
                'data-sizex': wgd.size_x,
                'data-sizey': wgd.size_y
            });
        }

        // attach Coord object to player data-coord attribute
        $el.data('coords', $el.coords());

        // Extend Coord object with grid position info
        $el.data('coords').grid = wgd;

        this.add_to_gridmap(wgd, $el);

        return this;
    };


    /**
    * Update in the mapped array of positions the value of cells represented by
    * the grid coords object passed in the `grid_data` param.
    *
    * @param {Object} grid_data The grid coords object representing the cells
    *  to update in the mapped array.
    * @param {HTMLElement|Boolean} value Pass `false` or the jQuery wrapped
    *  HTMLElement, depends if you want to delete an existing position or add
    *  a new one.
    * @method update_widget_position
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.update_widget_position = function (grid_data, value) {
        this.for_each_cell_occupied(grid_data, function (col, row) {
            if (!this.gridmap[col]) { return this; }
            this.gridmap[col][row] = value;
        });
        return this;
    };


    /**
    * Remove a widget from the mapped array of positions.
    *
    * @method remove_from_gridmap
    * @param {Object} grid_data The grid coords object representing the cells
    *  to update in the mapped array.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.remove_from_gridmap = function (grid_data) {
        return this.update_widget_position(grid_data, false);
    };


    /**
    * Add a widget to the mapped array of positions.
    *
    * @method add_to_gridmap
    * @param {Object} grid_data The grid coords object representing the cells
    *  to update in the mapped array.
    * @param {HTMLElement|Boolean} value The value to set in the specified
    *  position .
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.add_to_gridmap = function (grid_data, value) {
        this.update_widget_position(grid_data, value || grid_data.el);
        /*if (grid_data.el) {
            var $widgets = this.widgets_below(grid_data.el);
            $widgets.each($.proxy(function(i, widget) {
                console.log("from_add_to_gridmap");
                this.move_widget_up( $(widget));
            }, this));
        } */
    };


    /**
    * Make widgets draggable.
    *
    * @uses Draggable
    * @method draggable
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.draggable = function () {
        var self = this;
        var draggable_options = $.extend(true, {}, this.options.draggable, {
            offset_left: this.options.widget_margins[0],
            start: function (event, ui) {
                self.$widgets.filter('.player-revert')
                    .removeClass('player-revert');

                self.$player = $(this);
                self.$helper = self.options.draggable.helper === 'clone' ?
                    $(ui.helper) : self.$player;
                self.helper = !self.$helper.is(self.$player);

                self.on_start_drag.call(self, event, ui);
                self.$el.trigger('gridster:dragstart');
            },
            stop: function (event, ui) {
                self.on_stop_drag.call(self, event, ui);
                self.$el.trigger('gridster:dragstop');
            },
            drag: throttle(function (event, ui) {
                self.on_drag.call(self, event, ui);
                self.$el.trigger('gridster:drag');
            }, 60)
        });

        this.drag_api = this.$el.dragg(draggable_options).data('drag');
        return this;
    };


    /**
    * This function is executed when the player begins to be dragged.
    *
    * @method on_start_drag
    * @param {Event} The original browser event
    * @param {Object} A prepared ui object.
    */
    fn.on_start_drag = function (event, ui) {

        this.$helper.add(this.$player).add(this.$wrapper).addClass('dragging');

        this.$player.addClass('player');
        this.player_grid_data = this.$player.coords().grid;
        this.placeholder_grid_data = $.extend({}, this.player_grid_data);

        //set new grid height along the dragging period
        this.$el.css('height', this.$el.height() +
          (this.player_grid_data.size_y * this.min_widget_height));

        var colliders = this.faux_grid;
        var coords = this.$player.data('coords').coords;

        this.cells_occupied_by_player = this.get_cells_occupied(
            this.player_grid_data);
        this.cells_occupied_by_placeholder = this.get_cells_occupied(
            this.placeholder_grid_data);

        this.last_cols = [];
        this.last_rows = [];


        // see jquery.collision.js
        this.collision_api = this.$helper.collision(
            colliders, this.options.collision);

        this.$preview_holder = $('<li />', {
            'class': 'preview-holder',
            'data-row': this.$player.attr('data-row'),
            'data-col': this.$player.attr('data-col'),
            css: {
                width: coords.width,
                height: coords.height
            }
        }).appendTo(this.$el);

        if (this.options.draggable.start) {
            this.options.draggable.start.call(this, event, ui);
        }
    };


    /**
    * This function is executed when the player is being dragged.
    *
    * @method on_drag
    * @param {Event} The original browser event
    * @param {Object} A prepared ui object.
    */
    fn.on_drag = function (event, ui) {
        //break if dragstop has been fired
        if (this.$player === null) {
            return false;
        }

        var abs_offset = {
            left: ui.position.left + this.baseX,
            top: ui.position.top + this.baseY
        };

        this.colliders_data = this.collision_api.get_closest_colliders(
            abs_offset);

        this.on_overlapped_column_change(
            this.on_start_overlapping_column,
            this.on_stop_overlapping_column
        );

        this.on_overlapped_row_change(
            this.on_start_overlapping_row,
            this.on_stop_overlapping_row
        );

        if (this.helper && this.$player) {
            this.$player.css({
                'left': ui.position.left,
                'top': ui.position.top
            });
        }

        if (this.options.draggable.drag) {
            this.options.draggable.drag.call(this, event, ui);
        }
    };

    /**
    * This function is executed when the player stops being dragged.
    *
    * @method on_stop_drag
    * @param {Event} The original browser event
    * @param {Object} A prepared ui object.
    */
    fn.on_stop_drag = function (event, ui) {
        this.$helper.add(this.$player).add(this.$wrapper)
            .removeClass('dragging');

        ui.position.left = ui.position.left + this.baseX;
        ui.position.top = ui.position.top + this.baseY;
        this.colliders_data = this.collision_api.get_closest_colliders(ui.position);

        this.on_overlapped_column_change(
            this.on_start_overlapping_column,
            this.on_stop_overlapping_column
        );

        this.on_overlapped_row_change(
            this.on_start_overlapping_row,
            this.on_stop_overlapping_row
        );

        this.$player.addClass('player-revert').removeClass('player')
            .attr({
                'data-col': this.placeholder_grid_data.col,
                'data-row': this.placeholder_grid_data.row
            }).css({
                'left': '',
                'top': ''
            });

        this.$changed = this.$changed.add(this.$player);

        this.cells_occupied_by_player = this.get_cells_occupied(
            this.placeholder_grid_data);
        this.set_cells_player_occupies(
            this.placeholder_grid_data.col, this.placeholder_grid_data.row);

        this.$player.coords().grid.row = this.placeholder_grid_data.row;
        this.$player.coords().grid.col = this.placeholder_grid_data.col;

        if (this.options.draggable.stop) {
            this.options.draggable.stop.call(this, event, ui);
        }

        this.$preview_holder.remove();

        this.$player = null;
        this.$helper = null;
        this.placeholder_grid_data = {};
        this.player_grid_data = {};
        this.cells_occupied_by_placeholder = {};
        this.cells_occupied_by_player = {};
        this.w_queue = {};

        this.set_dom_grid_height();
    };


    /**
    * Executes the callbacks passed as arguments when a column begins to be
    * overlapped or stops being overlapped.
    *
    * @param {Function} start_callback Function executed when a new column
    *  begins to be overlapped. The column is passed as first argument.
    * @param {Function} stop_callback Function executed when a column stops
    *  being overlapped. The column is passed as first argument.
    * @method on_overlapped_column_change
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.on_overlapped_column_change = function (start_callback, stop_callback) {
        if (!this.colliders_data.length) {
            return;
        }
        var cols = this.get_targeted_columns(
            this.colliders_data[0].el.data.col);

        var last_n_cols = this.last_cols.length;
        var n_cols = cols.length;
        var i;

        for (i = 0; i < n_cols; i++) {
            if ($.inArray(cols[i], this.last_cols) === -1) {
                (start_callback || $.noop).call(this, cols[i]);
            }
        }

        for (i = 0; i < last_n_cols; i++) {
            if ($.inArray(this.last_cols[i], cols) === -1) {
                (stop_callback || $.noop).call(this, this.last_cols[i]);
            }
        }

        this.last_cols = cols;

        return this;
    };


    /**
    * Executes the callbacks passed as arguments when a row starts to be
    * overlapped or stops being overlapped.
    *
    * @param {Function} start_callback Function executed when a new row begins
    *  to be overlapped. The row is passed as first argument.
    * @param {Function} stop_callback Function executed when a row stops being
    *  overlapped. The row is passed as first argument.
    * @method on_overlapped_row_change
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.on_overlapped_row_change = function (start_callback, end_callback) {
        if (!this.colliders_data.length) {
            return;
        }
        var rows = this.get_targeted_rows(this.colliders_data[0].el.data.row);
        var last_n_rows = this.last_rows.length;
        var n_rows = rows.length;
        var i;

        for (i = 0; i < n_rows; i++) {
            if ($.inArray(rows[i], this.last_rows) === -1) {
                (start_callback || $.noop).call(this, rows[i]);
            }
        }

        for (i = 0; i < last_n_rows; i++) {
            if ($.inArray(this.last_rows[i], rows) === -1) {
                (end_callback || $.noop).call(this, this.last_rows[i]);
            }
        }

        this.last_rows = rows;
    };


    /**
    * Sets the current position of the player
    *
    * @param {Function} start_callback Function executed when a new row begins
    *  to be overlapped. The row is passed as first argument.
    * @param {Function} stop_callback Function executed when a row stops being
    *  overlapped. The row is passed as first argument.
    * @method set_player
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.set_player = function (col, row, no_player) {
        var self = this;
        var swap = false;
        if (!no_player) {
            this.empty_cells_player_occupies();
        }
        var cell = !no_player ? self.colliders_data[0].el.data : { col: col };
        var to_col = cell.col;
        var to_row = cell.row || row;

        this.player_grid_data = {
            col: to_col,
            row: to_row,
            size_y: this.player_grid_data.size_y,
            size_x: this.player_grid_data.size_x
        };

        this.cells_occupied_by_player = this.get_cells_occupied(
            this.player_grid_data);

        //Added placeholder for more advanced movement.
        this.cells_occupied_by_placeholder = this.get_cells_occupied(
            this.placeholder_grid_data);

        var $overlapped_widgets = this.get_widgets_overlapped(
            this.player_grid_data);

        var player_size_y = this.player_grid_data.size_y;
        var player_size_x = this.player_grid_data.size_x;
        var placeholder_cells = this.cells_occupied_by_placeholder;
        var $gr = this;


        //Queue Swaps
        $overlapped_widgets.each($.proxy(function (i, w) {
            var $w = $(w);
            var wgd = $w.coords().grid;

            // Ensure all values are in integer format
            wgd.col = parseInt(wgd.col);
            wgd.row = parseInt(wgd.row);
            wgd.size_x = parseInt(wgd.size_x);
            wgd.size_y = parseInt(wgd.size_y);
            player_size_x = parseInt(player_size_x);
            player_size_y = parseInt(player_size_y);

            var outside_col = placeholder_cells.cols[0] + player_size_x - 1;
            var outside_row = placeholder_cells.rows[0] + player_size_y - 1;
            if ($w.hasClass($gr.options.static_class)) {
                //next iteration
                return true;
            }
            if (wgd.size_x <= player_size_x && wgd.size_y <= player_size_y) {
                if (!$gr.is_swap_occupied(placeholder_cells.cols[0], wgd.row, wgd.size_x, wgd.size_y) && !$gr.is_player_in(placeholder_cells.cols[0], wgd.row) && !$gr.is_in_queue(placeholder_cells.cols[0], wgd.row, $w)) {
                    swap = $gr.queue_widget(placeholder_cells.cols[0], wgd.row, $w);
                }
                else if (!$gr.is_swap_occupied(outside_col, wgd.row, wgd.size_x, wgd.size_y) && !$gr.is_player_in(outside_col, wgd.row) && !$gr.is_in_queue(outside_col, wgd.row, $w)) {
                    swap = $gr.queue_widget(outside_col, wgd.row, $w);
                }
                else if (!$gr.is_swap_occupied(wgd.col, placeholder_cells.rows[0], wgd.size_x, wgd.size_y) && !$gr.is_player_in(wgd.col, placeholder_cells.rows[0]) && !$gr.is_in_queue(wgd.col, placeholder_cells.rows[0], $w)) {
                    swap = $gr.queue_widget(wgd.col, placeholder_cells.rows[0], $w);
                }
                else if (!$gr.is_swap_occupied(wgd.col, outside_row, wgd.size_x, wgd.size_y) && !$gr.is_player_in(wgd.col, outside_row) && !$gr.is_in_queue(wgd.col, outside_row, $w)) {
                    swap = $gr.queue_widget(wgd.col, outside_row, $w);
                }
                else if (!$gr.is_swap_occupied(placeholder_cells.cols[0], placeholder_cells.rows[0], wgd.size_x, wgd.size_y) && !$gr.is_player_in(placeholder_cells.cols[0], placeholder_cells.rows[0]) && !$gr.is_in_queue(placeholder_cells.cols[0], placeholder_cells.rows[0], $w)) {
                    swap = $gr.queue_widget(placeholder_cells.cols[0], placeholder_cells.rows[0], $w);
                } else {
                    //in one last attempt we check for any other empty spaces
                    for (var c = 0; c < player_size_x; c++) {
                        for (var r = 0; r < player_size_y; r++) {
                            var colc = placeholder_cells.cols[0] + c;
                            var rowc = placeholder_cells.rows[0] + r;
                            if (!$gr.is_swap_occupied(colc, rowc, wgd.size_x, wgd.size_y) && !$gr.is_player_in(colc, rowc) && !$gr.is_in_queue(colc, rowc, $w)) {
                                swap = $gr.queue_widget(colc, rowc, $w);
                                c = player_size_x;
                                break;
                            }
                        }
                    }

                }
            } else if ($gr.options.shift_larger_widgets_down && !swap) {
                $overlapped_widgets.each($.proxy(function (i, w) {
                    var $w = $(w);
                    var wgd = $w.coords().grid;

                    if ($gr.can_go_down($w)) {
                        $gr.move_widget_down($w, $gr.player_grid_data.size_y);
                        $gr.set_placeholder(to_col, to_row);
                    }
                }));
            }

            $gr.clean_up_changed();
        }));


        /* To show queued items in console
        for(var key in this.w_queue){
            console.log("key " +key);
            console.log(this.w_queue[key]);
        }
        */

        //Move queued widgets
        if (swap && this.can_placeholder_be_set(to_col, to_row, player_size_x, player_size_y)) {
            for (var key in this.w_queue) {
                var col = parseInt(key.split("_")[0]);
                var row = parseInt(key.split("_")[1]);
                if (this.w_queue[key] != "full") {
                    this.new_move_widget_to(this.w_queue[key], col, row);
                }
            }
            this.set_placeholder(to_col, to_row);
        }

        /* if there is not widgets overlapping in the new player position,
         * update the new placeholder position. */
        if (!$overlapped_widgets.length) {
            var pp = this.can_go_player_up(this.player_grid_data);
            if (pp !== false) {
                to_row = pp;
            }
            if (this.can_placeholder_be_set(to_col, to_row, player_size_x, player_size_y)) {
                this.set_placeholder(to_col, to_row);
            }
        }

        this.w_queue = {};

        return {
            col: to_col,
            row: to_row
        };
    };


    fn.is_swap_occupied = function (col, row, w_size_x, w_size_y) {
        var occupied = false;
        for (var c = 0; c < w_size_x; c++) {
            for (var r = 0; r < w_size_y; r++) {
                var colc = col + c;
                var rowc = row + r;
                var key = colc + "_" + rowc;
                if (this.is_occupied(colc, rowc)) {
                    occupied = true;
                } else if (key in this.w_queue) {
                    if (this.w_queue[key] == "full") {
                        occupied = true;
                        continue;
                    }
                    $tw = this.w_queue[key];
                    tgd = $tw.coords().grid;
                    //remove queued items if no longer under player.
                    if (!this.is_widget_under_player(tgd.col, tgd.row)) {
                        delete this.w_queue[key];
                    }
                }
                if (rowc > parseInt(this.options.max_rows)) {
                    occupied = true;
                }
                if (colc > parseInt(this.options.max_cols)) {
                    occupied = true;
                }
                if (this.is_player_in(colc, rowc)) {
                    occupied = true;
                }
            }
        }

        return occupied;
    }

    fn.can_placeholder_be_set = function (col, row, player_size_x, player_size_y) {
        var can_set = true;
        for (var c = 0; c < player_size_x; c++) {
            for (var r = 0; r < player_size_y; r++) {
                var colc = col + c;
                var rowc = row + r;
                var key = colc + "_" + rowc;
                var $tw = this.is_widget(colc, rowc);
                //if this space is occupied and not queued for move.
                if (rowc > parseInt(this.options.max_rows)) {
                    can_set = false;
                }
                if (colc > parseInt(this.options.max_cols)) {
                    can_set = false;
                }
                if (this.is_occupied(colc, rowc) && !this.is_widget_queued_and_can_move($tw)) {
                    can_set = false;
                }
            }
        }
        return can_set;
    }

    fn.queue_widget = function (col, row, $widget) {
        var $w = $widget
        var wgd = $w.coords().grid;
        var primary_key = col + "_" + row;
        if (primary_key in this.w_queue) {
            return false;
        }

        this.w_queue[primary_key] = $w;

        for (var c = 0; c < wgd.size_x; c++) {
            for (var r = 0; r < wgd.size_y; r++) {
                var colc = col + c;
                var rowc = row + r;
                var key = colc + "_" + rowc;
                if (key == primary_key) {
                    continue;
                }
                this.w_queue[key] = "full";
            }
        }

        return true;
    }

    fn.is_widget_queued_and_can_move = function ($widget) {
        var queued = false;
        if ($widget === false) {
            return false;
        }

        for (var key in this.w_queue) {
            if (this.w_queue[key] == "full") {
                continue;
            }
            if (this.w_queue[key].attr("data-col") == $widget.attr("data-col") && this.w_queue[key].attr("data-row") == $widget.attr("data-row")) {
                queued = true;
                //test whole space
                var $w = this.w_queue[key];
                var dcol = parseInt(key.split("_")[0]);
                var drow = parseInt(key.split("_")[1]);
                var wgd = $w.coords().grid;

                for (var c = 0; c < wgd.size_x; c++) {
                    for (var r = 0; r < wgd.size_y; r++) {
                        var colc = dcol + c;
                        var rowc = drow + r;
                        if (this.is_player_in(colc, rowc)) {
                            queued = false;
                        }

                    }
                }

            }
        }

        return queued
    }

    fn.is_in_queue = function (col, row, $widget) {
        var queued = false;
        var key = col + "_" + row;

        if ((key in this.w_queue)) {
            if (this.w_queue[key] == "full") {
                queued = true;
            } else {
                $tw = this.w_queue[key];
                tgd = $tw.coords().grid;
                if (!this.is_widget_under_player(tgd.col, tgd.row)) {
                    delete this.w_queue[key]
                    queued = false;
                } else if (this.w_queue[key].attr("data-col") == $widget.attr("data-col") && this.w_queue[key].attr("data-row") == $widget.attr("data-row")) {
                    delete this.w_queue[key]
                    queued = false;
                } else {
                    queued = true;
                }
            }
        }

        return queued;
    }


    /**
    * See which of the widgets in the $widgets param collection can go to
    * a upper row and which not.
    *
    * @method widgets_contraints
    * @param {HTMLElements} $widgets A jQuery wrapped collection of
    * HTMLElements.
    * @return {Array} Returns a literal Object with two keys: `can_go_up` &
    * `can_not_go_up`. Each contains a set of HTMLElements.
    */
    fn.widgets_constraints = function ($widgets) {
        var $widgets_can_go_up = $([]);
        var $widgets_can_not_go_up;
        var wgd_can_go_up = [];
        var wgd_can_not_go_up = [];

        $widgets.each($.proxy(function (i, w) {
            var $w = $(w);
            var wgd = $w.coords().grid;
            if (this.can_go_widget_up(wgd)) {
                $widgets_can_go_up = $widgets_can_go_up.add($w);
                wgd_can_go_up.push(wgd);
            } else {
                wgd_can_not_go_up.push(wgd);
            }
        }, this));

        $widgets_can_not_go_up = $widgets.not($widgets_can_go_up);

        return {
            can_go_up: this.sort_by_row_asc(wgd_can_go_up),
            can_not_go_up: this.sort_by_row_desc(wgd_can_not_go_up)
        };
    };


    /**
    * Sorts an Array of grid coords objects (representing the grid coords of
    * each widget) in ascending way.
    *
    * @method sort_by_row_asc
    * @param {Array} widgets Array of grid coords objects
    * @return {Array} Returns the array sorted.
    */
    fn.sort_by_row_asc = function (widgets) {
        widgets = widgets.sort(function (a, b) {
            if (!a.row) {
                a = $(a).coords().grid;
                b = $(b).coords().grid;
            }

            if (a.row > b.row) {
                return 1;
            }
            return -1;
        });

        return widgets;
    };


    /**
    * Sorts an Array of grid coords objects (representing the grid coords of
    * each widget) placing first the empty cells upper left.
    *
    * @method sort_by_row_and_col_asc
    * @param {Array} widgets Array of grid coords objects
    * @return {Array} Returns the array sorted.
    */
    fn.sort_by_row_and_col_asc = function (widgets) {
        widgets = widgets.sort(function (a, b) {
            if (a.row > b.row || a.row === b.row && a.col > b.col) {
                return 1;
            }
            return -1;
        });

        return widgets;
    };


    /**
    * Sorts an Array of grid coords objects by column (representing the grid
    * coords of each widget) in ascending way.
    *
    * @method sort_by_col_asc
    * @param {Array} widgets Array of grid coords objects
    * @return {Array} Returns the array sorted.
    */
    fn.sort_by_col_asc = function (widgets) {
        widgets = widgets.sort(function (a, b) {
            if (a.col > b.col) {
                return 1;
            }
            return -1;
        });

        return widgets;
    };


    /**
    * Sorts an Array of grid coords objects (representing the grid coords of
    * each widget) in descending way.
    *
    * @method sort_by_row_desc
    * @param {Array} widgets Array of grid coords objects
    * @return {Array} Returns the array sorted.
    */
    fn.sort_by_row_desc = function (widgets) {
        widgets = widgets.sort(function (a, b) {
            if (a.row + a.size_y < b.row + b.size_y) {
                return 1;
            }
            return -1;
        });
        return widgets;
    };


    /**
    * Sorts an Array of grid coords objects (representing the grid coords of
    * each widget) in descending way.

    * Depreciated.
    *
    * @method manage_movements
    * @param {HTMLElements} $widgets A jQuery collection of HTMLElements
    *  representing the widgets you want to move.
    * @param {Number} to_col The column to which we want to move the widgets.
    * @param {Number} to_row The row to which we want to move the widgets.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.manage_movements = function ($widgets, to_col, to_row) {
        $.each($widgets, $.proxy(function (i, w) {
            var wgd = w;
            var $w = wgd.el;

            var can_go_widget_up = this.can_go_widget_up(wgd);

            if (can_go_widget_up) {
                //target CAN go up
                //so move widget up
                this.move_widget_to($w, can_go_widget_up);
                this.set_placeholder(to_col, can_go_widget_up + wgd.size_y);

            } else {
                //target can't go up
                var can_go_player_up = this.can_go_player_up(
                    this.player_grid_data);

                if (!can_go_player_up) {
                    // target can't go up
                    // player cant't go up
                    // so we need to move widget down to a position that dont
                    // overlaps player
                    var y = (to_row + this.player_grid_data.size_y) - wgd.row;
                    if (this.can_go_down($w)) {
                        console.log("In Move Down!")
                        this.move_widget_down($w, y);
                        this.set_placeholder(to_col, to_row);
                    }
                }
            }
        }, this));

        return this;
    };

    /**
    * Determines if there is a widget in the row and col given. Or if the
    * HTMLElement passed as first argument is the player.
    *
    * @method is_player
    * @param {Number|HTMLElement} col_or_el A jQuery wrapped collection of
    * HTMLElements.
    * @param {Number} [row] The column to which we want to move the widgets.
    * @return {Boolean} Returns true or false.
    */
    fn.is_player = function (col_or_el, row) {
        if (row && !this.gridmap[col_or_el]) { return false; }
        var $w = row ? this.gridmap[col_or_el][row] : col_or_el;
        return $w && ($w.is(this.$player) || $w.is(this.$helper));
    };


    /**
    * Determines if the widget that is being dragged is currently over the row
    * and col given.
    *
    * @method is_player_in
    * @param {Number} col The column to check.
    * @param {Number} row The row to check.
    * @return {Boolean} Returns true or false.
    */
    fn.is_player_in = function (col, row) {
        var c = this.cells_occupied_by_player || {};
        return $.inArray(col, c.cols) >= 0 && $.inArray(row, c.rows) >= 0;
    };


    /**
    * Determines if the placeholder is currently over the row and col given.
    *
    * @method is_placeholder_in
    * @param {Number} col The column to check.
    * @param {Number} row The row to check.
    * @return {Boolean} Returns true or false.
    */
    fn.is_placeholder_in = function (col, row) {
        var c = this.cells_occupied_by_placeholder || {};
        return this.is_placeholder_in_col(col) && $.inArray(row, c.rows) >= 0;
    };


    /**
    * Determines if the placeholder is currently over the column given.
    *
    * @method is_placeholder_in_col
    * @param {Number} col The column to check.
    * @return {Boolean} Returns true or false.
    */
    fn.is_placeholder_in_col = function (col) {
        var c = this.cells_occupied_by_placeholder || [];
        return $.inArray(col, c.cols) >= 0;
    };


    /**
    * Determines if the cell represented by col and row params is empty.
    *
    * @method is_empty
    * @param {Number} col The column to check.
    * @param {Number} row The row to check.
    * @return {Boolean} Returns true or false.
    */
    fn.is_empty = function (col, row) {
        if (typeof this.gridmap[col] !== 'undefined' &&
            typeof this.gridmap[col][row] !== 'undefined' &&
            this.gridmap[col][row] === false
        ) {
            return true;
        }
        return false;
    };


    /**
    * Determines if the cell represented by col and row params is occupied.
    *
    * @method is_occupied
    * @param {Number} col The column to check.
    * @param {Number} row The row to check.
    * @return {Boolean} Returns true or false.
    */
    fn.is_occupied = function (col, row) {
        if (!this.gridmap[col]) {
            return false;
        }

        if (this.gridmap[col][row]) {
            return true;
        }
        return false;
    };


    /**
    * Determines if there is a widget in the cell represented by col/row params.
    *
    * @method is_widget
    * @param {Number} col The column to check.
    * @param {Number} row The row to check.
    * @return {Boolean|HTMLElement} Returns false if there is no widget,
    * else returns the jQuery HTMLElement
    */
    fn.is_widget = function (col, row) {
        var cell = this.gridmap[col];
        if (!cell) {
            return false;
        }

        cell = cell[row];

        if (cell) {
            return cell;
        }

        return false;
    };

    /**
   * Determines if widget is supposed to be static.
   * @method is_static
   * @param {Number} col The column to check.
   * @param {Number} row The row to check.
   * @return {Boolean} Returns true if widget exists and has static class,
   * else returns false
   */

    fn.is_static = function (col, row) {
        var cell = this.gridmap[col];
        if (!cell) {
            return false;
        }

        cell = cell[row];

        if (cell) {
            if (cell.hasClass(this.options.static_class)) {
                return true;
            }
        }

        return false;
    };


    /**
    * Determines if there is a widget in the cell represented by col/row
    * params and if this is under the widget that is being dragged.
    *
    * @method is_widget_under_player
    * @param {Number} col The column to check.
    * @param {Number} row The row to check.
    * @return {Boolean} Returns true or false.
    */
    fn.is_widget_under_player = function (col, row) {
        if (this.is_widget(col, row)) {
            return this.is_player_in(col, row);
        }
        return false;
    };


    /**
    * Get widgets overlapping with the player or with the object passed
    * representing the grid cells.
    *
    * @method get_widgets_under_player
    * @return {HTMLElement} Returns a jQuery collection of HTMLElements
    */
    fn.get_widgets_under_player = function (cells) {
        cells || (cells = this.cells_occupied_by_player || { cols: [], rows: [] });
        var $widgets = $([]);

        $.each(cells.cols, $.proxy(function (i, col) {
            $.each(cells.rows, $.proxy(function (i, row) {
                if (this.is_widget(col, row)) {
                    $widgets = $widgets.add(this.gridmap[col][row]);
                }
            }, this));
        }, this));

        return $widgets;
    };


    /**
    * Put placeholder at the row and column specified.
    *
    * @method set_placeholder
    * @param {Number} col The column to which we want to move the
    *  placeholder.
    * @param {Number} row The row to which we want to move the
    *  placeholder.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.set_placeholder = function (col, row) {
        var phgd = $.extend({}, this.placeholder_grid_data);
        var $nexts = this.widgets_below({
            col: phgd.col,
            row: phgd.row,
            size_y: phgd.size_y,
            size_x: phgd.size_x
        });

        // Prevents widgets go out of the grid
        var right_col = (col + parseInt(phgd.size_x) - 1);
        if (right_col > this.cols) {
            col = col - (right_col - col);
        }

        var moved_down = this.placeholder_grid_data.row < row;
        var changed_column = this.placeholder_grid_data.col !== col;

        this.placeholder_grid_data.col = col;
        this.placeholder_grid_data.row = row;

        this.cells_occupied_by_placeholder = this.get_cells_occupied(
            this.placeholder_grid_data);

        this.$preview_holder.attr({
            'data-row': row,
            'data-col': col
        });

        if (moved_down || changed_column) {
            $nexts.each($.proxy(function (i, widget) {
                //Make sure widget is at it's topmost position
                $w = $(widget);
                wgd = $w.coords().grid;

                var can_go_widget_up = this.can_go_widget_up(wgd);

                if (can_go_widget_up) {
                    this.move_widget_to($w, can_go_widget_up);
                }

            }, this));
        }


        var $widgets_under_ph = this.get_widgets_under_player(this.cells_occupied_by_placeholder);
        if ($widgets_under_ph.length) {
            $widgets_under_ph.each($.proxy(function (i, widget) {
                var $w = $(widget);
                this.move_widget_down(
                 $w, row + phgd.size_y - $w.data('coords').grid.row);
            }, this));
        }

    };


    /**
    * Determines whether the player can move to a position above.
    *
    * @method can_go_player_up
    * @param {Object} widget_grid_data The actual grid coords object of the
    *  player.
    * @return {Number|Boolean} If the player can be moved to an upper row
    *  returns the row number, else returns false.
    */
    fn.can_go_player_up = function (widget_grid_data) {
        var p_bottom_row = widget_grid_data.row + widget_grid_data.size_y - 1;
        var result = true;
        var upper_rows = [];
        var min_row = 10000;
        var $widgets_under_player = this.get_widgets_under_player();

        /* generate an array with columns as index and array with upper rows
         * empty as value */
        this.for_each_column_occupied(widget_grid_data, function (tcol) {
            var grid_col = this.gridmap[tcol];
            var r = p_bottom_row + 1;
            upper_rows[tcol] = [];

            while (--r > 0) {
                if (this.is_empty(tcol, r) || this.is_player(tcol, r) ||
                    this.is_widget(tcol, r) &&
                    grid_col[r].is($widgets_under_player)
                ) {
                    upper_rows[tcol].push(r);
                    min_row = r < min_row ? r : min_row;
                } else {
                    break;
                }
            }

            if (upper_rows[tcol].length === 0) {
                result = false;
                return true; //break
            }

            upper_rows[tcol].sort();
        });

        if (!result) { return false; }

        return this.get_valid_rows(widget_grid_data, upper_rows, min_row);
    };


    /**
    * Determines whether a widget can move to a position above.
    *
    * @method can_go_widget_up
    * @param {Object} widget_grid_data The actual grid coords object of the
    *  widget we want to check.
    * @return {Number|Boolean} If the widget can be moved to an upper row
    *  returns the row number, else returns false.
    */
    fn.can_go_widget_up = function (widget_grid_data) {
        var p_bottom_row = widget_grid_data.row + widget_grid_data.size_y - 1;
        var result = true;
        var upper_rows = [];
        var min_row = 10000;

        /* generate an array with columns as index and array with topmost rows
         * empty as value */
        this.for_each_column_occupied(widget_grid_data, function (tcol) {
            var grid_col = this.gridmap[tcol];
            upper_rows[tcol] = [];

            var r = p_bottom_row + 1;
            // iterate over each row
            while (--r > 0) {
                if (this.is_widget(tcol, r) && !this.is_player_in(tcol, r)) {
                    if (!grid_col[r].is(widget_grid_data.el)) {
                        break;
                    }
                }

                if (!this.is_player(tcol, r) &&
                    !this.is_placeholder_in(tcol, r) &&
                    !this.is_player_in(tcol, r)) {
                    upper_rows[tcol].push(r);
                }

                if (r < min_row) {
                    min_row = r;
                }
            }

            if (upper_rows[tcol].length === 0) {
                result = false;
                return true; //break
            }

            upper_rows[tcol].sort();
        });

        if (!result) { return false; }

        return this.get_valid_rows(widget_grid_data, upper_rows, min_row);
    };


    /**
    * Search a valid row for the widget represented by `widget_grid_data' in
    * the `upper_rows` array. Iteration starts from row specified in `min_row`.
    *
    * @method get_valid_rows
    * @param {Object} widget_grid_data The actual grid coords object of the
    *  player.
    * @param {Array} upper_rows An array with columns as index and arrays
    *  of valid rows as values.
    * @param {Number} min_row The upper row from which the iteration will start.
    * @return {Number|Boolean} Returns the upper row valid from the `upper_rows`
    *  for the widget in question.
    */
    fn.get_valid_rows = function (widget_grid_data, upper_rows, min_row) {
        var p_top_row = widget_grid_data.row;
        var p_bottom_row = widget_grid_data.row + widget_grid_data.size_y - 1;
        var size_y = widget_grid_data.size_y;
        var r = min_row - 1;
        var valid_rows = [];

        while (++r <= p_bottom_row) {
            var common = true;
            $.each(upper_rows, function (col, rows) {
                if ($.isArray(rows) && $.inArray(r, rows) === -1) {
                    common = false;
                }
            });

            if (common === true) {
                valid_rows.push(r);
                if (valid_rows.length === size_y) {
                    break;
                }
            }
        }

        var new_row = false;
        if (size_y === 1) {
            if (valid_rows[0] !== p_top_row) {
                new_row = valid_rows[0] || false;
            }
        } else {
            if (valid_rows[0] !== p_top_row) {
                new_row = this.get_consecutive_numbers_index(
                    valid_rows, size_y);
            }
        }

        return new_row;
    };


    fn.get_consecutive_numbers_index = function (arr, size_y) {
        var max = arr.length;
        var result = [];
        var first = true;
        var prev = -1; // or null?

        for (var i = 0; i < max; i++) {
            if (first || arr[i] === prev + 1) {
                result.push(i);
                if (result.length === size_y) {
                    break;
                }
                first = false;
            } else {
                result = [];
                first = true;
            }

            prev = arr[i];
        }

        return result.length >= size_y ? arr[result[0]] : false;
    };


    /**
    * Get widgets overlapping with the player.
    *
    * @method get_widgets_overlapped
    * @return {HTMLElements} Returns a jQuery collection of HTMLElements.
    */
    fn.get_widgets_overlapped = function () {
        var $w;
        var $widgets = $([]);
        var used = [];
        var rows_from_bottom = this.cells_occupied_by_player.rows.slice(0);
        rows_from_bottom.reverse();

        $.each(this.cells_occupied_by_player.cols, $.proxy(function (i, col) {
            $.each(rows_from_bottom, $.proxy(function (i, row) {
                // if there is a widget in the player position
                if (!this.gridmap[col]) { return true; } //next iteration
                var $w = this.gridmap[col][row];
                if (this.is_occupied(col, row) && !this.is_player($w) &&
                    $.inArray($w, used) === -1
                ) {
                    $widgets = $widgets.add($w);
                    used.push($w);
                }

            }, this));
        }, this));

        return $widgets;
    };


    /**
    * This callback is executed when the player begins to collide with a column.
    *
    * @method on_start_overlapping_column
    * @param {Number} col The collided column.
    * @return {HTMLElements} Returns a jQuery collection of HTMLElements.
    */
    fn.on_start_overlapping_column = function (col) {
        this.set_player(col, false);
    };


    /**
    * A callback executed when the player begins to collide with a row.
    *
    * @method on_start_overlapping_row
    * @param {Number} col The collided row.
    * @return {HTMLElements} Returns a jQuery collection of HTMLElements.
    */
    fn.on_start_overlapping_row = function (row) {
        this.set_player(false, row);
    };


    /**
    * A callback executed when the the player ends to collide with a column.
    *
    * @method on_stop_overlapping_column
    * @param {Number} col The collided row.
    * @return {HTMLElements} Returns a jQuery collection of HTMLElements.
    */
    fn.on_stop_overlapping_column = function (col) {
        //this.set_player(col, false);
        var self = this;
        if (this.options.shift_larger_widgets_down) {
            this.for_each_widget_below(col, this.cells_occupied_by_player.rows[0],
                function (tcol, trow) {
                    self.move_widget_up(this, self.player_grid_data.size_y);
                });
        }
    };


    /**
    * This callback is executed when the player ends to collide with a row.
    *
    * @method on_stop_overlapping_row
    * @param {Number} row The collided row.
    * @return {HTMLElements} Returns a jQuery collection of HTMLElements.
    */
    fn.on_stop_overlapping_row = function (row) {
        //this.set_player(false, row);
        var self = this;
        var cols = this.cells_occupied_by_player.cols;
        if (this.options.shift_larger_widgets_down) {
            for (var c = 0, cl = cols.length; c < cl; c++) {
                this.for_each_widget_below(cols[c], row, function (tcol, trow) {
                    console.log("from_on_stop_overlapping_row");
                    self.move_widget_up(this, self.player_grid_data.size_y);
                });
            }
        }
    };

    //Not yet part of api - DM.
    fn.new_move_widget_to = function ($widget, col, row) {
        var self = this;
        var widget_grid_data = $widget.coords().grid;

        this.remove_from_gridmap(widget_grid_data);
        widget_grid_data.row = row;
        widget_grid_data.col = col;

        this.add_to_gridmap(widget_grid_data);
        $widget.attr('data-row', row);
        $widget.attr('data-col', col);
        this.update_widget_position(widget_grid_data, $widget);
        this.$changed = this.$changed.add($widget);

        return this;
    }


    /**
    * Move a widget to a specific row. The cell or cells must be empty.
    * If the widget has widgets below, all of these widgets will be moved also
    * if they can.
    *
    * @method move_widget_to
    * @param {HTMLElement} $widget The jQuery wrapped HTMLElement of the
    * widget is going to be moved.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.move_widget_to = function ($widget, row) {
        var self = this;
        var widget_grid_data = $widget.coords().grid;
        var diff = row - widget_grid_data.row;
        var $next_widgets = this.widgets_below($widget);

        var can_move_to_new_cell = this.can_move_to(
            widget_grid_data, widget_grid_data.col, row, $widget);

        if (can_move_to_new_cell === false) {
            return false;
        }

        this.remove_from_gridmap(widget_grid_data);
        widget_grid_data.row = row;
        this.add_to_gridmap(widget_grid_data);
        $widget.attr('data-row', row);
        this.$changed = this.$changed.add($widget);


        $next_widgets.each(function (i, widget) {
            var $w = $(widget);
            var wgd = $w.coords().grid;
            var can_go_up = self.can_go_widget_up(wgd);
            if (can_go_up && can_go_up !== wgd.row) {
                self.move_widget_to($w, can_go_up);
            }
        });

        return this;
    };


    /**
    * Move up the specified widget and all below it.
    *
    * @method move_widget_up
    * @param {HTMLElement} $widget The widget you want to move.
    * @param {Number} [y_units] The number of cells that the widget has to move.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.move_widget_up = function ($widget, y_units) {
        var el_grid_data = $widget.coords().grid;
        var actual_row = el_grid_data.row;
        var moved = [];
        var can_go_up = true;
        y_units || (y_units = 1);

        if (!this.can_go_up($widget)) { return false; } //break;

        this.for_each_column_occupied(el_grid_data, function (col) {
            // can_go_up
            if ($.inArray($widget, moved) === -1) {
                var widget_grid_data = $widget.coords().grid;
                var next_row = actual_row - y_units;
                next_row = this.can_go_up_to_row(
                    widget_grid_data, col, next_row);

                if (!next_row) {
                    return true;
                }

                var $next_widgets = this.widgets_below($widget);

                this.remove_from_gridmap(widget_grid_data);
                widget_grid_data.row = next_row;
                this.add_to_gridmap(widget_grid_data);
                $widget.attr('data-row', widget_grid_data.row);
                this.$changed = this.$changed.add($widget);

                moved.push($widget);

                /* $next_widgets.each($.proxy(function(i, widget) {
                    console.log("from_within_move_widget_up");
                    this.move_widget_up($(widget), y_units);
                }, this)); */
            }
        });

    };


    /**
    * Move down the specified widget and all below it.
    *
    * @method move_widget_down
    * @param {HTMLElement} $widget The jQuery object representing the widget
    *  you want to move.
    * @param {Number} The number of cells that the widget has to move.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.move_widget_down = function ($widget, y_units) {
        var el_grid_data = $widget.coords().grid;
        var actual_row = el_grid_data.row;
        var moved = [];
        var y_diff = y_units;

        if (!$widget) { return false; }

        if ($.inArray($widget, moved) === -1) {

            var widget_grid_data = $widget.coords().grid;
            var next_row = actual_row + y_units;
            var $next_widgets = this.widgets_below($widget);

            this.remove_from_gridmap(widget_grid_data);

            $next_widgets.each($.proxy(function (i, widget) {
                var $w = $(widget);
                var wd = $w.coords().grid;
                var tmp_y = this.displacement_diff(
                             wd, widget_grid_data, y_diff);

                if (tmp_y > 0) {
                    this.move_widget_down($w, tmp_y);
                }
            }, this));

            widget_grid_data.row = next_row;
            this.update_widget_position(widget_grid_data, $widget);
            $widget.attr('data-row', widget_grid_data.row);
            this.$changed = this.$changed.add($widget);

            moved.push($widget);
        }
    };


    /**
    * Check if the widget can move to the specified row, else returns the
    * upper row possible.
    *
    * @method can_go_up_to_row
    * @param {Number} widget_grid_data The current grid coords object of the
    *  widget.
    * @param {Number} col The target column.
    * @param {Number} row The target row.
    * @return {Boolean|Number} Returns the row number if the widget can move
    *  to the target position, else returns false.
    */
    fn.can_go_up_to_row = function (widget_grid_data, col, row) {
        var ga = this.gridmap;
        var result = true;
        var urc = []; // upper_rows_in_columns
        var actual_row = widget_grid_data.row;
        var r;

        /* generate an array with columns as index and array with
         * upper rows empty in the column */
        this.for_each_column_occupied(widget_grid_data, function (tcol) {
            var grid_col = ga[tcol];
            urc[tcol] = [];

            r = actual_row;
            while (r--) {
                if (this.is_empty(tcol, r) &&
                    !this.is_placeholder_in(tcol, r)
                ) {
                    urc[tcol].push(r);
                } else {
                    break;
                }
            }

            if (!urc[tcol].length) {
                result = false;
                return true;
            }

        });

        if (!result) { return false; }

        /* get common rows starting from upper position in all the columns
         * that widget occupies */
        r = row;
        for (r = 1; r < actual_row; r++) {
            var common = true;

            for (var uc = 0, ucl = urc.length; uc < ucl; uc++) {
                if (urc[uc] && $.inArray(r, urc[uc]) === -1) {
                    common = false;
                }
            }

            if (common === true) {
                result = r;
                break;
            }
        }

        return result;
    };


    fn.displacement_diff = function (widget_grid_data, parent_bgd, y_units) {
        var actual_row = widget_grid_data.row;
        var diffs = [];
        var parent_max_y = parent_bgd.row + parent_bgd.size_y;

        this.for_each_column_occupied(widget_grid_data, function (col) {
            var temp_y_units = 0;

            for (var r = parent_max_y; r < actual_row; r++) {
                if (this.is_empty(col, r)) {
                    temp_y_units = temp_y_units + 1;
                }
            }

            diffs.push(temp_y_units);
        });

        var max_diff = Math.max.apply(Math, diffs);
        y_units = (y_units - max_diff);

        return y_units > 0 ? y_units : 0;
    };


    /**
    * Get widgets below a widget.
    *
    * @method widgets_below
    * @param {HTMLElement} $el The jQuery wrapped HTMLElement.
    * @return {HTMLElements} A jQuery collection of HTMLElements.
    */
    fn.widgets_below = function ($el) {
        var el_grid_data = $.isPlainObject($el) ? $el : $el.coords().grid;
        var self = this;
        var ga = this.gridmap;
        var next_row = el_grid_data.row + el_grid_data.size_y - 1;
        var $nexts = $([]);

        this.for_each_column_occupied(el_grid_data, function (col) {
            self.for_each_widget_below(col, next_row, function (tcol, trow) {
                if (!self.is_player(this) && $.inArray(this, $nexts) === -1) {
                    $nexts = $nexts.add(this);
                    return true; // break
                }
            });
        });

        return this.sort_by_row_asc($nexts);
    };


    /**
    * Update the array of mapped positions with the new player position.
    *
    * @method set_cells_player_occupies
    * @param {Number} col The new player col.
    * @param {Number} col The new player row.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.set_cells_player_occupies = function (col, row) {
        this.remove_from_gridmap(this.placeholder_grid_data);
        this.placeholder_grid_data.col = col;
        this.placeholder_grid_data.row = row;
        this.add_to_gridmap(this.placeholder_grid_data, this.$player);
        return this;
    };


    /**
    * Remove from the array of mapped positions the reference to the player.
    *
    * @method empty_cells_player_occupies
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.empty_cells_player_occupies = function () {
        this.remove_from_gridmap(this.placeholder_grid_data);
        return this;
    };

    fn.can_go_down = function ($el) {
        var can_go_down = true;
        var $gr = this;

        if ($el.hasClass(this.options.static_class)) {
            can_go_down = false;
        }

        this.widgets_below($el).each(function () {
            if ($(this).hasClass($gr.options.static_class)) {
                can_go_down = false;
            }
        })

        return can_go_down;
    }


    fn.can_go_up = function ($el) {
        var el_grid_data = $el.coords().grid;
        var initial_row = el_grid_data.row;
        var prev_row = initial_row - 1;
        var ga = this.gridmap;
        var upper_rows_by_column = [];

        var result = true;
        if (initial_row === 1) { return false; }

        this.for_each_column_occupied(el_grid_data, function (col) {
            var $w = this.is_widget(col, prev_row);

            if (this.is_occupied(col, prev_row) ||
                this.is_player(col, prev_row) ||
                this.is_placeholder_in(col, prev_row) ||
                this.is_player_in(col, prev_row)
            ) {
                result = false;
                return true; //break
            }
        });

        return result;
    };



    /**
    * Check if it's possible to move a widget to a specific col/row. It takes
    * into account the dimensions (`size_y` and `size_x` attrs. of the grid
    *  coords object) the widget occupies.
    *
    * @method can_move_to
    * @param {Object} widget_grid_data The grid coords object that represents
    *  the widget.
    * @param {Object} col The col to check.
    * @param {Object} row The row to check.
    * @param {Number} [max_row] The max row allowed.
    * @return {Boolean} Returns true if all cells are empty, else return false.
    */
    fn.can_move_to = function (widget_grid_data, col, row, max_row) {
        var ga = this.gridmap;
        var $w = widget_grid_data.el;
        var future_wd = {
            size_y: widget_grid_data.size_y,
            size_x: widget_grid_data.size_x,
            col: col,
            row: row
        };
        var result = true;

        //Prevents widgets go out of the grid
        var right_col = col + widget_grid_data.size_x - 1;
        if (right_col > this.cols) {
            return false;
        }

        if (max_row && max_row < row + widget_grid_data.size_y - 1) {
            return false;
        }

        this.for_each_cell_occupied(future_wd, function (tcol, trow) {
            var $tw = this.is_widget(tcol, trow);
            if ($tw && (!widget_grid_data.el || $tw.is($w))) {
                result = false;
            }
        });

        return result;
    };


    /**
    * Given the leftmost column returns all columns that are overlapping
    *  with the player.
    *
    * @method get_targeted_columns
    * @param {Number} [from_col] The leftmost column.
    * @return {Array} Returns an array with column numbers.
    */
    fn.get_targeted_columns = function (from_col) {
        var max = (from_col || this.player_grid_data.col) +
            (this.player_grid_data.size_x - 1);
        var cols = [];
        for (var col = from_col; col <= max; col++) {
            cols.push(col);
        }
        return cols;
    };


    /**
    * Given the upper row returns all rows that are overlapping with the player.
    *
    * @method get_targeted_rows
    * @param {Number} [from_row] The upper row.
    * @return {Array} Returns an array with row numbers.
    */
    fn.get_targeted_rows = function (from_row) {
        var max = (from_row || this.player_grid_data.row) +
            (this.player_grid_data.size_y - 1);
        var rows = [];
        for (var row = from_row; row <= max; row++) {
            rows.push(row);
        }
        return rows;
    };

    /**
    * Get all columns and rows that a widget occupies.
    *
    * @method get_cells_occupied
    * @param {Object} el_grid_data The grid coords object of the widget.
    * @return {Object} Returns an object like `{ cols: [], rows: []}`.
    */
    fn.get_cells_occupied = function (el_grid_data) {
        var cells = { cols: [], rows: [] };
        var i;
        if (arguments[1] instanceof jQuery) {
            el_grid_data = arguments[1].coords().grid;
        }

        for (i = 0; i < el_grid_data.size_x; i++) {
            var col = el_grid_data.col + i;
            cells.cols.push(col);
        }

        for (i = 0; i < el_grid_data.size_y; i++) {
            var row = el_grid_data.row + i;
            cells.rows.push(row);
        }

        return cells;
    };


    /**
    * Iterate over the cells occupied by a widget executing a function for
    * each one.
    *
    * @method for_each_cell_occupied
    * @param {Object} el_grid_data The grid coords object that represents the
    *  widget.
    * @param {Function} callback The function to execute on each column
    *  iteration. Column and row are passed as arguments.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.for_each_cell_occupied = function (grid_data, callback) {
        this.for_each_column_occupied(grid_data, function (col) {
            this.for_each_row_occupied(grid_data, function (row) {
                callback.call(this, col, row);
            });
        });
        return this;
    };


    /**
    * Iterate over the columns occupied by a widget executing a function for
    * each one.
    *
    * @method for_each_column_occupied
    * @param {Object} el_grid_data The grid coords object that represents
    *  the widget.
    * @param {Function} callback The function to execute on each column
    *  iteration. The column number is passed as first argument.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.for_each_column_occupied = function (el_grid_data, callback) {
        for (var i = 0; i < el_grid_data.size_x; i++) {
            var col = el_grid_data.col + i;
            callback.call(this, col, el_grid_data);
        }
    };


    /**
    * Iterate over the rows occupied by a widget executing a function for
    * each one.
    *
    * @method for_each_row_occupied
    * @param {Object} el_grid_data The grid coords object that represents
    *  the widget.
    * @param {Function} callback The function to execute on each column
    *  iteration. The row number is passed as first argument.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.for_each_row_occupied = function (el_grid_data, callback) {
        for (var i = 0; i < el_grid_data.size_y; i++) {
            var row = el_grid_data.row + i;
            callback.call(this, row, el_grid_data);
        }
    };

    fn.clean_up_changed = function () {
        $gr = this;
        $gr.$changed.each(function () {
            if ($gr.options.shift_larger_widgets_down) {
                $gr.move_widget_up($(this));
            }
        });
    }



    fn._traversing_widgets = function (type, direction, col, row, callback) {
        var ga = this.gridmap;
        if (!ga[col]) { return; }

        var cr, max;
        var action = type + '/' + direction;
        if (arguments[2] instanceof jQuery) {
            var el_grid_data = arguments[2].coords().grid;
            col = el_grid_data.col;
            row = el_grid_data.row;
            callback = arguments[3];
        }
        var matched = [];
        var trow = row;


        var methods = {
            'for_each/above': function () {
                while (trow--) {
                    if (trow > 0 && this.is_widget(col, trow) &&
                        $.inArray(ga[col][trow], matched) === -1
                    ) {
                        cr = callback.call(ga[col][trow], col, trow);
                        matched.push(ga[col][trow]);
                        if (cr) { break; }
                    }
                }
            },
            'for_each/below': function () {
                for (trow = row + 1, max = ga[col].length; trow < max; trow++) {
                    if (this.is_widget(col, trow) &&
                        $.inArray(ga[col][trow], matched) === -1
                    ) {
                        cr = callback.call(ga[col][trow], col, trow);
                        matched.push(ga[col][trow]);
                        //break was causing problems, leaving for testing.
                        //if (cr) { break; }
                    }
                }
            }
        };

        if (methods[action]) {
            methods[action].call(this);
        }
    };


    /**
    * Iterate over each widget above the column and row specified.
    *
    * @method for_each_widget_above
    * @param {Number} col The column to start iterating.
    * @param {Number} row The row to start iterating.
    * @param {Function} callback The function to execute on each widget
    *  iteration. The value of `this` inside the function is the jQuery
    *  wrapped HTMLElement.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.for_each_widget_above = function (col, row, callback) {
        this._traversing_widgets('for_each', 'above', col, row, callback);
        return this;
    };


    /**
    * Iterate over each widget below the column and row specified.
    *
    * @method for_each_widget_below
    * @param {Number} col The column to start iterating.
    * @param {Number} row The row to start iterating.
    * @param {Function} callback The function to execute on each widget
    *  iteration. The value of `this` inside the function is the jQuery wrapped
    *  HTMLElement.
    * @return {Class} Returns the instance of the Gridster Class.
    */
    fn.for_each_widget_below = function (col, row, callback) {
        this._traversing_widgets('for_each', 'below', col, row, callback);
        return this;
    };


    /**
    * Returns the highest occupied cell in the grid.
    *
    * @method get_highest_occupied_cell
    * @return {Object} Returns an object with `col` and `row` numbers.
    */
    fn.get_highest_occupied_cell = function () {
        var r;
        var gm = this.gridmap;
        var rows = [];
        var row_in_col = [];
        for (var c = gm.length - 1; c >= 1; c--) {
            for (r = gm[c].length - 1; r >= 1; r--) {
                if (this.is_widget(c, r)) {
                    rows.push(r);
                    row_in_col[r] = c;
                    break;
                }
            }
        }

        var highest_row = Math.max.apply(Math, rows);

        this.highest_occupied_cell = {
            col: row_in_col[highest_row],
            row: highest_row
        };

        return this.highest_occupied_cell;
    };


    fn.get_widgets_from = function (col, row) {
        var ga = this.gridmap;
        var $widgets = $();

        if (col) {
            $widgets = $widgets.add(
                this.$widgets.filter(function () {
                    var tcol = $(this).attr('data-col');
                    return (tcol === col || tcol > col);
                })
            );
        }

        if (row) {
            $widgets = $widgets.add(
                this.$widgets.filter(function () {
                    var trow = $(this).attr('data-row');
                    return (trow === row || trow > row);
                })
            );
        }

        return $widgets;
    };


    /**
    * Set the current height of the parent grid.
    *
    * @method set_dom_grid_height
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.set_dom_grid_height = function () {
        var r = this.get_highest_occupied_cell().row;
        this.$el.css('height', r * this.min_widget_height);
        return this;
    };


    /**
    * It generates the neccessary styles to position the widgets.
    *
    * @method generate_stylesheet
    * @param {Number} rows Number of columns.
    * @param {Number} cols Number of rows.
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.generate_stylesheet = function (opts) {
        var styles = '';
        var max_size_x = this.options.max_size_x;
        var max_rows = 0;
        var max_cols = 0;
        var i;
        var rules;

        opts || (opts = {});
        opts.cols || (opts.cols = this.cols);
        opts.rows || (opts.rows = this.rows);
        opts.namespace || (opts.namespace = this.options.namespace);
        opts.widget_base_dimensions ||
            (opts.widget_base_dimensions = this.options.widget_base_dimensions);
        opts.widget_margins ||
            (opts.widget_margins = this.options.widget_margins);
        opts.min_widget_width = (opts.widget_margins[0] * 2) +
            opts.widget_base_dimensions[0];
        opts.min_widget_height = (opts.widget_margins[1] * 2) +
            opts.widget_base_dimensions[1];

        // don't duplicate stylesheets for the same configuration
        var serialized_opts = $.param(opts);
        if ($.inArray(serialized_opts, Gridster.generated_stylesheets) >= 0) {
            return false;
        }

        Gridster.generated_stylesheets.push(serialized_opts);

        /* generate CSS styles for cols */
        for (i = opts.cols; i >= 0; i--) {
            styles += (opts.namespace + ' [data-col="' + (i + 1) + '"] { left:' + (33.75 * (i)) + '%;} ');
            //styles += (opts.namespace + ' [data-col="' + (i + 1) + '"] { left:' +
            //    ((i * dimension) +
            //    //((i * opts.widget_base_dimensions[0]) +
            //    (i * opts.widget_margins[0]) +
            //    ((i + 1) * opts.widget_margins[0])) + 'px;} ');
        }

        /* generate CSS styles for rows */
        for (i = opts.rows; i >= 0; i--) {
            styles += (opts.namespace + ' [data-row="' + (i + 1) + '"] { top:' +
                ((i * opts.widget_base_dimensions[1]) +
                (i * opts.widget_margins[1]) +
                ((i + 1) * opts.widget_margins[1])) + 'px;} ');
        }

        for (var y = 1; y <= opts.rows; y++) {
            styles += (opts.namespace + ' [data-sizey="' + y + '"] { height:' +
                (y * opts.widget_base_dimensions[1] +
                (y - 1) * (opts.widget_margins[1] * 2)) + 'px;}');
        }

        for (var x = 1; x <= max_size_x; x++) {
            styles += (opts.namespace + ' [data-sizex="' + x + '"] { width:' +
                (x * opts.widget_base_dimensions[0] +
                (x - 1) * (opts.widget_margins[0] * 2)) + 'px;}');
        }

        this.remove_style_tags();

        return this.add_style_tag(styles);
    };


    /**
    * Injects the given CSS as string to the head of the document.
    *
    * @method add_style_tag
    * @param {String} css The styles to apply.
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.add_style_tag = function (css) {
        var d = document;
        var tag = d.createElement('style');

        d.getElementsByTagName('head')[0].appendChild(tag);
        tag.setAttribute('type', 'text/css');

        if (tag.styleSheet) {
            tag.styleSheet.cssText = css;
        } else {
            tag.appendChild(document.createTextNode(css));
        }
        return this;
    };


    /**
    * Generates a faux grid to collide with it when a widget is dragged and
    * detect row or column that we want to go.
    *
    * @method generate_faux_grid
    * @param {Number} rows Number of columns.
    * @param {Number} cols Number of rows.
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.generate_faux_grid = function (rows, cols) {
        this.faux_grid = [];
        this.gridmap = [];
        var col;
        var row;
        for (col = cols; col > 0; col--) {
            this.gridmap[col] = [];
            for (row = rows; row > 0; row--) {
                this.add_faux_cell(row, col);
            }
        }
        return this;
    };


    /**
    * Add cell to the faux grid.
    *
    * @method add_faux_cell
    * @param {Number} row The row for the new faux cell.
    * @param {Number} col The col for the new faux cell.
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.add_faux_cell = function (row, col) {
        var coords = $({
            left: this.baseX + ((col - 1) * this.min_widget_width),
            top: this.baseY + (row - 1) * this.min_widget_height,
            width: this.min_widget_width,
            height: this.min_widget_height,
            col: col,
            row: row,
            original_col: col,
            original_row: row
        }).coords();

        if (!$.isArray(this.gridmap[col])) {
            this.gridmap[col] = [];
        }

        this.gridmap[col][row] = false;
        this.faux_grid.push(coords);

        return this;
    };


    /**
    * Add rows to the faux grid.
    *
    * @method add_faux_rows
    * @param {Number} rows The number of rows you want to add to the faux grid.
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.add_faux_rows = function (rows) {
        var actual_rows = this.rows;
        var max_rows = actual_rows + (rows || 1);

        for (var r = max_rows; r > actual_rows; r--) {
            for (var c = this.cols; c >= 1; c--) {
                this.add_faux_cell(r, c);
            }
        }

        this.rows = max_rows;

        if (this.options.autogenerate_stylesheet) {
            this.generate_stylesheet();
        }

        return this;
    };

    /**
   * Add cols to the faux grid.
   *
   * @method add_faux_cols
   * @param {Number} cols The number of cols you want to add to the faux grid.
   * @return {Object} Returns the instance of the Gridster class.
   */
    fn.add_faux_cols = function (cols) {
        var actual_cols = this.cols;
        var max_cols = actual_cols + (cols || 1);

        for (var c = actual_cols; c < max_cols; c++) {
            for (var r = this.rows; r >= 1; r--) {
                this.add_faux_cell(r, c);
            }
        }

        this.cols = max_cols;

        if (this.options.autogenerate_stylesheet) {
            this.generate_stylesheet();
        }

        return this;
    };


    /**
    * Recalculates the offsets for the faux grid. You need to use it when
    * the browser is resized.
    *
    * @method recalculate_faux_grid
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.recalculate_faux_grid = function () {
        var aw = this.$wrapper.width();
        this.baseX = ($(window).width() - aw) / 2;
        this.baseY = this.$wrapper.offset().top;

        $.each(this.faux_grid, $.proxy(function (i, coords) {
            this.faux_grid[i] = coords.update({
                left: this.baseX + (coords.data.col - 1) * this.min_widget_width,
                top: this.baseY + (coords.data.row - 1) * this.min_widget_height
            });

        }, this));

        return this;
    };


    /**
    * Get all widgets in the DOM and register them.
    *
    * @method get_widgets_from_DOM
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.get_widgets_from_DOM = function () {
        this.$widgets.each($.proxy(function (i, widget) {
            this.register_widget($(widget));
        }, this));
        return this;
    };


    /**
    * Calculate columns and rows to be set based on the configuration
    *  parameters, grid dimensions, etc ...
    *
    * @method generate_grid_and_stylesheet
    * @return {Object} Returns the instance of the Gridster class.
    */
    fn.generate_grid_and_stylesheet = function () {
        var aw = this.$wrapper.width();
        var ah = this.$wrapper.height();

        var cols = Math.floor(aw / this.min_widget_width) +
                   this.options.extra_cols;

        var actual_cols = this.$widgets.map(function () {
            return $(this).attr('data-col');
        });
        actual_cols = Array.prototype.slice.call(actual_cols, 0);
        //needed to pass tests with phantomjs
        actual_cols.length || (actual_cols = [0]);

        var min_cols = Math.max.apply(Math, actual_cols);

        // get all rows that could be occupied by the current widgets
        var max_rows = this.options.extra_rows;
        this.$widgets.each(function (i, w) {
            max_rows += (+$(w).attr('data-sizey'));
        });

        this.cols = Math.max(min_cols, cols, this.options.min_cols);
        //this.rows = Math.max(max_rows, this.options.min_rows);
        this.rows = this.options.max_rows;

        this.baseX = ($(window).width() - aw) / 2;
        this.baseY = this.$wrapper.offset().top;

        if (this.options.autogenerate_stylesheet) {
            this.generate_stylesheet();
        }

        return this.generate_faux_grid(this.rows, this.cols);
    };


    //jQuery adapter
    $.fn.gridster = function (options) {
        return this.each(function () {
            if (!$(this).data('gridster')) {
                $(this).data('gridster', new Gridster(this, options));
            }
        });
    };

    $.Gridster = fn;

}(jQuery, window, document));

; (function ($, window, document, undefined) {

    var fn = $.Gridster;

    fn.widgets_in_col = function (col) {
        if (!this.gridmap[col]) {
            return false;
        }

        for (var i = this.gridmap[col].length - 1; i >= 0; i--) {
            if (this.is_widget(col, i) !== false) {
                return true;
            }
        }

        return false;
    };

    fn.widgets_in_row = function (row) {
        for (var i = this.gridmap.length; i >= 1; i--) {
            if (this.is_widget(i, row) !== false) {
                return true;
            }
        }

        return false;
    };


    fn.widgets_in_range = function (col1, row1, col2, row2) {
        var valid_cols = [];
        var valid_rows = [];
        var $widgets = $([]);
        var c, r, $w, wgd;

        for (c = col2; c >= col1; c--) {
            for (r = row2; r >= row1; r--) {
                $w = this.is_widget(c, r);

                if ($w !== false) {
                    wgd = $w.data('coords').grid;
                    if (wgd.col >= col1 && wgd.col <= col2 &&
                        wgd.row >= row1 && wgd.row <= row2
                       ) {
                        $widgets = $widgets.add($w);
                    }
                }
            }
        }

        return $widgets;
    };


    fn.get_bottom_most_occupied_cell = function () {
        var row = 0;
        var col = 0;
        this.for_each_cell(function ($el, c, r) {
            if ($el && r > row) {
                row = r;
                col = c;
            }
        });

        return { col: col, row: row };
    };


    fn.get_right_most_occupied_cell = function () {
        var row = 0;
        var col = 0;
        this.for_each_cell(function ($el, c, r) {
            if ($el) {
                row = r;
                col = c;
                return false;
            }
        });

        return { col: col, row: row };
    };


    fn.for_each_cell = function (callback, gridmap) {
        gridmap || (gridmap = this.gridmap);
        var cols = gridmap.length;
        var rows = gridmap[1].length;

        cols_iter:
            for (var c = cols - 1; c >= 1; c--) {
                for (var r = rows - 1; r >= 1; r--) {
                    var $el = gridmap[c] && gridmap[c][r];
                    if (callback) {
                        if (callback.call(this, $el, c, r) === false) {
                            break cols_iter;
                        } else { continue; }
                    }
                }
            }
    };


    fn.next_position_in_range = function (size_x, size_y, max_rows) {
        size_x || (size_x = 1);
        size_y || (size_y = 1);
        var ga = this.gridmap;
        var cols_l = ga.length;
        var valid_pos = [];
        var rows_l;

        for (var c = 1; c < cols_l; c++) {
            rows_l = max_rows || ga[c].length;
            for (var r = 1; r <= rows_l; r++) {
                var can_move_to = this.can_move_to({
                    size_x: size_x,
                    size_y: size_y
                }, c, r, max_rows);

                if (can_move_to) {
                    valid_pos.push({
                        col: c,
                        row: r,
                        size_y: size_y,
                        size_x: size_x
                    });
                }
            }
        }

        if (valid_pos.length >= 1) {
            return this.sort_by_col_asc(valid_pos)[0];
        }

        return false;
    };


    fn.closest_to_right = function (col, row) {
        if (!this.gridmap[col]) { return false; }
        var cols_l = this.gridmap.length - 1;

        for (var c = col; c <= cols_l; c++) {
            if (this.gridmap[c][row]) {
                return { col: c, row: row };
            }
        }

        return false;
    };


    fn.closest_to_left = function (col, row) {
        var cols_l = this.gridmap.length - 1;
        if (!this.gridmap[col]) { return false; }

        for (var c = col; c >= 1; c--) {
            if (this.gridmap[c][row]) {
                return { col: c, row: row };
            }
        }

        return false;
    };

}(jQuery, window, document));

/*! http://mths.be/placeholder v2.0.7 by @mathias */
;(function(window, document, $) {

	var isInputSupported = 'placeholder' in document.createElement('input');
	var isTextareaSupported = 'placeholder' in document.createElement('textarea');
	var prototype = $.fn;
	var valHooks = $.valHooks;
	var propHooks = $.propHooks;
	var hooks;
	var placeholder;

	if (isInputSupported && isTextareaSupported) {

		placeholder = prototype.placeholder = function() {
			return this;
		};

		placeholder.input = placeholder.textarea = true;

	} else {

		placeholder = prototype.placeholder = function() {
			var $this = this;
			$this
				.filter((isInputSupported ? 'textarea' : ':input') + '[placeholder]')
				.not('.placeholder')
				.bind({
					'focus.placeholder': clearPlaceholder,
					'blur.placeholder': setPlaceholder
				})
				.data('placeholder-enabled', true)
				.trigger('blur.placeholder');
			return $this;
		};

		placeholder.input = isInputSupported;
		placeholder.textarea = isTextareaSupported;

		hooks = {
			'get': function(element) {
				var $element = $(element);

				var $passwordInput = $element.data('placeholder-password');
				if ($passwordInput) {
					return $passwordInput[0].value;
				}

				return $element.data('placeholder-enabled') && $element.hasClass('placeholder') ? '' : element.value;
			},
			'set': function(element, value) {
				var $element = $(element);

				var $passwordInput = $element.data('placeholder-password');
				if ($passwordInput) {
					return $passwordInput[0].value = value;
				}

				if (!$element.data('placeholder-enabled')) {
					return element.value = value;
				}
				if (value == '') {
					element.value = value;
					// Issue #56: Setting the placeholder causes problems if the element continues to have focus.
					if (element != document.activeElement) {
						// We can't use `triggerHandler` here because of dummy text/password inputs :(
						setPlaceholder.call(element);
					}
				} else if ($element.hasClass('placeholder')) {
					clearPlaceholder.call(element, true, value) || (element.value = value);
				} else {
					element.value = value;
				}
				// `set` can not return `undefined`; see http://jsapi.info/jquery/1.7.1/val#L2363
				return $element;
			}
		};

		if (!isInputSupported) {
			valHooks.input = hooks;
			propHooks.value = hooks;
		}
		if (!isTextareaSupported) {
			valHooks.textarea = hooks;
			propHooks.value = hooks;
		}

		$(function() {
			// Look for forms
			$(document).delegate('form', 'submit.placeholder', function() {
				// Clear the placeholder values so they don't get submitted
				var $inputs = $('.placeholder', this).each(clearPlaceholder);
				setTimeout(function() {
					$inputs.each(setPlaceholder);
				}, 10);
			});
		});

		// Clear placeholder values upon page reload
		$(window).bind('beforeunload.placeholder', function() {
			$('.placeholder').each(function() {
				this.value = '';
			});
		});

	}

	function args(elem) {
		// Return an object of element attributes
		var newAttrs = {};
		var rinlinejQuery = /^jQuery\d+$/;
		$.each(elem.attributes, function(i, attr) {
			if (attr.specified && !rinlinejQuery.test(attr.name)) {
				newAttrs[attr.name] = attr.value;
			}
		});
		return newAttrs;
	}

	function clearPlaceholder(event, value) {
		var input = this;
		var $input = $(input);
		if (input.value == $input.attr('placeholder') && $input.hasClass('placeholder')) {
			if ($input.data('placeholder-password')) {
				$input = $input.hide().next().show().attr('id', $input.removeAttr('id').data('placeholder-id'));
				// If `clearPlaceholder` was called from `$.valHooks.input.set`
				if (event === true) {
					return $input[0].value = value;
				}
				$input.focus();
			} else {
				input.value = '';
				$input.removeClass('placeholder');
				input == document.activeElement && input.select();
			}
		}
	}

	function setPlaceholder() {
		var $replacement;
		var input = this;
		var $input = $(input);
		var id = this.id;
		if (input.value == '') {
			if (input.type == 'password') {
				if (!$input.data('placeholder-textinput')) {
					try {
						$replacement = $input.clone().attr({ 'type': 'text' });
					} catch(e) {
						$replacement = $('<input>').attr($.extend(args(this), { 'type': 'text' }));
					}
					$replacement
						.removeAttr('name')
						.data({
							'placeholder-password': $input,
							'placeholder-id': id
						})
						.bind('focus.placeholder', clearPlaceholder);
					$input
						.data({
							'placeholder-textinput': $replacement,
							'placeholder-id': id
						})
						.before($replacement);
				}
				$input = $input.removeAttr('id').hide().prev().attr('id', id).show();
				// Note: `$input[0] != input` now!
			}
			$input.addClass('placeholder');
			$input[0].value = $input.attr('placeholder');
		} else {
			$input.removeClass('placeholder');
		}
	}

}(this, document, jQuery));

; (function ($, window, document, undefined) {

    var pluginName = "validform",
        defaults = {
            type: "empty"
        };

    function Plugin(element, options) {
        this.element = $(element);

        this.options = $.extend({}, defaults, options);

        this._defaults = defaults;
        this._name = pluginName;

        this.init();
    }

    Plugin.prototype = {
        init: function () {
            if (typeof this.options.invalid !== 'undefined')
                this.invalid = this.options.invalid;
        },
        // Funcao que da trim na string
        trim: function (_text) {
            return _text.replace(/^\s*|\s*$/g, "");
        },
        invalid: function (sClass) {
            var elem = this.element;
            if (sClass)
                elem = this.element.parent().find(sClass);
            else if (typeof this.options.parent !== 'undefined')
                elem = this.element.parent();

            if (typeof this.options.bgcolor !== 'undefined') {
                if (!elem.data('background-color'))
                    elem.data('background-color', elem.css('background-color')).css('background-color', this.options.bgcolor).on('focus, click', function () { elem.css('background-color', elem.data('background-color')) });
                else
                    elem.css('background-color', this.options.bgcolor);
            }
            if (typeof this.options.textcolor !== 'undefined') {
                if (!elem.data('color'))
                    elem.data('color', elem.css('color')).css('color', this.options.textcolor).on('focus, click', function () { elem.css('color', elem.data('color')) });
                else
                    elem.css('color', this.options.textcolor);
            }
            if (typeof this.options.border !== 'undefined') {
                if (!elem.data('border'))
                    elem.data('border', elem.css('border')).css('border', this.options.border).on('focus, click', function () { elem.css('border', elem.data('border')) });
                else
                    elem.css('border', this.options.border);
            }
            if (typeof this.options.labelcolor !== 'undefined') {
                var $label = (elem.hasClass('valida-prev')) ? elem.prev() : elem.parent().find('label');

                if (!$label.data('color')) {
                    $label.data('color', $label.css('color')).css('color', this.options.labelcolor);
                    elem.on('focus', function () { $label.css('color', $label.data('color')) });
                } else {
                    $label.css('color', this.options.labelcolor);
                }
            }
            if (typeof this.options.errorClass !== 'undefined') {
                var eClass = this.options.errorClass;
                elem.addClass(eClass);
                elem.on('focus click', function () { elem.removeClass(eClass); });
            }
        },
        empty: function () {
            val = this.element.val();
            if (this.trim(val) == '')
                return false;

            if (typeof this.element.data('minchar') !== 'undefined' && this.trim(val).length < this.element.data('minchar'))
                return false;

            return true;
        },
        select: function () {
            val = this.trim(this.element.val());
            if (val == 0 || val == '' || val == false) {
                return false;
            }
            return true;
        },
        email: function () {
            val = this.element.val();
            if (!this.empty(val)) return false;
            var reg1 = /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/i;
            var reg2 = /\.\./i;
            if (!val.match(reg1) || val.match(reg2)) {
                return false;
            }
            return true;
        },
        equal: function (element2) {
            if (this.empty(this.element) && this.empty(element2)) {
                if (this.element.val() !== element2.val())
                    return false;
                else
                    return true;

            } else {
                return false;
            }
        },
        cpf: function () {
            var cpf = this.element.val();
            if (!this.empty(val)) return false;
            exp = /\.|\-/g;
            cpf = cpf.toString().replace(exp, "");
            var digitoDigitado = eval(cpf.charAt(9) + cpf.charAt(10));
            var soma1 = 0, soma2 = 0;
            var vlr = 11;

            for (i = 0; i < 9; i++) {
                soma1 += eval(cpf.charAt(i) * (vlr - 1));
                soma2 += eval(cpf.charAt(i) * vlr);
                vlr--;
            }
            soma1 = (((soma1 * 10) % 11) == 10 ? 0 : ((soma1 * 10) % 11));
            soma2 = (((soma2 + (2 * soma1)) * 10) % 11);

            soma2 = (soma2 == 10) ? 0 : soma2;

            var digitoGerado = (soma1 * 10) + soma2;
            if (digitoGerado != digitoDigitado) {
                return false;
            }
            return true;
        },
        data: function () {
            var date = this.element.val();
            if (!this.empty(date)) return false;
            var matches = /^(\d{2})[-\/](\d{2})[-\/](\d{4})$/.exec(date);
            if (matches == null) return false;
            var d = matches[1];
            var m = matches[2] - 1;
            var y = matches[3];
            var composedDate = new Date(y, m, d);

            var valid = composedDate.getDate() == d &&
                    composedDate.getMonth() == m &&
                    composedDate.getFullYear() == y;

            return valid;
        },
        checked: function (elements) {
            if (elements.filter(':checked').length > 0) {
                return true;
            } else {
                return false;
            }
        }
    };

    $.fn[pluginName] = function (options) {
        return this.each(function () {
            if (!$.data(this, "plugin_" + pluginName)) {
                $.data(this, "plugin_" + pluginName, new Plugin(this, options));
            }
        });
    };

})(jQuery, window, document);
/*
 * Lemmon Slider - jQuery Plugin
 * Simple and lightweight slider/carousel supporting variable elements/images widths.
 *
 * Examples and documentation at: http://jquery.lemmonjuice.com/plugins/slider-variable-widths.php
 *
 * Copyright (c) 2011 Jakub Pelák <jpelak@gmail.com>
 *
 * Version: 0.2 (9/6/2011)
 * Requires: jQuery v1.4+
 *
 * Licensed under the MIT license:
 *   http://www.opensource.org/licenses/mit-license.php
 */
(function( $ ){

	var _css = {};

	var methods = {
		//
		// Initialzie plugin
		//
		init : function(options){

			var options = $.extend({}, $.fn.lemmonSlider.defaults, options);

			return this.each(function(){

				var $slider = $( this ),
				    data = $slider.data( 'slider' );

				if ( ! data ){

					var $sliderContainer = $slider.find(options.slider),
					    $sliderControls = $slider.next().filter('.controls'),
					    $items = $sliderContainer.find( options.items ),
					    originalWidth = 1;

					$items.each(function(){ originalWidth += $(this).outerWidth(true) });
					$sliderContainer.width( originalWidth );

					// slide to last item
					if ( options.slideToLast ) $sliderContainer.css( 'padding-right', $slider.width() );

					// infinite carousel
					if ( options.infinite ){
						$slider.attr('data-slider-infinite',true)

						originalWidth = originalWidth * 3;
						$sliderContainer.width( originalWidth );

						$items.clone().addClass( '-after' ).insertAfter( $items.filter(':last') );
						$items.filter( ':first' ).before( $items.clone().addClass('-before') );

					    $items = $sliderContainer.find( options.items );

					}

					$slider.items = $items;
					$slider.options = options;

					// first item
					//$items.filter( ':first' ).addClass( 'active' );

					// attach events
					$slider.bind( 'nextSlide', function( e, t ){

						var scroll = $slider.scrollLeft();
						var x = 0;
						var slide = 0;

						$items.each(function( i ){
							if ( x == 0 && $( this ).position().left > 1 ){
								x = $( this ).position().left;
								slide = i;
							}
						});

						if ( x > 0 && $sliderContainer.outerWidth() - scroll - $slider.width() - 1 > 0 ){
							slideTo( e, $slider, scroll+x, slide, 'fast' );
						} else if ( options.loop ){
							// return to first
							slideTo( e, $slider, 0, 0, 'slow' );
						}

					});
					$slider.bind( 'prevSlide', function( e, t ){

						var scroll = $slider.scrollLeft();
						var x = 0;
						var slide = 0;

						$items.each(function( i ){
							if ( $( this ).position().left < 0 ){
								x = $( this ).position().left;
								slide = i;
							}
						});

						if ( x ){
							slideTo( e, $slider, scroll+x, slide, 'fast' )
						} else if ( options.loop ){
							// return to last
							var a = $sliderContainer.outerWidth() - $slider.width();
							var b = $items.filter( ':last' ).position().left;
							slide = $items.size() - 1;
							if ( a > b ){
								slideTo( e, $slider, b, slide, 'fast' );
							} else {
								slideTo( e, $slider, a, slide, 'fast' );
							}
						}

					});
					$slider.bind( 'nextPage', function( e, t ){

						var scroll = $slider.scrollLeft();
						var w = $slider.width();
						var x = 0;
						var slide = 0;

						$items.each(function( i ){
							if ( $( this ).position().left < w ){
								x = $( this ).position().left;
								slide = i;
							}
						});

						if ( x > 0 && scroll + w + 1 < originalWidth ){
							slideTo( e, $slider, scroll+x, slide, 'slow' );
						} else if ( options.loop ){
							// return to first
							slideTo( e, $slider, 0, 0, 'slow' );
						}

					});
					$slider.bind( 'prevPage', function( e, t ){

						var scroll = $slider.scrollLeft();
						var w = $slider.width();
						var x = 0;

						$items.each(function( i ){
							if ( $( this ).position().left < 1 - w ){
								x = $( this ).next().position().left;
								slide = i;
							}
						});

						if ( scroll ){
							if ( x == 0 ){
								//$slider.animate({ 'scrollLeft' : 0 }, 'slow' );
								slideTo( e, $slider, 0, 0, 'slow' );
							} else {
								//$slider.animate({ 'scrollLeft' : scroll + x }, 'slow' );
								slideTo( e, $slider, scroll+x, slide, 'slow' );
							}
						} else if ( options.loop ) {
							// return to last
							var a = $sliderContainer.outerWidth() - $slider.width();
							var b = $items.filter( ':last' ).position().left;
							if ( a > b ){
								$slider.animate({ 'scrollLeft' : b }, 'slow' );
							} else {
								$slider.animate({ 'scrollLeft' : a }, 'slow' );
							}
						}

					});
					$slider.bind( 'slideTo', function( e, i, t ){

						slideTo(
							e, $slider,
							$slider.scrollLeft() + $items.filter( ':eq(' + i +')' ).position().left,
							i, t );

					});

					// controls
					$sliderControls.find( '.next-slide' ).click(function(){
						$slider.trigger( 'nextSlide' );
						return false;
					});
					$sliderControls.find( '.prev-slide' ).click(function(){
						$slider.trigger( 'prevSlide' );
						return false;
					});
					$sliderControls.find( '.next-page' ).click(function(){
						$slider.trigger( 'nextPage' );
						return false;
					});
					$sliderControls.find( '.prev-page' ).click(function(){
						$slider.trigger( 'prevPage' );
						return false;
					});

					//if ( typeof $slider.options.create == 'function' ) $slider.options.create();

					$slider.data( 'slider', {
						'target'  : $slider,
						'options' : options
					})

				}

			});

		},
		//
    // Add Item
    //
    addItem : function(options){
        var options = $.extend({}, $.fn.lemmonSlider.defaults, options);

        var $slider = $( this ),
            $sliderContainer = $slider.find(options.slider),
            $sliderControls = $slider.next().filter('.controls'),
            $items = $sliderContainer.find( options.items )

        options.infinite = $slider.attr('data-slider-infinite')

        if (!options.item) { return false }
        methods.destroy.apply(this);
        if (options.prepend) {
            $sliderContainer.prepend(options.item);
        } else {
            $sliderContainer.append(options.item);
        }
        methods.init.apply( this, [options]);
    },
		//
		// Destroy plugin
		//
		destroy : function(){

			return this.each(function(){

				var $slider = $( this ),
				    $sliderControls = $slider.next().filter( '.controls' ),
				    $items = $slider.find('> *:first > *'),
				    data = $slider.data( 'slider' );

				$slider.unbind( 'nextSlide' );
				$slider.unbind( 'prevSlide' );
				$slider.unbind( 'nextPage' );
				$slider.unbind( 'prevPage' );
				$slider.unbind( 'slideTo' );

				$sliderControls.find( '.next-slide' ).unbind( 'click' );
				$sliderControls.find( '.prev-slide' ).unbind( 'click' );
				$sliderControls.find( '.next-page' ).unbind( 'click' );
				$sliderControls.find( '.next-page' ).unbind( 'click' );

				$slider.removeData( 'slider' );

				if ($slider.attr('data-slider-infinite')) {
            $.merge($items.filter('.-before'),$items.filter('.-after')).each(function(index,item){
                $(item).remove();
            });
        }
			});

		}
		//
		//
		//
	}
	//
	// Private functions
	//
	function slideTo( e, $slider, x, i, t ){

		$slider.items.filter( 'li:eq(' + i + ')' ).addClass( 'active' ).siblings( '.active' ).removeClass( 'active' );

		if ( typeof t == 'undefined' ){
			t = 'fast';
		}
		if ( t ){
			$slider.animate({ 'scrollLeft' : x }, t, function(){
				checkInfinite( $slider );
			});
		} else {
			var time = 0;
			$slider.scrollLeft( x );
			checkInfinite( $slider );
		}

		//if ( typeof $slider.options.slide == 'function' ) $slider.options.slide( e, i, time );

	}
	function checkInfinite( $slider ){

		var $active = $slider.items.filter( '.active' );
		if ( $active.hasClass( '-before' ) ){

			var i = $active.prevAll().size();
			$active.removeClass( 'active' );
			$active = $slider.items.filter( ':not(.-before):eq(' + i + ')' ).addClass( 'active' );
			$slider.scrollLeft( $slider.scrollLeft() + $active.position().left );

		} else if ( $active.hasClass( '-after' ) ){

			var i = $active.prevAll( '.-after' ).size();
			$active.removeClass( 'active' );
			$active = $slider.items.filter( ':not(.-before):eq(' + i + ')' ).addClass( 'active' );
			$slider.scrollLeft( $slider.scrollLeft() + $active.position().left );

		}

	}
	//
	// Debug
	//
	function debug( text ){
		$( '#debug span' ).text( text );
	}
	//
	//
	//
	$.fn.lemmonSlider = function( method , options ){
		if (options == null) { options = {}; };
		if ( methods[method] ) {
			return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
		} else if ( typeof method === 'object' || !method ){
			return methods.init.apply( this, arguments );
		} else {
			$.error( 'Method ' +  method + ' does not exist on jQuery.lemmonSlider' );
		}

	};
	//
	//
	//
	$.fn.lemmonSlider.defaults = {

		'items'       : '> *',
		'loop'        : true,
		'slideToLast' : false,
		'slider'      : '> *:first',
		// since 0.2
		'infinite'    : false

	}

})( jQuery );

//! moment.js
//! version : 2.3.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
(function(a){function b(a,b){return function(c){return i(a.call(this,c),b)}}function c(a,b){return function(c){return this.lang().ordinal(a.call(this,c),b)}}function d(){}function e(a){u(a),g(this,a)}function f(a){var b=o(a),c=b.year||0,d=b.month||0,e=b.week||0,f=b.day||0,g=b.hour||0,h=b.minute||0,i=b.second||0,j=b.millisecond||0;this._input=a,this._milliseconds=+j+1e3*i+6e4*h+36e5*g,this._days=+f+7*e,this._months=+d+12*c,this._data={},this._bubble()}function g(a,b){for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c]);return b.hasOwnProperty("toString")&&(a.toString=b.toString),b.hasOwnProperty("valueOf")&&(a.valueOf=b.valueOf),a}function h(a){return 0>a?Math.ceil(a):Math.floor(a)}function i(a,b){for(var c=a+"";c.length<b;)c="0"+c;return c}function j(a,b,c,d){var e,f,g=b._milliseconds,h=b._days,i=b._months;g&&a._d.setTime(+a._d+g*c),(h||i)&&(e=a.minute(),f=a.hour()),h&&a.date(a.date()+h*c),i&&a.month(a.month()+i*c),g&&!d&&bb.updateOffset(a),(h||i)&&(a.minute(e),a.hour(f))}function k(a){return"[object Array]"===Object.prototype.toString.call(a)}function l(a){return"[object Date]"===Object.prototype.toString.call(a)}function m(a,b,c){var d,e=Math.min(a.length,b.length),f=Math.abs(a.length-b.length),g=0;for(d=0;e>d;d++)(c&&a[d]!==b[d]||!c&&q(a[d])!==q(b[d]))&&g++;return g+f}function n(a){if(a){var b=a.toLowerCase().replace(/(.)s$/,"$1");a=Jb[a]||Kb[b]||b}return a}function o(a){var b,c,d={};for(c in a)a.hasOwnProperty(c)&&(b=n(c),b&&(d[b]=a[c]));return d}function p(b){var c,d;if(0===b.indexOf("week"))c=7,d="day";else{if(0!==b.indexOf("month"))return;c=12,d="month"}bb[b]=function(e,f){var g,h,i=bb.fn._lang[b],j=[];if("number"==typeof e&&(f=e,e=a),h=function(a){var b=bb().utc().set(d,a);return i.call(bb.fn._lang,b,e||"")},null!=f)return h(f);for(g=0;c>g;g++)j.push(h(g));return j}}function q(a){var b=+a,c=0;return 0!==b&&isFinite(b)&&(c=b>=0?Math.floor(b):Math.ceil(b)),c}function r(a,b){return new Date(Date.UTC(a,b+1,0)).getUTCDate()}function s(a){return t(a)?366:365}function t(a){return 0===a%4&&0!==a%100||0===a%400}function u(a){var b;a._a&&-2===a._pf.overflow&&(b=a._a[gb]<0||a._a[gb]>11?gb:a._a[hb]<1||a._a[hb]>r(a._a[fb],a._a[gb])?hb:a._a[ib]<0||a._a[ib]>23?ib:a._a[jb]<0||a._a[jb]>59?jb:a._a[kb]<0||a._a[kb]>59?kb:a._a[lb]<0||a._a[lb]>999?lb:-1,a._pf._overflowDayOfYear&&(fb>b||b>hb)&&(b=hb),a._pf.overflow=b)}function v(a){a._pf={empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1}}function w(a){return null==a._isValid&&(a._isValid=!isNaN(a._d.getTime())&&a._pf.overflow<0&&!a._pf.empty&&!a._pf.invalidMonth&&!a._pf.nullInput&&!a._pf.invalidFormat&&!a._pf.userInvalidated,a._strict&&(a._isValid=a._isValid&&0===a._pf.charsLeftOver&&0===a._pf.unusedTokens.length)),a._isValid}function x(a){return a?a.toLowerCase().replace("_","-"):a}function y(a,b){return b.abbr=a,mb[a]||(mb[a]=new d),mb[a].set(b),mb[a]}function z(a){delete mb[a]}function A(a){var b,c,d,e,f=0,g=function(a){if(!mb[a]&&nb)try{require("./lang/"+a)}catch(b){}return mb[a]};if(!a)return bb.fn._lang;if(!k(a)){if(c=g(a))return c;a=[a]}for(;f<a.length;){for(e=x(a[f]).split("-"),b=e.length,d=x(a[f+1]),d=d?d.split("-"):null;b>0;){if(c=g(e.slice(0,b).join("-")))return c;if(d&&d.length>=b&&m(e,d,!0)>=b-1)break;b--}f++}return bb.fn._lang}function B(a){return a.match(/\[[\s\S]/)?a.replace(/^\[|\]$/g,""):a.replace(/\\/g,"")}function C(a){var b,c,d=a.match(rb);for(b=0,c=d.length;c>b;b++)d[b]=Ob[d[b]]?Ob[d[b]]:B(d[b]);return function(e){var f="";for(b=0;c>b;b++)f+=d[b]instanceof Function?d[b].call(e,a):d[b];return f}}function D(a,b){return a.isValid()?(b=E(b,a.lang()),Lb[b]||(Lb[b]=C(b)),Lb[b](a)):a.lang().invalidDate()}function E(a,b){function c(a){return b.longDateFormat(a)||a}var d=5;for(sb.lastIndex=0;d>=0&&sb.test(a);)a=a.replace(sb,c),sb.lastIndex=0,d-=1;return a}function F(a,b){var c;switch(a){case"DDDD":return vb;case"YYYY":case"GGGG":case"gggg":return wb;case"YYYYY":case"GGGGG":case"ggggg":return xb;case"S":case"SS":case"SSS":case"DDD":return ub;case"MMM":case"MMMM":case"dd":case"ddd":case"dddd":return yb;case"a":case"A":return A(b._l)._meridiemParse;case"X":return Bb;case"Z":case"ZZ":return zb;case"T":return Ab;case"MM":case"DD":case"YY":case"GG":case"gg":case"HH":case"hh":case"mm":case"ss":case"M":case"D":case"d":case"H":case"h":case"m":case"s":case"w":case"ww":case"W":case"WW":case"e":case"E":return tb;default:return c=new RegExp(N(M(a.replace("\\","")),"i"))}}function G(a){var b=(zb.exec(a)||[])[0],c=(b+"").match(Gb)||["-",0,0],d=+(60*c[1])+q(c[2]);return"+"===c[0]?-d:d}function H(a,b,c){var d,e=c._a;switch(a){case"M":case"MM":null!=b&&(e[gb]=q(b)-1);break;case"MMM":case"MMMM":d=A(c._l).monthsParse(b),null!=d?e[gb]=d:c._pf.invalidMonth=b;break;case"D":case"DD":null!=b&&(e[hb]=q(b));break;case"DDD":case"DDDD":null!=b&&(c._dayOfYear=q(b));break;case"YY":e[fb]=q(b)+(q(b)>68?1900:2e3);break;case"YYYY":case"YYYYY":e[fb]=q(b);break;case"a":case"A":c._isPm=A(c._l).isPM(b);break;case"H":case"HH":case"h":case"hh":e[ib]=q(b);break;case"m":case"mm":e[jb]=q(b);break;case"s":case"ss":e[kb]=q(b);break;case"S":case"SS":case"SSS":e[lb]=q(1e3*("0."+b));break;case"X":c._d=new Date(1e3*parseFloat(b));break;case"Z":case"ZZ":c._useUTC=!0,c._tzm=G(b);break;case"w":case"ww":case"W":case"WW":case"d":case"dd":case"ddd":case"dddd":case"e":case"E":a=a.substr(0,1);case"gg":case"gggg":case"GG":case"GGGG":case"GGGGG":a=a.substr(0,2),b&&(c._w=c._w||{},c._w[a]=b)}}function I(a){var b,c,d,e,f,g,h,i,j,k,l=[];if(!a._d){for(d=K(a),a._w&&null==a._a[hb]&&null==a._a[gb]&&(f=function(b){return b?b.length<3?parseInt(b,10)>68?"19"+b:"20"+b:b:null==a._a[fb]?bb().weekYear():a._a[fb]},g=a._w,null!=g.GG||null!=g.W||null!=g.E?h=X(f(g.GG),g.W||1,g.E,4,1):(i=A(a._l),j=null!=g.d?T(g.d,i):null!=g.e?parseInt(g.e,10)+i._week.dow:0,k=parseInt(g.w,10)||1,null!=g.d&&j<i._week.dow&&k++,h=X(f(g.gg),k,j,i._week.doy,i._week.dow)),a._a[fb]=h.year,a._dayOfYear=h.dayOfYear),a._dayOfYear&&(e=null==a._a[fb]?d[fb]:a._a[fb],a._dayOfYear>s(e)&&(a._pf._overflowDayOfYear=!0),c=S(e,0,a._dayOfYear),a._a[gb]=c.getUTCMonth(),a._a[hb]=c.getUTCDate()),b=0;3>b&&null==a._a[b];++b)a._a[b]=l[b]=d[b];for(;7>b;b++)a._a[b]=l[b]=null==a._a[b]?2===b?1:0:a._a[b];l[ib]+=q((a._tzm||0)/60),l[jb]+=q((a._tzm||0)%60),a._d=(a._useUTC?S:R).apply(null,l)}}function J(a){var b;a._d||(b=o(a._i),a._a=[b.year,b.month,b.day,b.hour,b.minute,b.second,b.millisecond],I(a))}function K(a){var b=new Date;return a._useUTC?[b.getUTCFullYear(),b.getUTCMonth(),b.getUTCDate()]:[b.getFullYear(),b.getMonth(),b.getDate()]}function L(a){a._a=[],a._pf.empty=!0;var b,c,d,e,f,g=A(a._l),h=""+a._i,i=h.length,j=0;for(d=E(a._f,g).match(rb)||[],b=0;b<d.length;b++)e=d[b],c=(F(e,a).exec(h)||[])[0],c&&(f=h.substr(0,h.indexOf(c)),f.length>0&&a._pf.unusedInput.push(f),h=h.slice(h.indexOf(c)+c.length),j+=c.length),Ob[e]?(c?a._pf.empty=!1:a._pf.unusedTokens.push(e),H(e,c,a)):a._strict&&!c&&a._pf.unusedTokens.push(e);a._pf.charsLeftOver=i-j,h.length>0&&a._pf.unusedInput.push(h),a._isPm&&a._a[ib]<12&&(a._a[ib]+=12),a._isPm===!1&&12===a._a[ib]&&(a._a[ib]=0),I(a),u(a)}function M(a){return a.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(a,b,c,d,e){return b||c||d||e})}function N(a){return a.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function O(a){var b,c,d,e,f;if(0===a._f.length)return a._pf.invalidFormat=!0,a._d=new Date(0/0),void 0;for(e=0;e<a._f.length;e++)f=0,b=g({},a),v(b),b._f=a._f[e],L(b),w(b)&&(f+=b._pf.charsLeftOver,f+=10*b._pf.unusedTokens.length,b._pf.score=f,(null==d||d>f)&&(d=f,c=b));g(a,c||b)}function P(a){var b,c=a._i,d=Cb.exec(c);if(d){for(b=4;b>0;b--)if(d[b]){a._f=Eb[b-1]+(d[6]||" ");break}for(b=0;4>b;b++)if(Fb[b][1].exec(c)){a._f+=Fb[b][0];break}zb.exec(c)&&(a._f+=" Z"),L(a)}else a._d=new Date(c)}function Q(b){var c=b._i,d=ob.exec(c);c===a?b._d=new Date:d?b._d=new Date(+d[1]):"string"==typeof c?P(b):k(c)?(b._a=c.slice(0),I(b)):l(c)?b._d=new Date(+c):"object"==typeof c?J(b):b._d=new Date(c)}function R(a,b,c,d,e,f,g){var h=new Date(a,b,c,d,e,f,g);return 1970>a&&h.setFullYear(a),h}function S(a){var b=new Date(Date.UTC.apply(null,arguments));return 1970>a&&b.setUTCFullYear(a),b}function T(a,b){if("string"==typeof a)if(isNaN(a)){if(a=b.weekdaysParse(a),"number"!=typeof a)return null}else a=parseInt(a,10);return a}function U(a,b,c,d,e){return e.relativeTime(b||1,!!c,a,d)}function V(a,b,c){var d=eb(Math.abs(a)/1e3),e=eb(d/60),f=eb(e/60),g=eb(f/24),h=eb(g/365),i=45>d&&["s",d]||1===e&&["m"]||45>e&&["mm",e]||1===f&&["h"]||22>f&&["hh",f]||1===g&&["d"]||25>=g&&["dd",g]||45>=g&&["M"]||345>g&&["MM",eb(g/30)]||1===h&&["y"]||["yy",h];return i[2]=b,i[3]=a>0,i[4]=c,U.apply({},i)}function W(a,b,c){var d,e=c-b,f=c-a.day();return f>e&&(f-=7),e-7>f&&(f+=7),d=bb(a).add("d",f),{week:Math.ceil(d.dayOfYear()/7),year:d.year()}}function X(a,b,c,d,e){var f,g,h=new Date(Date.UTC(a,0)).getUTCDay();return c=null!=c?c:e,f=e-h+(h>d?7:0),g=7*(b-1)+(c-e)+f+1,{year:g>0?a:a-1,dayOfYear:g>0?g:s(a-1)+g}}function Y(a){var b=a._i,c=a._f;return"undefined"==typeof a._pf&&v(a),null===b?bb.invalid({nullInput:!0}):("string"==typeof b&&(a._i=b=A().preparse(b)),bb.isMoment(b)?(a=g({},b),a._d=new Date(+b._d)):c?k(c)?O(a):L(a):Q(a),new e(a))}function Z(a,b){bb.fn[a]=bb.fn[a+"s"]=function(a){var c=this._isUTC?"UTC":"";return null!=a?(this._d["set"+c+b](a),bb.updateOffset(this),this):this._d["get"+c+b]()}}function $(a){bb.duration.fn[a]=function(){return this._data[a]}}function _(a,b){bb.duration.fn["as"+a]=function(){return+this/b}}function ab(){"undefined"==typeof ender&&(this.moment=bb)}for(var bb,cb,db="2.3.1",eb=Math.round,fb=0,gb=1,hb=2,ib=3,jb=4,kb=5,lb=6,mb={},nb="undefined"!=typeof module&&module.exports,ob=/^\/?Date\((\-?\d+)/i,pb=/(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,qb=/^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,rb=/(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|SS?S?|X|zz?|ZZ?|.)/g,sb=/(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,tb=/\d\d?/,ub=/\d{1,3}/,vb=/\d{3}/,wb=/\d{1,4}/,xb=/[+\-]?\d{1,6}/,yb=/[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i,zb=/Z|[\+\-]\d\d:?\d\d/i,Ab=/T/i,Bb=/[\+\-]?\d+(\.\d{1,3})?/,Cb=/^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d\d?\d?)?)?)?)?([\+\-]\d\d:?\d\d)?)?$/,Db="YYYY-MM-DDTHH:mm:ssZ",Eb=["YYYY-MM-DD","GGGG-[W]WW","GGGG-[W]WW-E","YYYY-DDD"],Fb=[["HH:mm:ss.S",/(T| )\d\d:\d\d:\d\d\.\d{1,3}/],["HH:mm:ss",/(T| )\d\d:\d\d:\d\d/],["HH:mm",/(T| )\d\d:\d\d/],["HH",/(T| )\d\d/]],Gb=/([\+\-]|\d\d)/gi,Hb="Date|Hours|Minutes|Seconds|Milliseconds".split("|"),Ib={Milliseconds:1,Seconds:1e3,Minutes:6e4,Hours:36e5,Days:864e5,Months:2592e6,Years:31536e6},Jb={ms:"millisecond",s:"second",m:"minute",h:"hour",d:"day",D:"date",w:"week",W:"isoWeek",M:"month",y:"year",DDD:"dayOfYear",e:"weekday",E:"isoWeekday",gg:"weekYear",GG:"isoWeekYear"},Kb={dayofyear:"dayOfYear",isoweekday:"isoWeekday",isoweek:"isoWeek",weekyear:"weekYear",isoweekyear:"isoWeekYear"},Lb={},Mb="DDD w W M D d".split(" "),Nb="M D H h m s w W".split(" "),Ob={M:function(){return this.month()+1},MMM:function(a){return this.lang().monthsShort(this,a)},MMMM:function(a){return this.lang().months(this,a)},D:function(){return this.date()},DDD:function(){return this.dayOfYear()},d:function(){return this.day()},dd:function(a){return this.lang().weekdaysMin(this,a)},ddd:function(a){return this.lang().weekdaysShort(this,a)},dddd:function(a){return this.lang().weekdays(this,a)},w:function(){return this.week()},W:function(){return this.isoWeek()},YY:function(){return i(this.year()%100,2)},YYYY:function(){return i(this.year(),4)},YYYYY:function(){return i(this.year(),5)},gg:function(){return i(this.weekYear()%100,2)},gggg:function(){return this.weekYear()},ggggg:function(){return i(this.weekYear(),5)},GG:function(){return i(this.isoWeekYear()%100,2)},GGGG:function(){return this.isoWeekYear()},GGGGG:function(){return i(this.isoWeekYear(),5)},e:function(){return this.weekday()},E:function(){return this.isoWeekday()},a:function(){return this.lang().meridiem(this.hours(),this.minutes(),!0)},A:function(){return this.lang().meridiem(this.hours(),this.minutes(),!1)},H:function(){return this.hours()},h:function(){return this.hours()%12||12},m:function(){return this.minutes()},s:function(){return this.seconds()},S:function(){return q(this.milliseconds()/100)},SS:function(){return i(q(this.milliseconds()/10),2)},SSS:function(){return i(this.milliseconds(),3)},Z:function(){var a=-this.zone(),b="+";return 0>a&&(a=-a,b="-"),b+i(q(a/60),2)+":"+i(q(a)%60,2)},ZZ:function(){var a=-this.zone(),b="+";return 0>a&&(a=-a,b="-"),b+i(q(10*a/6),4)},z:function(){return this.zoneAbbr()},zz:function(){return this.zoneName()},X:function(){return this.unix()}},Pb=["months","monthsShort","weekdays","weekdaysShort","weekdaysMin"];Mb.length;)cb=Mb.pop(),Ob[cb+"o"]=c(Ob[cb],cb);for(;Nb.length;)cb=Nb.pop(),Ob[cb+cb]=b(Ob[cb],2);for(Ob.DDDD=b(Ob.DDD,3),g(d.prototype,{set:function(a){var b,c;for(c in a)b=a[c],"function"==typeof b?this[c]=b:this["_"+c]=b},_months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),months:function(a){return this._months[a.month()]},_monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),monthsShort:function(a){return this._monthsShort[a.month()]},monthsParse:function(a){var b,c,d;for(this._monthsParse||(this._monthsParse=[]),b=0;12>b;b++)if(this._monthsParse[b]||(c=bb.utc([2e3,b]),d="^"+this.months(c,"")+"|^"+this.monthsShort(c,""),this._monthsParse[b]=new RegExp(d.replace(".",""),"i")),this._monthsParse[b].test(a))return b},_weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdays:function(a){return this._weekdays[a.day()]},_weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysShort:function(a){return this._weekdaysShort[a.day()]},_weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),weekdaysMin:function(a){return this._weekdaysMin[a.day()]},weekdaysParse:function(a){var b,c,d;for(this._weekdaysParse||(this._weekdaysParse=[]),b=0;7>b;b++)if(this._weekdaysParse[b]||(c=bb([2e3,1]).day(b),d="^"+this.weekdays(c,"")+"|^"+this.weekdaysShort(c,"")+"|^"+this.weekdaysMin(c,""),this._weekdaysParse[b]=new RegExp(d.replace(".",""),"i")),this._weekdaysParse[b].test(a))return b},_longDateFormat:{LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D YYYY",LLL:"MMMM D YYYY LT",LLLL:"dddd, MMMM D YYYY LT"},longDateFormat:function(a){var b=this._longDateFormat[a];return!b&&this._longDateFormat[a.toUpperCase()]&&(b=this._longDateFormat[a.toUpperCase()].replace(/MMMM|MM|DD|dddd/g,function(a){return a.slice(1)}),this._longDateFormat[a]=b),b},isPM:function(a){return"p"===(a+"").toLowerCase().charAt(0)},_meridiemParse:/[ap]\.?m?\.?/i,meridiem:function(a,b,c){return a>11?c?"pm":"PM":c?"am":"AM"},_calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},calendar:function(a,b){var c=this._calendar[a];return"function"==typeof c?c.apply(b):c},_relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},relativeTime:function(a,b,c,d){var e=this._relativeTime[c];return"function"==typeof e?e(a,b,c,d):e.replace(/%d/i,a)},pastFuture:function(a,b){var c=this._relativeTime[a>0?"future":"past"];return"function"==typeof c?c(b):c.replace(/%s/i,b)},ordinal:function(a){return this._ordinal.replace("%d",a)},_ordinal:"%d",preparse:function(a){return a},postformat:function(a){return a},week:function(a){return W(a,this._week.dow,this._week.doy).week},_week:{dow:0,doy:6},_invalidDate:"Invalid date",invalidDate:function(){return this._invalidDate}}),bb=function(b,c,d,e){return"boolean"==typeof d&&(e=d,d=a),Y({_i:b,_f:c,_l:d,_strict:e,_isUTC:!1})},bb.utc=function(b,c,d,e){var f;return"boolean"==typeof d&&(e=d,d=a),f=Y({_useUTC:!0,_isUTC:!0,_l:d,_i:b,_f:c,_strict:e}).utc()},bb.unix=function(a){return bb(1e3*a)},bb.duration=function(a,b){var c,d,e,g=bb.isDuration(a),h="number"==typeof a,i=g?a._input:h?{}:a,j=null;return h?b?i[b]=a:i.milliseconds=a:(j=pb.exec(a))?(c="-"===j[1]?-1:1,i={y:0,d:q(j[hb])*c,h:q(j[ib])*c,m:q(j[jb])*c,s:q(j[kb])*c,ms:q(j[lb])*c}):(j=qb.exec(a))&&(c="-"===j[1]?-1:1,e=function(a){var b=a&&parseFloat(a.replace(",","."));return(isNaN(b)?0:b)*c},i={y:e(j[2]),M:e(j[3]),d:e(j[4]),h:e(j[5]),m:e(j[6]),s:e(j[7]),w:e(j[8])}),d=new f(i),g&&a.hasOwnProperty("_lang")&&(d._lang=a._lang),d},bb.version=db,bb.defaultFormat=Db,bb.updateOffset=function(){},bb.lang=function(a,b){var c;return a?(b?y(x(a),b):null===b?(z(a),a="en"):mb[a]||A(a),c=bb.duration.fn._lang=bb.fn._lang=A(a),c._abbr):bb.fn._lang._abbr},bb.langData=function(a){return a&&a._lang&&a._lang._abbr&&(a=a._lang._abbr),A(a)},bb.isMoment=function(a){return a instanceof e},bb.isDuration=function(a){return a instanceof f},cb=Pb.length-1;cb>=0;--cb)p(Pb[cb]);for(bb.normalizeUnits=function(a){return n(a)},bb.invalid=function(a){var b=bb.utc(0/0);return null!=a?g(b._pf,a):b._pf.userInvalidated=!0,b},bb.parseZone=function(a){return bb(a).parseZone()},g(bb.fn=e.prototype,{clone:function(){return bb(this)},valueOf:function(){return+this._d+6e4*(this._offset||0)},unix:function(){return Math.floor(+this/1e3)},toString:function(){return this.clone().lang("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},toDate:function(){return this._offset?new Date(+this):this._d},toISOString:function(){return D(bb(this).utc(),"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]")},toArray:function(){var a=this;return[a.year(),a.month(),a.date(),a.hours(),a.minutes(),a.seconds(),a.milliseconds()]},isValid:function(){return w(this)},isDSTShifted:function(){return this._a?this.isValid()&&m(this._a,(this._isUTC?bb.utc(this._a):bb(this._a)).toArray())>0:!1},parsingFlags:function(){return g({},this._pf)},invalidAt:function(){return this._pf.overflow},utc:function(){return this.zone(0)},local:function(){return this.zone(0),this._isUTC=!1,this},format:function(a){var b=D(this,a||bb.defaultFormat);return this.lang().postformat(b)},add:function(a,b){var c;return c="string"==typeof a?bb.duration(+b,a):bb.duration(a,b),j(this,c,1),this},subtract:function(a,b){var c;return c="string"==typeof a?bb.duration(+b,a):bb.duration(a,b),j(this,c,-1),this},diff:function(a,b,c){var d,e,f=this._isUTC?bb(a).zone(this._offset||0):bb(a).local(),g=6e4*(this.zone()-f.zone());return b=n(b),"year"===b||"month"===b?(d=432e5*(this.daysInMonth()+f.daysInMonth()),e=12*(this.year()-f.year())+(this.month()-f.month()),e+=(this-bb(this).startOf("month")-(f-bb(f).startOf("month")))/d,e-=6e4*(this.zone()-bb(this).startOf("month").zone()-(f.zone()-bb(f).startOf("month").zone()))/d,"year"===b&&(e/=12)):(d=this-f,e="second"===b?d/1e3:"minute"===b?d/6e4:"hour"===b?d/36e5:"day"===b?(d-g)/864e5:"week"===b?(d-g)/6048e5:d),c?e:h(e)},from:function(a,b){return bb.duration(this.diff(a)).lang(this.lang()._abbr).humanize(!b)},fromNow:function(a){return this.from(bb(),a)},calendar:function(){var a=this.diff(bb().zone(this.zone()).startOf("day"),"days",!0),b=-6>a?"sameElse":-1>a?"lastWeek":0>a?"lastDay":1>a?"sameDay":2>a?"nextDay":7>a?"nextWeek":"sameElse";return this.format(this.lang().calendar(b,this))},isLeapYear:function(){return t(this.year())},isDST:function(){return this.zone()<this.clone().month(0).zone()||this.zone()<this.clone().month(5).zone()},day:function(a){var b=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=a?(a=T(a,this.lang()),this.add({d:a-b})):b},month:function(a){var b,c=this._isUTC?"UTC":"";return null!=a?"string"==typeof a&&(a=this.lang().monthsParse(a),"number"!=typeof a)?this:(b=this.date(),this.date(1),this._d["set"+c+"Month"](a),this.date(Math.min(b,this.daysInMonth())),bb.updateOffset(this),this):this._d["get"+c+"Month"]()},startOf:function(a){switch(a=n(a)){case"year":this.month(0);case"month":this.date(1);case"week":case"isoWeek":case"day":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0)}return"week"===a?this.weekday(0):"isoWeek"===a&&this.isoWeekday(1),this},endOf:function(a){return a=n(a),this.startOf(a).add("isoWeek"===a?"week":a,1).subtract("ms",1)},isAfter:function(a,b){return b="undefined"!=typeof b?b:"millisecond",+this.clone().startOf(b)>+bb(a).startOf(b)},isBefore:function(a,b){return b="undefined"!=typeof b?b:"millisecond",+this.clone().startOf(b)<+bb(a).startOf(b)},isSame:function(a,b){return b="undefined"!=typeof b?b:"millisecond",+this.clone().startOf(b)===+bb(a).startOf(b)},min:function(a){return a=bb.apply(null,arguments),this>a?this:a},max:function(a){return a=bb.apply(null,arguments),a>this?this:a},zone:function(a){var b=this._offset||0;return null==a?this._isUTC?b:this._d.getTimezoneOffset():("string"==typeof a&&(a=G(a)),Math.abs(a)<16&&(a=60*a),this._offset=a,this._isUTC=!0,b!==a&&j(this,bb.duration(b-a,"m"),1,!0),this)},zoneAbbr:function(){return this._isUTC?"UTC":""},zoneName:function(){return this._isUTC?"Coordinated Universal Time":""},parseZone:function(){return"string"==typeof this._i&&this.zone(this._i),this},hasAlignedHourOffset:function(a){return a=a?bb(a).zone():0,0===(this.zone()-a)%60},daysInMonth:function(){return r(this.year(),this.month())},dayOfYear:function(a){var b=eb((bb(this).startOf("day")-bb(this).startOf("year"))/864e5)+1;return null==a?b:this.add("d",a-b)},weekYear:function(a){var b=W(this,this.lang()._week.dow,this.lang()._week.doy).year;return null==a?b:this.add("y",a-b)},isoWeekYear:function(a){var b=W(this,1,4).year;return null==a?b:this.add("y",a-b)},week:function(a){var b=this.lang().week(this);return null==a?b:this.add("d",7*(a-b))},isoWeek:function(a){var b=W(this,1,4).week;return null==a?b:this.add("d",7*(a-b))},weekday:function(a){var b=(this.day()+7-this.lang()._week.dow)%7;return null==a?b:this.add("d",a-b)},isoWeekday:function(a){return null==a?this.day()||7:this.day(this.day()%7?a:a-7)},get:function(a){return a=n(a),this[a]()},set:function(a,b){return a=n(a),"function"==typeof this[a]&&this[a](b),this},lang:function(b){return b===a?this._lang:(this._lang=A(b),this)}}),cb=0;cb<Hb.length;cb++)Z(Hb[cb].toLowerCase().replace(/s$/,""),Hb[cb]);Z("year","FullYear"),bb.fn.days=bb.fn.day,bb.fn.months=bb.fn.month,bb.fn.weeks=bb.fn.week,bb.fn.isoWeeks=bb.fn.isoWeek,bb.fn.toJSON=bb.fn.toISOString,g(bb.duration.fn=f.prototype,{_bubble:function(){var a,b,c,d,e=this._milliseconds,f=this._days,g=this._months,i=this._data;i.milliseconds=e%1e3,a=h(e/1e3),i.seconds=a%60,b=h(a/60),i.minutes=b%60,c=h(b/60),i.hours=c%24,f+=h(c/24),i.days=f%30,g+=h(f/30),i.months=g%12,d=h(g/12),i.years=d},weeks:function(){return h(this.days()/7)},valueOf:function(){return this._milliseconds+864e5*this._days+2592e6*(this._months%12)+31536e6*q(this._months/12)},humanize:function(a){var b=+this,c=V(b,!a,this.lang());return a&&(c=this.lang().pastFuture(b,c)),this.lang().postformat(c)},add:function(a,b){var c=bb.duration(a,b);return this._milliseconds+=c._milliseconds,this._days+=c._days,this._months+=c._months,this._bubble(),this},subtract:function(a,b){var c=bb.duration(a,b);return this._milliseconds-=c._milliseconds,this._days-=c._days,this._months-=c._months,this._bubble(),this},get:function(a){return a=n(a),this[a.toLowerCase()+"s"]()},as:function(a){return a=n(a),this["as"+a.charAt(0).toUpperCase()+a.slice(1)+"s"]()},lang:bb.fn.lang,toIsoString:function(){var a=Math.abs(this.years()),b=Math.abs(this.months()),c=Math.abs(this.days()),d=Math.abs(this.hours()),e=Math.abs(this.minutes()),f=Math.abs(this.seconds()+this.milliseconds()/1e3);return this.asSeconds()?(this.asSeconds()<0?"-":"")+"P"+(a?a+"Y":"")+(b?b+"M":"")+(c?c+"D":"")+(d||e||f?"T":"")+(d?d+"H":"")+(e?e+"M":"")+(f?f+"S":""):"P0D"}});for(cb in Ib)Ib.hasOwnProperty(cb)&&(_(cb,Ib[cb]),$(cb.toLowerCase()));_("Weeks",6048e5),bb.duration.fn.asMonths=function(){return(+this-31536e6*this.years())/2592e6+12*this.years()},bb.lang("en",{ordinal:function(a){var b=a%10,c=1===q(a%100/10)?"th":1===b?"st":2===b?"nd":3===b?"rd":"th";return a+c}}),nb?(module.exports=bb,ab()):"function"==typeof define&&define.amd?define("moment",function(a,b,c){return c.config().noGlobal!==!0&&ab(),bb}):ab()}).call(this);
//     Underscore.js 1.5.2
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  //use the faster Date.now if available.
  var getTime = (Date.now || function() {
    return new Date().getTime();
  });

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.5.2';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? void 0 : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed > result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return value;
    return _.property(value);
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, iterator, context) {
    iterator = lookupIterator(iterator);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iterator, context) {
      var result = {};
      iterator = lookupIterator(iterator);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[0];
    if (n < 0) return [];
    return slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, "length").concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error("bindAll must be passed function names");
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : getTime();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function() {
      var now = getTime();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    return function() {
      context = this;
      args = arguments;
      timestamp = getTime();
      var later = function() {
        var last = getTime() - timestamp;
        if (last < wait) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            context = args = null;
          }
        }
      };
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))
                        && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  _.constant = function(value) {
    return function () {
      return value;
    };
  };

  _.property = function(key) {
    return function(obj) {
      return obj[key];
    };
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}).call(this);

(function(){if(!window.WL){var Zg="download",h="interface_method",Ie="WL.Internal.jsonp.",Ed=2000,ge="body",r="callback",Ub="code",cb="element",ce="error",wh="error_description",Od="logging",Ch="tracing",Nb="message",R="method",fg="file_input",th="stream_input",Mb="file_name",xh="file_output",J="overwrite",y="path",Dg="pretty",Eg="result",Eh="status",Pf="return_ssl_resources",Ah="success",Fh="error",rd="suppress_redirects",ad="suppress_response_codes",M="x_http_live_library",de=0,sd=1,d="access_token",bh="appstate",Zb="authentication_token",q="client_id",ec="display",kh="code",k="error",D="error_description",gb="expires",fb="expires_in",fh="locale",w="redirect_uri",lb="response_type",s="request_ts",g="scope",xe="session",Qb="secure_cookie",V="state",e="status",Tb=[d,Zb,g,fb,gb],E="connected",Ig="notConnected",T="unchecked",xb="unknown",dc="expiring",Kh="expired",Ih="live-sdk-upload",Dh="live-sdk-download",jh="appId",Wg="channelUrl",ve="wl_auth",ke="wl_upload",oe="page",Jc="touch",bc="none",Xd="none",Rb="auth.login",Bc="auth.logout",X="auth.sessionChange",nc="auth.statusChange",Ae="wl.log",Jb="access_denied",zf="connection_failed",ng="invalid_cookie",uh="invalid_request",mb="request_canceled",P="request_failed",Vb="timed_out",Bh="unknown_user",zh="user_canceled",of="METHOD: Failed to get the required user permission to perform this operation.",pf="The request could not be completed due to browser issues.",ld="The request could not be completed due to browser limitations.",Ob="METHOD: The operation has been canceled.",hd="The 'wl_auth' cookie is not valid.",cd="The 'wl_auth' cookie has been modified incorrectly. Ensure that the redirect URI only modifies sub-keys for values received from the OAuth endpoint.",Me="The 'wl_auth' cookie has multiple values. Ensure that the redirect URI specifies a cookie domain and path when setting cookies.",Hf="METHOD: The input property 'PARAM' does not reference a valid DOM element.",Wf="METHOD: An exception was received for EVENT. Detail: MESSAGE",If="METHOD: The WL object must be initialized with WL.init() prior to invoking this method.",od="A connection to the server could not be established.",rh="The user could not be identified.",Af="The pending login request has been canceled.",Qe="Logging out the user is not supported in current session because the user is logged in with a Microsoft account on this computer. To logout, the user may quit the app or log out from the computer.",qf="METHOD: The input value for parameter/property 'PARAM' is not valid.",rf="METHOD: The input parameter/property 'PARAM' must be included.",Te="METHOD: The type of the provided value for the input parameter/property 'PARAM' is not valid.",hc="METHOD: There is a pending METHOD request, the current call will be ignored.",Ke=hc.replace(/METHOD/g,"WL.login"),Fe=hc.replace(/METHOD/g,"WL.fileDialog"),ph=hc.replace(/METHOD/g,"WL.upload"),Re="METHOD: The input property 'redirect_uri' is required if the value of the 'response_type' property is 'code'.",oh="WL.init: The redirect_uri value should be the same as the value of 'Redirect Domain' of your registered app. It must begin with 'http://' or 'https://'.",qh="METHOD: The api call is not supported on this platform.",nh="WL.init: The response_type value 'code' is not supported on this platform.",og="METHOD: The input property 'redirect_uri' must use https: to match the scheme of the current page.",sf="The auth request is timed out.",Jf="The popup is closed without receiving consent.",Cc=0,jf=1,md=2,pg=3,Sb="GET",Zd="POST",Ng="PUT",rg="DELETE",Gh="COPY",Hh="MOVE",Df=30000,mh="METHOD",n="onSuccess",o="onError",H="onProgress",ac="redirect_type",Md="auth",Ad="upload",sg="code",ib="token",cc="https:",Oc="http:",qe="wl.signin",Tg="wl.skydrive",Tf="wl.skydrive_update",Ag=/\s|,/,rb="boolean",Sc="dom",j="function",we="number",b="string",wb="object",Ac="string_or_array",Wb="undefined",Yg="name",db="element",Xb="brand",Mc="type",Fb="sign_in_text",Db="sign_out_text",C="theme",Hd="onloggedin",Cd="onloggedout",nb="onerror",tg="messenger",Hg="hotmail",Bg="skydrive",Dc="windows",Bd="windowslive",Lc="none",Qc="signin",qc=Qc,Dd="login",wd="connect",zd="custom",Hb="blue",Gb="white",yh="dark",vh="light",fe="id",eb="auth_server",Q="apiservice_uri",S="skydrive_uri",F="sdk_root",fc="wl_trace";window.WL={getSession:function(){try{return a.getSession()}catch(b){t(b.message)}},getLoginStatus:function(){try{return a.getLoginStatus({callback:Kd(arguments,j,2),internal:false},Kd(arguments,rb,2))}catch(d){return I("WL.getLoginStatus",d)}},logout:function(b){try{Yb(b,L,"WL.logout");return a.logout({callback:b})}catch(c){return I("WL.logout",c)}},canLogout:function(){return a.canLogout()},api:function(){try{var c=Rf(arguments);m(c,[{name:y,type:b,optional:false},{name:R,type:b,optional:true},L],"WL.api");return a.api(c)}catch(f){return I("WL.api",f)}}};var je=[Rb,Bc,X,nc,Ae];WL.Event={subscribe:function(d,a){try{Yb([d,a],[{name:"event",type:b,allowedValues:je,caseSensitive:true,optional:false},ff],"WL.Event.subscribe");c.subscribe(d,a)}catch(e){t(e.message)}},unsubscribe:function(d,a){try{Yb([d,a],[{name:"event",type:b,allowedValues:je,caseSensitive:true,optional:false},L],"WL.Event.unsubscribe");c.unsubscribe(d,a)}catch(e){t(e.message)}}};WL.Internal={};var c={subscribe:function(a,b){i("Subscribe "+a);var d=c.getHandlers(a);d.push(b)},unsubscribe:function(d,f){i("Unsubscribe "+d);var b=c.getHandlers(d),e=[];if(f!=null){var g=false;for(var a=0;a<b.length;a++)if(g||b[a]!=f)e.push(b[a]);else g=true}c._eHandlers[d]=e},getHandlers:function(b){if(!c._eHandlers)c._eHandlers={};var a=c._eHandlers[b];if(a==null)c._eHandlers[b]=a=[];return a},notify:function(d,e){i("Notify "+d);var b=c.getHandlers(d);for(var a=0;a<b.length;a++)b[a](e)}},a={_status:de,_statusRequests:[],_rpsAuth:false};a.appInit=function(c){if(a._status==sd){var e=a._session.getNormalStatus();return ab("WL.init",true,c.callback,e)}var b=WL[F];if(b){if(b.charAt(b.length-1)!=="/")b+="/";a[F]=b}var d=c[Od];if(d===false)a._logEnabled=d;if(a.testInit)a.testInit(c);a._status=sd;return wf(c)};a.onloadInit=function(){Qg();Sg()};function x(b){if(a._status===de)throw new Error(If.replace("METHOD",b))}function Pc(){return WL.Internal.tApp||a}a.api=function(a){x("WL.api");var c=a[ge];if(c){a=K(Hc(c),a);delete a[ge]}var b=a[R];a[R]=(b!=null?U(b):Sb).toUpperCase();return (new ye(a)).execute()};var Yf=function(){var b=a.api.lastId,c;b=b===undefined?1:b+1;c="WLAPI_REQ_"+b+"_"+(new Date).getTime();a.api.lastId=b;return c},ye=function(b){var c=this;c._properties=b;c._completed=false;c._id=Yf();b[Dg]=false;b[Pf]=a._isHttps;b[M]=a[M];var d=b[y];c._url=Yd()+(d.charAt(0)==="/"?d.substring(1):d);c._promise=new l("WL.api",null,null)};ye.prototype={execute:function(){xg(this);return this._promise},onCompleted:function(a){if(this._completed)return;this._completed=true;B(this._properties.callback,a,true);if(a[k])this._promise[o](a);else this._promise[n](a)}};function zc(e,c,a,d){a=a?U(a):"";var b=a!==""?Ec(a):null;if(b===null){b={};if(c/100!==2)b[ce]=ug(c,d)}e.onCompleted(b)}function ug(c,b){var a={};a[Ub]=P;a[Nb]=b||od;return a}function rc(){var c=null;if(!a._rpsAuth){var b=Pc()._session.getStatus();if(b.status===dc||b.status===E)c=b.session[d]}return c}function Hc(i){var c={};for(var b in i){var a=i[b],j=typeof a;if(a instanceof Array)for(var d=0;d<a.length;d++){var f=a[d],l=typeof f;if(j==wb&&!(a instanceof Date)){var h=Hc(f);for(var e in h)c[b+"."+d+"."+e]=h[e]}else c[b+"."+d]=f}else if(j==wb&&!(a instanceof Date)){var k=Hc(a);for(var g in k)c[b+"."+g]=k[g]}else c[b]=a}return c}function cg(c){if(!ih())return false;var b=Ud(c),a=new XMLHttpRequest;a.open(b.method,b.url,true);var d=c._properties[R];if(b.method!=Sb)a.setRequestHeader("Content-Type","application/x-www-form-urlencoded");a.onreadystatechange=function(){if(a.readyState==4)zc(c,a.status,a.responseText)};a.send(b.body);return true}function Ud(e){var a=Qd(e._properties,null,[r,y,R]),f=e._properties[R],g=hb(e._url,{"ts":(new Date).getTime()}),h=rc(),c,b;a[rd]="true";a[ad]="true";if(h!=null)a[d]=h;if(f===Sb||f===rg){c=null;b=Sb;g+="&"+v(a)}else{c=v(a);b=Zd}g+="&method="+f;return {url:g,method:b,body:c}}a.download=function(a){df(a);x("WL.download");return (new Rd(a)).execute()};function td(b,f){var c=f||{},g=Yd();if(!le(b))b=g+(b.charAt(0)==="/"?b.substring(1):b);var e=rc();if(e)c[d]=e;c[M]=a[M];return hb(b,c)}var bd="notStarted",ud="ready",gc="downloadCompleted",Wc="downloadFailed",gd="canceled",bf="completed";function Rd(a){this._properties=a;this._status=bd}Rd.prototype={execute:function(){this._promise=new l("WL.download",this,null);this._process();return this._promise},cancel:function(){this._status=gd;if(this._cancel)try{this._cancel()}catch(a){}else{this._result=p(mb,Ob.replace("METHOD","WL.download"));this._process()}},downloadComplete:function(b,c){var a=this;a._result=c;a._status=b?gc:Wc;a._process()},downloadProgress:function(a){this._promise[H](a)},_process:function(){switch(this._status){case bd:this._start();break;case ud:this._download();break;case gc:case Wc:case gd:this._complete()}},_start:function(){var b=this;a.getLoginStatus({internal:true,callback:function(){b._status=ud;b._process()}})},_download:function(){var a=this;Lg(a)},_complete:function(){var a=this,c=a._result,d=a._status===gc?n:o;a._status=bf;var b=a._properties[r];if(b)b(c);a._promise[d](c)}};a.login=function(b,d){x("WL.login");gg(b);if(!qg(d))return ab("WL.login",false,null,p(P,Ke));var c=a._session.tryGetResponse(b.normalizedScope);if(c!=null)return ab("WL.login",true,b.callback,c);a._pendingLogin=mg(b,Kf);return a._pendingLogin.execute()};function Kf(c,b){a._pendingLogin=null;var d=b[k];if(d)zb("WL.login: "+b[D]);else B(c.callback,b,true)}function Fd(b){var a=b||"";if(a instanceof Array)a=a.join(" ");return U(a)}a.getSession=function(){x("WL.getSession");return a._session.getStatus()[xe]};a.getLoginStatus=function(b,f){x("WL.getLoginStatus");b=b||{};if(!f){var d=a._session.tryGetResponse();if(d)return ab("WL.getLoginStatus",true,b.callback,d)}i("wl_app:getLoginStatus");var e=a._statusRequests,c=null;if(!a._pendingStatusRequest){c=nf(b,lf);a._pendingStatusRequest=c}e.push(b);if(c!=null)c.execute();return a._pendingStatusRequest._promise};function lf(h,b){var f=a._statusRequests;a._pendingStatusRequest=null;i("wl_app:onGetLoginStatusCompleted");var d=b[k],e=false;while(f.length>0){var c=f.shift(),g=K(b);if(!d||c.internal)B(c.callback,g,true);if(!c.internal)e=true}if(d)if(e&&d!==Vb)zb("WL.getLoginStatus: "+b[D]);else i("wl_app-onGetLoginStatusCompleted: "+b[D])}a.logout=function(f){var b="WL.logout";x(b);var d=new l(b,null,null),c=function(c){ub(function(){var e,g=n;if(c){t(c.message);g=o;e=Cb(b,b,c)}else e=a._session.getNormalStatus();B(f.callback,e,false);d[g](e)})},e=function(){var b=a._session;if(b.isSignedIn())if(a.canLogout()){b.updateStatus(xb);yg(c)}else c(new Error(Qe));else c()};if(a._pendingStatusRequest!=null)a.getLoginStatus({internal:true,callback:e},false);else e();return d};a.upload=function(a){var c=a[h];x(c);m(a,[{name:y,type:b,optional:false},L],c);Ne(a);Ef(a);return (new Fc(a)).execute()};function Ef(a){var b=a[fg],c=a[Mb];if(b)a[Mb]=c||b.name}function Ve(a,h,i){var c=a.indexOf("?"),e=c!==-1,g="";if(e){g=a.substring(c+1);a=a.substring(0,c)}var f=typeof h!==Wb,j=a.charAt(a.length-1)==="/";if(f&&!j)a+="/";var b=a,d={};if(f)b+=encodeURIComponent(h);if(i==="rename")d[J]="choosenewname";else d[J]=i;if(e)b=Pd(b,g);return lc(b,d)}function eh(a){return /^(file|\/file)/.test(a.toLowerCase())}function lc(b,a){a=a||{};a[ad]="true";return td(b,a)}function Ne(a){if(J in a){var c=a[h],d=a[J],f=typeof d,i=f===rb,e=f===b;if(!(i||e))throw O(J,c);if(e){var g=/^(true|false|rename)$/i.test(d);if(!g)throw Y(J,c)}}else a[J]=false}var jd=0,nd=1,kc=2,jc=3,Ab=4,pd=5,vf=6;function Fc(a){this._props=a;this._status=jd}Fc.prototype={execute:function(){var a=this;a._strategy=a._getStrategy(a._props);a._promise=new l(a._props[h],a,null);a._process();return a._promise},cancel:function(){var a=this;a._status=pd;if(a._cancel)try{a._cancel()}catch(c){}else{var b=Ob.replace(mh,a._props[h]);a._result=p(mb,b);a._process()}},uploadProgress:function(a){this._promise[H](a)},uploadComplete:function(b,c){var a=this;a._result=c;a._status=b?jc:Ab;a._process()},onErr:function(c){var a=this._props[h]+":"+c,b=p(P,a);this.uploadComplete(false,b)},onResp:function(a){a=a?U(a):"";var b=a!==""?Ec(a):null;b=b||{};this.uploadComplete(b.error==null,b)},setFileName:function(a){this._props[Mb]=a},_process:function(){switch(this._status){case jd:this._start();break;case nd:this._getUploadPath();break;case kc:this._upload();break;case jc:case Ab:case pd:this._complete()}},_start:function(){var a=this;Pc().getLoginStatus({internal:true,callback:function(){a._status=nd;a._process()}})},_getUploadPath:function(){var a=this,c=a._props,b=c[y];if(le(b)){a._uploadPath=lc(b);a._status=kc;a._process();return}Pc().api({path:b}).then(function(h){var d=h.upload_location;if(d){var e=Gg(b);d=Pd(d,e);var f=c[Mb],g=c[J];if(eh(b))a._uploadPath=lc(d);else a._uploadPath=Ve(d,f,g);a._status=kc}else{a._result=p(P,"WL.upload: Failed to get upload_location of the resource.");a._status=Ab}a._process()},function(b){a._result=b;a._status=Ab;a._process()})},_upload:function(){this._strategy.upload(this._uploadPath)},_complete:function(){var a=this,c=a._result,d=a._status===jc?n:o;a._status=vf;var b=a._props[r];if(b)b(c);a._promise[d](c)}};function U(a){return a.replace(/^\s+|\s+$/g,"")}function id(a,b){if(a&&b)return a.toLowerCase()===b.toLowerCase();return a===b}function Gd(a){return a==null||a===""}function K(b,d){var c=d||{};if(b!=null)for(var a in b)c[a]=b[a];return c}function Qd(e,d,b){var c=K(e,d);for(var a=0;a<b.length;a++)delete c[b[a]];return c}function Vg(b,c){var a;for(a=0;a<b.length;a++)if(b[a]===c)return true;return false}function ze(a){return Array.prototype.slice.call(a)}function f(b,a){return function(){if(typeof a===j)return a.apply(b,arguments)}}function Ce(a,e){a="[WL]"+a;var b=window.console;if(b&&b.log)switch(e){case "warning":b.warn(a);break;case "error":b.error(a);break;default:b.log(a)}var d=window.opera;if(d)d.postError(a);var c=window.debugService;if(c)c.trace(a)}function le(a){return a.indexOf("https://")===0||a.indexOf("http://")===0}function i(b){if(a._traceEnabled)Ce(b)}function zb(b,d){if(a._logEnabled||a._traceEnabled)Ce(b,d);c.notify(Ae,b)}if(window.WL&&WL.Internal){WL.Internal.trace=i;WL.Internal.log=zb}function t(a){zb(a,"error")}function Jd(b,c){var a=Ib("iframe");a.id=c;a.src=b;document.body.appendChild(a);return a}function Ib(b){var a=document.createElement(b);a.style.position="absolute";a.style.top="-1000px";a.style.width="300px";a.style.height="300px";a.style.visibility="hidden";return a}function pc(){var a=null;while(a==null){a="wl_"+Math.floor(Math.random()*1024*1024);if(pb(a)!=null)a=null}return a}function pb(a){return document.getElementById(a)}function Ug(a,b){if(a)if(a.innerText)a.innerText=b;else{var c=document.createTextNode(b);a.innerHTML="";a.appendChild(c)}}function Gg(b){var a=b.indexOf("?");if(a===-1)return "";var c=b.indexOf("#",a+1);if(c!==-1)return b.substring(a+1,c);return b.substring(a+1)}function Pd(a,b){if(typeof b===Wb||b===null||b==="")return a;var c=a.indexOf("?");if(c===-1)return a+"?"+b;if(a.charAt(a.length-1)!=="&")a+="&";return a+b}function De(a){K(Rc(a),this)}De.prototype={toString:function(){var a=this,b=(a.scheme!=""?a.scheme+"//":"")+a.host+(a.port!=""?":"+a.port:"")+a.path;return b},resolve:function(){var a=this;if(a.scheme==""){var b=window.location.port,c=window.location.host;a.scheme=window.location.protocol;a.host=c.split(":")[0];a.port=b!=null?b:"";if(a.path.charAt(0)!="/")a.path=ig(a.host,window.location.href,a.path)}}};function Rc(c){var e=c.indexOf(cc)==0?cc:c.indexOf(Oc)==0?Oc:"",h="",i="",f;if(e!="")var b=c.substring(e.length+2),a=b.indexOf("/"),g=a>0?b.substring(0,a):b,d=g.split(":"),h=d[0],i=d.length>1?d[1]:"",f=a>0?b.substring(a):"";else f=c;return {scheme:e,host:h,port:i,path:f}}function Xg(a){return Rc(a.toLowerCase()).host}function ig(e,b,h){var d=function(a,c){charIdx=b.indexOf(c);a=charIdx>0?a.substring(0,charIdx):a;return a};b=d(d(b,"?"),"#");var f=b.indexOf(e),a=b.substring(f+e.length),g=a.indexOf("/"),c=a.lastIndexOf("/");a=c>=0?a.substring(g,c):a;return a+"/"+h}function ah(a){var b=a.indexOf("?");if(b>0)a=a.substring(0,b);b=a.indexOf("#");if(b>0)a=a.substring(0,b);return a}function B(a,b,d,c){if(a!=null){if(c)b[V]=c;if(d)a(b);else ub(function(){a(b)})}}function Ec(a){if(window.JSON)return JSON.parse(a);else return eval("("+a+")")}function Td(){return Math.floor((new Date).getTime()/1000)}function lh(b,c){var d=b.length;for(var a=0;a<d;a++)c(b[a])}function Jg(c,b){var a={};a[k]=c;a[D]=b;return a}function p(d,c){var a={},b={};a[Ub]=d,a[Nb]=c;b[ce]=a;return b}function Cb(a,b,c){return p(P,Wf.replace("METHOD",a).replace("EVENT",b).replace("MESSAGE",c.message))}function Of(b){var a=b.split(".");return a[0]+"."+a[1]}function ub(a,b){if(window.wlUnitTests)wlUnitTests.delayInvoke(a);else window.setTimeout(a,b||1)}function Qg(){var b=Rg(navigator.userAgent,document.documentMode),c=a[M];a._browser=b;a[M]=c.replace("DEVICE",b.device)}function Rg(a,e){a=a.toLowerCase();var c="other",b={"firefox":/firefox/.test(a),"firefox1.5":/firefox\/1\.5/.test(a),"firefox2":/firefox\/2/.test(a),"firefox3":/firefox\/3/.test(a),"firefox4":/firefox\/4/.test(a),"ie":(/msie/.test(a)||/trident/.test(a))&&!/opera/.test(a),"ie6":false,"ie7":false,"ie8":false,"ie9":false,"ie10":false,"ie11":false,"opera":/opera/.test(a),"webkit":/webkit/.test(a),"chrome":/chrome/.test(a),"mobile":/mobile/.test(a)||/phone/.test(a)};if(b["ie"]){var d=0;if(e)d=e;else if(/msie 7/.test(a))d=7;d=Math.min(11,Math.max(d,6));c="ie"+d;b[c]=true}else if(b.firefox)c="firefox";else if(b.chrome)c="chrome";else if(b.webkit)c="webkit";else if(b.opera)c="opera";if(b.mobile)c+="mobile";b.device=c;return b}function Eb(e,c){var f=c!=null?c:{};if(e!=null){var d=e.split("&");for(var b=0;b<d.length;b++){var a=d[b].split("=");if(a.length==2)f[decodeURIComponent(a[0])]=decodeURIComponent(a[1])}}return f}function v(b){var a="";if(b!=null)for(var c in b){var d=a.length==0?"":"&",e=b[c];a+=d+encodeURIComponent(c)+"="+encodeURIComponent(jg(e))}return a}function jg(a){if(a instanceof Date){var b=function(a,b){switch(b){case 2:return a<10?"0"+a:a;case 3:return (a<10?"00":a<100?"0":"")+a}};return a.getUTCFullYear()+"-"+b(a.getUTCMonth()+1,2)+"-"+b(a.getUTCDate(),2)+"T"+b(a.getUTCHours(),2)+":"+b(a.getUTCMinutes(),2)+":"+b(a.getUTCSeconds(),2)+"."+b(a.getUTCMilliseconds(),3)+"Z"}return ""+a}function zg(b){var d=b.indexOf("?")+1,c=b.indexOf("#")+1,a={};if(d>0){var e=c>d?c-1:b.length;a=Eb(b.substring(d,e),a)}if(c>0)a=Eb(b.substring(c),a);return a}function hb(a,b){return a+(a.indexOf("?")<0?"?":"&")+v(b)}function Sf(a){switch(typeof a){case rb:return a;case we:return !!a;case b:return a.toLowerCase()==="true";default:return false}}var L={name:r,type:j,optional:true},ff={name:r,type:j,optional:false};function Yb(a,c,d){if(a instanceof Array)for(var b=0;b<a.length;b++)me(a[b],c[b],d);else me(a,c,d)}function me(c,a,b){Vd(c,a,b);if(a.type==="properties")m(c,a.properties,b)}function Vd(f,e,c){var d=e.name,a=typeof f,g=e.type;if(a==="undefined"||f==null)if(e.optional)return;else throw mc(d,c);switch(g){case "string":if(a!==b)throw O(d,c);if(!e.optional&&U(f)==="")throw mc(d,c);break;case "properties":if(a!=wb)throw O(d,c);break;case "function":if(a!=j)throw O(a,c);break;case "dom":if(a==b){if(pb(f)==null)throw new Error(Hf.replace("METHOD",c).replace("PARAM",d))}else if(a!=wb)throw O(d,c);break;case "string_or_array":if(a!==b&&!(f instanceof Array))throw O(a,c);break;default:if(a!==g)throw O(d,c)}if(e.allowedValues!=null)dg(f,e.allowedValues,e.caseSensitive,d,c)}function m(g,c,f){var d=g||{};for(var b=0;b<c.length;b++){var a=c[b],e=d[a.name]||d[a.altName];Vd(e,a,f)}}function dg(d,a,e,f,h){var g=typeof a[0]===b;for(var c=0;c<a.length;c++)if(g&&!e){if(d.toLowerCase()===a[c].toLowerCase())return}else if(d===a[c])return;throw Y(f,h)}function O(a,b){return new Error(Te.replace("METHOD",b).replace("PARAM",a))}function mc(a,b){return new Error(rf.replace("METHOD",b).replace("PARAM",a))}function Y(c,d,a){var b=qf.replace("METHOD",d).replace("PARAM",c);if(typeof a!==Wb)b+=" "+a;return new Error(b)}function Kd(b,d,c){if(b)for(var a=0;a<c&&a<b.length;a++)if(d===typeof b[a])return b[a];return undefined}function bb(i,g){var e=ze(i),a=null,b=null;for(var d=0;d<e.length;d++){var c=e[d],f=typeof c;if(f===wb&&a===null)a=K(c);else if(f===j&&b===null)b=c}a=a||{};if(b)a.callback=b;a[h]=g;return a}function Rf(e){var a=ze(e),d=null,c=null;if(typeof a[0]===b){d=a.shift();if(typeof a[0]===b)c=a.shift()}normalizedArgs=bb(a);if(d!==null){normalizedArgs[y]=d;if(c!=null)normalizedArgs[R]=c}return normalizedArgs}function I(a,b){var c=Cb(a,a,b);t(b.message);return ab(a,false,null,c)}var l=function(b,c,a){this._name=b;this._op=c;this._uplinkPromise=a;this._isCompleted=false;this._listeners=[]};l.prototype={then:function(d,e,c){var b=new l(null,null,this),a={};a[n]=d;a[o]=e;a[H]=c;a.chainedPromise=b;this._listeners.push(a);return b},cancel:function(){if(this._isCompleted)return;if(this._uplinkPromise&&!this._uplinkPromise._isCompleted)this._uplinkPromise.cancel();else{var a=this._op?this._op.cancel:null;if(typeof a===j)this._op.cancel();else this.onError(p(mb,Ob.replace("METHOD",this._getName())))}},_getName:function(){if(this._name)return this._name;if(this._op&&typeof this._op._getName===j)return this._op._getName();if(this._uplinkPromise)return this._uplinkPromise._getName();return ""},_onEvent:function(b,a){if(this._isCompleted)return;this._isCompleted=a!==H;this._notify(b,a)},_notify:function(b,a){var c=this;lh(this._listeners,function(g){var h=g[a],d=g.chainedPromise,f=a!==H;if(h)try{var e=h.apply(g,b);if(f&&e&&e.then){d._op=e;e.then(function(a){d[n](a)},function(a){d[o](a)},function(a){d[H](a)})}}catch(i){if(f)d.onError(Cb(c._getName(),a,i))}else if(f)d[a].apply(d,b)})}};l.prototype[n]=function(){this._onEvent(arguments,n)};l.prototype[o]=function(){this._onEvent(arguments,o)};l.prototype[H]=function(){this._onEvent(arguments,H)};function ab(e,d,b,f){var a=new l(e,null,null),c=d?n:o;if(typeof b===j)a.then(function(a){b(a)});ub(function(){a[c](f)});return a}var Tb=[d,Zb,g,fb,gb,s,k,D],be="refresh_type",eg="app",vc="ms",wc="response_method",qd="url",fd="cookie",Lb="onanalytics",Id="login",kd="loginstatus",xf="file_dialog",Kb="auth.response",N="mode",W="open",cf="save",Z="select",Zc="single",Ue="multi",Bb="lightbox",Se="grey",Tc="transparent",ic="white",Vc="loading_timeout",dd="onselected",Qf="auth",gf="rps",Ze="oauth",hf="v",Ge="1",He="2",Bf="domain",tf="livesdk",Xf="mkt",Yc="pickerscript",Ye="onPickerComplete",We="updateToken",yc="WL.fileDialog",dh=27,Pb="skydrivepicker",ef="Loading SkyDrive picker is timed out.";WL.init=function(d){try{var c=K(d);Yb(c,{name:"properties",type:"properties",optional:false,properties:[{name:q,altName:jh,type:b,optional:false},{name:g,type:Ac,optional:true},{name:w,altName:Wg,type:b,optional:true},{name:lb,type:b,allowedValues:[sg,ib],optional:true},{name:be,type:b,allowedValues:[eg,vc],optional:true},{name:Od,type:rb,optional:true},{name:e,type:rb,optional:true}]},"WL.init");if(!c[w]&&c[lb]===kh)throw new Error(Re.replace("METHOD","WL.init"));if(c[e]==null)c[e]=true;return a.appInit(c)}catch(f){return I("WL.init",f)}};WL.login=function(){try{var c=bb(arguments);m(c,[{name:g,type:Ac,optional:true},{name:w,type:b,optional:true},{name:V,type:b,optional:true},L],"WL.login");return a.login(c)}catch(f){return I("WL.login",f)}};WL.download=function(){try{var b="WL.download",c=bb(arguments,b);return a.download(c)}catch(f){return I(b,f)}};WL.upload=function(){try{var b="WL.upload",c=bb(arguments,b);return a.upload(c)}catch(f){return I(b,f)}};WL.ui=function(){try{var c=bb(arguments);m(c,[{name:Yg,type:b,allowedValues:[Qc,Pb],optional:false},L],"WL.ui");a.ui(c)}catch(f){vd(c,f)}};WL.fileDialog=function(){try{var b=yc,c=bb(arguments,b);xd(c,b);return a.fileDialog(c)}catch(f){return I(b,f)}};function xd(d,c){m(d,[{name:N,type:b,allowedValues:[W,cf],optional:false},{name:Z,type:b,allowedValues:[Zc,Ue],optional:true},{name:Bb,type:b,allowedValues:[Se,Tc,ic],optional:true},{name:Vc,type:we,optional:true},L],c);if(c!==yc)m(d,[{name:C,allowedValues:[Hb,Gb],type:b,optional:true},{name:dd,type:j,optional:false},{name:nb,type:j,optional:true}],c);if(!Gc.isSupported()||!window.JSON||a._browser.mobile)throw new Error(ld)}function bg(){a._urlParams=zg(window.location.href);a._pageState=Eb(a._urlParams[V])}function Nd(){var b=new tb(ve);b.load();var c=a._urlParams,f=a._pageState,i=true,m=f[s];if(m)if(m!=b.get(s))b.set(s,f[s]);else i=false;var j=c[d]!=null,n=b.get(d)!=null||j,o=n?E:xb,p=Td();if(f[wc]===qd){for(var h=0;h<Tb.length;h++){var g=Tb[h];if(c[g])b.set(g,c[g])}if(j){b.set(gb,p+parseInt(c[fb]));b.remove(k);b.remove(D)}else if(!n)if(c[k]===Jb)o=Ig}else if(i){var l=yf(b);if(l){b.set(k,ng);b.set(D,l)}}else return;b.set(e,o);b.save()}function Fg(){var b=a._pageState,e=b[ac];if(e===Ad){var h=b[fe],g=a._urlParams[Eg];Zf(h,g);return}var c=b[ec],f=b[Qb]==="true";a._logEnabled=true;a._traceEnabled=b[fc]||a._urlParams[fc];a._secureCookie=f;Gf();if(c===oe||c===Jc){Nd();if(c===Jc&&a._browser.ie)document.location=b[w];else window.close()}else if(c===bc)Nd();else{jb(Og);var d=window.wlAsyncInit;if(d&&typeof d===j)d.call()}}function ag(a,b){if(!a)a=ah(window.location.href);return Je(a,window.location.hostname,b)}function Je(f,e,d){var b=new De(f);b.resolve();var e=e.split(":")[0].toLowerCase(),c=b.host.toLowerCase();a._domain=a._domain||c;if(a._isHttps&&b.scheme==Oc)throw new Error(og.replace("METHOD",d));return b.toString()}function yf(a){var i=a.get(d)!=null,f=a.get(k)!=null,h=a.get(g)!=null,c=a.get(fb)!=null,e=a.get(q)!=null,b=null;if(!(i&&h&&c)&&!f){t(hd);b=hd}if(!e){t(cd);b=cd}return b}function Sg(){Ed=a._browser.ie?2000:4000;bg();Fg()}function Zf(c,b){var a=new tb(ke);a.load();a.set(c,b);a.save()}function wf(b){a._authScope=Fd(b[g]);a._secureCookie=Sf(b[Qb]);a._redirect_uri=ag(b[w],"WL.init");a._response_type=(b[lb]||ib).toLowerCase();a._appId=b[q];a._refreshType=(b[be]||vc).toLowerCase();var i=new se(b[q],ve);a._session=i;var d=i.getNormalStatus(),j=d[e],f,h="WL.init";if(j==E){c.notify(X,d);c.notify(nc,d);c.notify(Rb,d);f=ab(h,true,b.callback,d)}else if(b[e]){f=new l(h,null,null);a.getLoginStatus({internal:true,callback:function(a){var b=!!a.error?o:n;f[b](a)}},true)}return f}function qg(){var b=a._pendingLogin;if(b!=null){b.cancel();a._pendingLogin=null}return true}function gg(c){var b=Fd(c[g]);if(b==="")b=a._authScope;if(!b||b==="")throw mc(g,"WL.login");c.normalizedScope=b}function mg(b,a){return new Nc(Id,b,a)}function nf(b,a){return new Nc(kd,b,a)}a.ensurePermission=function(d,e,f,b){var c=p(Jb,of.replace("METHOD",f));a.login({scope:d}).then(function(f){if(f.session[fb]<e)a.getLoginStatus({internal:true},true).then(function(){a.login({scope:d}).then(function(a){b(a)},function(){b(c)})},function(){b(c)});else b(f)},function(){b(c)})};a.canLogout=function(){return true};function yg(d){Wd();var b=Ib("iframe"),c=Sd(),e="/oauth20_logout.srf?ts=";b.src="//"+c+e+(new Date).getTime();document.body.appendChild(b);a.logoutFrame=b;window.setTimeout(function(){Wd();d()},30000)}function Wd(){if(a.logoutFrame!=null){document.body.removeChild(a.logoutFrame);a.logoutFrame=null}}function vd(c,b){t(b.message);var a=c[nb];if(a)ub(function(){error=Cb("WL.ui","WL.ui",b),a(error)})}function he(){return a[F]}function pe(){return he()+"images"}var Kc=function(c){var a=this;a._properties=c;var b=f(a,a.init);jb(b)};Kc.prototype={init:function(){var d=this,e=d._properties;if(d._inited===true)return;d._inited=true;try{d.validate();var g=e[db],h=e[Mc],m=e[r],j=e[Fb],i=e[Db];af(e);g=typeof g===b?pb(e[db]):g;d._element=g;h=h!=null?h:qc;if(h==qc){j=u.signIn;i=u.signOut}else if(h==Dd){j=u.login;i=u.logout}else if(h==wd){j=u.connect;i=u.signOut}d[Fb]=j;d[Db]=i;re(g,Ff(e));var k=a._session.isSignedIn(),l=k?i:j;d.updateUI(l,k);Oe(d,g.childNodes[0]);c.subscribe(Rb,f(d,d.onLoggedIn));c.subscribe(Bc,f(d,d.onLoggedOut));a.getLoginStatus({internal:true});delete e[r];B(m,e,false)}catch(n){vd(e,n)}},validate:function(){var a=this._properties;m(a,[{name:db,type:Sc,optional:false},{name:Mc,allowedValues:[qc,Dd,wd,zd],type:b,optional:true},{name:g,type:Ac,optional:true},{name:V,type:b,optional:true},{name:Hd,type:j,optional:true},{name:Cd,type:j,optional:true},{name:nb,type:j,optional:true}],"WL.ui-signin");Ee(a);var c=a[Mc];if(c==zd)m(a,[{name:Fb,type:b,optional:false},{name:Db,type:b,optional:false}],"WL.ui-signin")},fireEvent:function(b,c){var a=this._properties[b];if(a)a(c)},onClick:function(){var b=this;if(b._element.childNodes.length==0){Xc(b);return false}if(a._session.isSignedIn()){if(a.canLogout())a.logout({})}else a.login(b._properties,true).then(function(){},function(a){b.fireEvent(nb,a)});return false},onLoggedIn:function(a){this.updateUI(this[Db],true);this.fireEvent(Hd,a)},onLoggedOut:function(a){this.updateUI(this[Fb],false);this.fireEvent(Cd,a)}};function af(b){if(a._authScope&&a._authScope!=="")b[g]=a._authScope;if(!b[g])b[g]=qe}function Le(d,a,c){a._handlers=a._handlers||{};var b=f(a,c);a._handlers[d]=b;return b}function Xe(b,a){return a._handlers[b]}a.ui=function(a){x("WL.ui");switch(a.name){case Qc:new Kc(a);break;case Pb:new yd(a)}};function Ee(a){m(a,[{name:C,allowedValues:[Hb,Gb],type:b,optional:true},{name:Xb,allowedValues:[tg,Hg,Bg,Dc,Bd,Lc],type:b,optional:true}],"WL.ui-signin");a[C]=a[C]||Hb;a[Xb]=a[Xb]||Dc}function Ff(f){var d=f[Xb],e=f[C],g=a._locale,b=g.indexOf("ar")>-1||g.indexOf("he")>-1?"RTL":"LTR",h="cursor:pointer;background-color:transparent;border:solid 0px;display:inline-block;overflow:hidden;white-space:nowrap;padding:0px;width:auto;",c="margin:0px;padding:0px;border-width:0px;vertical-align:middle;background-attachment:scroll;display:inline-block;white-space:nowrap;",k=uc(d,b,e,"left")+c,i=uc(d,b,e,"center")+c,j=uc(d,b,e,"right")+c;return '<button style="'+h+'"><span style="'+k+'"></span><span style="'+i+'"><span style="'+kf(b)+'"></span></span><span style="'+j+'"></span></button>'}function kf(g){var b=a._browser,j=b.ie6||b.ie7,k=b.ie8||b.ie9,f=b.chrome||b.safari?"padding:2px 3px;margin:0px;":"padding:1px 3px;margin:0px;",h="font-family: Segoe UI, Verdana, Tahoma, Helvetica, Arial, sans-serif;",e="direction:"+g.toLowerCase()+";",d="text-decoration:none;color:#3975a0;display:inline-block;",c="150";switch(a._locale){case "ar-ploc-sa":if(!j)c="170";break;case "te":case "ja-ploc-jp":if(b.ie)c="190"}var i="height:18px;font-size:9pt;font-weight:bold;line-height:"+c+"%;";return f+e+d+h+i}function uc(a,b,i,g){a=a==Dc?Bd:a;var h=a+"_"+b+"_"+i,e,d,c,f="background: url({imgpath}/signincontrol/{image}.png) scroll {repeat} 0px {vpos}; height: 22px; width: {width};";switch(g){case "left":e=a===Lc||b==="RTL"?"3px":"25px";d=b==="LTR"?"0px":"-44px";c="no-repeat";break;case "center":e="auto";d="-22px";c="repeat-x";break;case "right":e=a===Lc||b==="LTR"?"3px":"25px";d=b==="LTR"?"-44px":"0px";c="no-repeat"}return f.replace("{imgpath}",pe()).replace("{image}",h).replace("{vpos}",d).replace("{width}",e).replace("{repeat}",c)}Kc.prototype.updateUI=function(d){if(this._element.childNodes.length==0){Xc(this);return}if(d!=this._text){var c=a._browser,b=this._element.childNodes[0],e=b.childNodes[1];Ug(e.childNodes[0],d);this._text=d;if(c.ie6||c.ie7){e.style.width="auto";b.style.width="auto";var h=b.childNodes[0].clientWidth,f=b.childNodes[1].clientWidth,g=b.childNodes[2].clientWidth,i=h+f+g;b.style.width=i+"px";if(c.ie6){b.childNodes[0].style.width=h+"px";b.childNodes[1].style.width=f+"px";b.childNodes[2].style.width=g+"px"}}}};function Oe(a,b){a._button=b;z(b,"click",Le("click",a,a.onClick))}function Xc(a){var b=a._button;if(b){A(b,"click",Xe("click",a));delete a._button}}var yd=function(b){xd(b);var a=this;a._props=b;jb(f(a,a.init))};yd.prototype={init:function(){var a=this;if(a._inited===true)return;a._inited=true;try{var c=a._props,d=c[db],e=c[r];c[h]="WL.ui-"+Pb;a.validate();c[C]=c[C]||Gb;d=typeof d===b?pb(c[db]):d;a._element=d;var g=Pe(c);re(d,g);mf(d,f(a,a.onClick),f(a,a.onRender));a.onRender(false,false);B(e,c,false)}catch(i){t(i.message)}},validate:function(){var a=this._props;m(a,[{name:db,type:Sc,optional:false}],a[h])},onClick:function(){try{return a.fileDialog(this._props)}catch(b){t(b.message)}return false},onRender:function(){var k=this._props,f=k[C]===Gb,h=a._locale,e=h.indexOf("ar")>-1||h.indexOf("he")>-1,j=e?"RTL":"LTR",b=this._element.childNodes[0],i=b.childNodes[0],c=b.childNodes[1],d="#094AB2",g="#ffffff";b.style.direction=j;b.style.backgroundColor=f?g:d;b.style.border="solid 1px";b.style.borderColor=d;b.style.height="20px";b.style.paddingLeft="4px";b.style.paddingRight="4px";b.style.textAlign="center";b.style.cursor="pointer";i.style.verticalAlign="middle";i.style.height="16px";c.style.fontFamily="'Segoe UI', 'Segoe UI Web Regular', 'Helvetica Neue', 'BBAlpha Sans', 'S60 Sans', Arial, 'sans-serif'";c.style.fontSize="12px";c.style.fontWeight="bold";c.style.color=f?d:g;c.style.textAlign="center";c.style.verticalAlign="middle";c.style.marginLeft=e?"0px":"2px";c.style.marginRight=e?"2px":"0px"}};function Pe(b){var k=b[N],j=b[C],a=k===W,e=a?u.skyDriveOpenPickerButtonText:u.skyDriveSavePickerButtonText,c=a?u.skyDriveOpenPickerButtonTooltip:u.skyDriveSavePickerButtonTooltip,f=a?"skydriveopenpickerbutton":"skydrivesavepickerbutton",i=j===Hb?"SkyDriveIcon_white.png":"SkyDriveIcon_blue.png",h="<img alt='' src='"+pe()+"/SkyDrivePicker/"+i+"'>",g="<span>"+e+"</span>",d="<button id='"+f+"' title='"+c+"'>"+h+g+"</button>";return d}function mf(c,l,k){var a=c.childNodes[0];if(l){var f=function(b){if(c.childNodes.length==0){A(a,"click",f);return}l(b)};z(a,"click",f)}if(k){var d=false,e=false,g=function(a){e=true;b(a)},h=function(a){e=false;b(a)},i=function(a){d=true;b(a)},j=function(a){d=false;b(a)},b=function(){if(c.childNodes.length==0){A(a,"mouseenter",g);A(a,"mouseleave",h);A(document,"mousedown",i);A(document,"mouseup",j);return}k(d,e)};z(a,"mouseenter",g);z(a,"mouseleave",h);z(document,"mousedown",i);z(document,"mouseup",j)}}function gh(c){var a=document.cookie;c+="=";var b=a.indexOf(c);if(b>=0){b+=c.length;var d=a.indexOf(";",b);if(d<0)d=a.length;else{postCookie=a.substring(d);if(postCookie.indexOf(c)>=0)throw new Error(Me)}var e=a.substring(b,d);return e}return ""}function Be(g,d,f,e){d=d?d:"";var c=g+"="+d+"; path=/";if(f&&f!="localhost")c+="; domain="+encodeURIComponent(f);if(e!=null){var b=new Date(0);if(e>0){b=new Date;b.setTime(b.getTime()+e*1000)}c+=";expires="+b.toUTCString()}if(a._isHttps&&a._secureCookie)c+=";secure";document.cookie=c}var tb=function(a,b){this._cookieName=a;this._states=b||{};this._listeners=[];this._cookieWatcher=null};tb.prototype={getStates:function(){return this._states},get:function(a){return this._states[a]},set:function(b,a){this._states[b]=a},remove:function(a){if(this._states[a])delete this._states[a]},load:function(){try{var a=gh(this._cookieName);if(this._rawValue!=a){i("Cookie changed: "+this._cookieName+"="+a);this._rawValue=a;this._states=Eb(a);for(var b=0;b<this._listeners.length;b++)this._listeners[b]()}}catch(c){t(c.message);this.stopMonitor()}},flush:function(a){this._states=a;this.save()},populate:function(a){K(a,this._states);this.save()},save:function(){Be(this._cookieName,v(this._states),ee(),null)},clear:function(){this._states={};Be(this._cookieName,"",ee(),0)},addCookieChanged:function(a){this._listeners.push(a);this.startMonitor()},startMonitor:function(){this._refreshInterval=300;if(!this._cookieWatcher){i("Started monitoring cookie: "+this._cookieName);this._cookieWatcher=window.setInterval(f(this,this.load),this._refreshInterval)}},stopMonitor:function(){if(this._cookieWatcher){i("Stopped monitoring cookie: "+this._cookieName);window.clearInterval(this._cookieWatcher);this._cookieWatcher=null}},isBeingMonitored:function(){return this._cookieWatcher!==null}};function ee(){var b=a._domain||window.location.hostname.split(":")[0];return b}var Nc=function(d,b,c){var a=this;a._method=d;a._completed=false;a._requestFired=false;a._properties=b;a._callback=c;a._authMonitor=f(a,a._onAuthChanged);a.execute=a._method==Id?a._login:a._getLoginStatus};Nc.prototype={cancel:function(){this._onComplete({error:mb,error_description:Af})},_login:function(){var b=this;b._requestTs=(new Date).getTime();var e=a._browser.mobile,d=e&&a._browser.ie,h=e?Jc:oe,g=ne(h,b._properties.normalizedScope,xc(b._properties),b._requestTs,d,b._properties.state);if(d)document.location=g;else{b._popup=hh(g);i("AuthRequest-login: popup is opened. "+b._popup);b._popupWatcher=window.setInterval(f(b,b._checkPopup),3000);c.subscribe(Kb,b._authMonitor)}b._promise=new l("WL.login",null,null);return b._promise},_getLoginStatus:function(){hg(f(this,this._fireStatusRequest));this._timeout=window.setTimeout(f(this,this._onTimedOut),Df);this._promise=new l("WL.getLoginStatus",null,null);return this._promise},_fireStatusRequest:function(){var b=this;if(!b._requestFired){b._requestTs=(new Date).getTime();var d=a._refreshType===vc?ne(bc,a._authScope,xc(),b._requestTs,false):lg(xc(),a._authScope,b._requestTs);b._statusFrame=Jd(d);c.subscribe(Kb,b._authMonitor);b._requestFired=true}},_onAuthChanged:function(){var b=a._session.tryGetResponse(this._properties.normalizedScope,this._requestTs);if(b!=null)this._onComplete(this._normalizeResp(b))},_normalizeResp:function(b){if(this._method===kd&&b.error===Jb)return a._session.getNormalStatus();return b},_onTimedOut:function(){this._onComplete({error:Vb,error_description:sf})},_checkPopup:function(){try{if(this._popup===null)this._onComplete({error:Jb,error_description:Jf});else if(this._popup.closed)this._popup=null}catch(a){i("AuthRequest-checkPopup-error: "+a)}},_onComplete:function(a){if(!this._completed){this._completed=true;this._dispose();this._callback(this._properties,a);if(a[k])this._promise[o](a);else this._promise[n](a)}},_dispose:function(){i("AuthRequest: dispose "+this._method);if(this._timeout){window.clearTimeout(this._timeout);this._timeout=null}if(this._statusFrame!=null){document.body.removeChild(this._statusFrame);this._statusFrame=null}if(this._popupWatcher){window.clearInterval(this._popupWatcher);this._popupWatcher=null}c.unsubscribe(Kb,this._authMonitor)}};function hh(p){var c=525,b=525,e,d;if(a._browser.ie){var k=window.screenLeft,l=window.screenTop,f=document.documentElement,i=30;d=k+(f.clientWidth-c)/2;e=l+(f.clientHeight-b)/2-i}else{var n=window.screenX,o=window.screenY,j=window.outerWidth,h=window.outerHeight;d=n+(j-c)/2;e=o+(h-b)/2}var m=["width="+c,"height="+b,"top="+e,"left="+d,"status=no","resizable=yes","toolbar=no","menubar=no","scrollbars=yes"],g=window.open(p,"oauth",m.join(","));g.focus();return g}function lg(d,i,f){var b={};b[ac]=Md;b[s]=f;b[Qb]=a._secureCookie;b[ec]=bc;b[wc]=fd;if(a.trace)b[fc]=true;var j=v(b),c={};c[q]=a._session.get(q);c[lb]=ib;c[g]=i;c[V]=j;var h=d.indexOf("?")>0,e=h?"&":"?",k=d+e+v(c);return k}function ne(d,m,i,k,l,f){var b={};b[ac]=Md;b[ec]=d;b[s]=k;if(l)b[w]=window.location.href;if(a.trace)b[fc]=true;if(f)b[bh]=f;var e=d===bc?ib:a._response_type,h=e===ib?qd:fd;b[wc]=h;b[Qb]=a._secureCookie;var n=v(b),c={};c[q]=a._session.get(q);c[ec]=d;c[fh]=a._locale;c[w]=i;c[lb]=e;c[g]=m;c[V]=n;var j=Sd(),o="https://"+j+"/oauth20_authorize.srf?"+v(c);return o}function xc(c){var b=c!=null?c[w]:null;return b!=null&&b!=""?b:a._redirect_uri}var se=function(b,a){this._state={};this._state[q]=b;this._state[e]=T;this._cookieName=a;this.init()};se.prototype={get:function(a){return this._state[a]},save:function(){if(this._stateDirty){this._cookie.flush(this._state);this._stateDirty=false}},init:function(){var a=new tb(this._cookieName);a.load();this._cookie=a;if(a.get(q)!=this._state[q]){a.clear();a.flush(this._state)}else this._state=a.getStates();var b=this._state[e];this._statusChecked=b!==xb&&b!==T;this._cookie.addCookieChanged(f(this,this.onCookieChanged))},refresh:function(){a.getLoginStatus({internal:true},true);this._refresh=undefined},scheduleRefresh:function(){this.cancelRefresh();var a=(this.tokenExpiresIn()-600)*1000;if(a>0)this._refresh=window.setTimeout(f(this,this.refresh),a)},cancelRefresh:function(){if(this._refresh){window.clearTimeout(this._refresh);this._refresh=undefined}},updateStatus:function(a){var b=this._state[e],f=this._state[d];if(b!=a){this._state[e]=a;this._stateDirty=true;this.onStatusChanged(b,a);this.save();if(f!=this._state[d])c.notify(X,this.getNormalStatus())}},onStatusChanged:function(b,a){i("AuthSession: Auth status changed: "+b+"=>"+a);if(b!=a){var g=b==E,d=a==E;if(!d){for(var e=0;e<Tb.length;e++){var f=Tb[e];if(this._state[f])delete this._state[f]}this._stateDirty=true;this.save()}if(oc(b)!=oc(a))c.notify(nc,this.getNormalStatus());if(d!=g)if(d)c.notify(Rb,this.getNormalStatus());else c.notify(Bc,this.getNormalStatus())}},isSignedIn:function(){return this._state[e]===E},getNormalStatus:function(){var a=this.getStatus();a[e]=oc(a[e]);return a},tokenExpiresIn:function(){var a=this._state,c=a[e],b=parseInt(a[gb]);if(c===E)return b-Td();return -1},onCookieChanged:function(){var b=this._state,a=this._cookie.getStates();this._state=a;i("AuthSession: cookie changed. Has token: "+(a[d]!=null));this._statusChecked=a[e]!==T;if(b[d]!=a[d]||b[k]!=a[k]||b[s]!=a[s]){c.notify(Kb);delete a[k];delete a[D];this._stateDirty=true}if(b[e]!=a[e])this.onStatusChanged(b[e],a[e]);if(b[d]!=a[d]){c.notify(X,this.getNormalStatus());if(a[d])this.scheduleRefresh();else this.cancelRefresh()}this.save()},getStatus:function(){var b=null,c=this._state[e];if(c===E){var f=this.tokenExpiresIn();if(f<=10){c=this._statusChecked?xb:T;this.updateStatus(c);window.setTimeout(function(){a.getLoginStatus({internal:true},true)},30000)}else{if(f<60)c=dc;b={};b[d]=this._state[d];b[Zb]=this._state[Zb];b[g]=this._state[g].split(" ");b[fb]=f;b[gb]=this._state[gb]}}else if(!this._statusChecked)c=T;return {status:c,session:b}},tryGetResponse:function(b,c){i("AuthSession.tryGetResponse: requestTs = "+c+" scope = "+b);var a=this.getStatus(),h=a[e];session=a[xe];if(h==T||h==dc)return null;if(c===undefined)if(b)return session&&ae(session[g],b)?a:null;else return a;var d=this._state,j=parseInt(d[s]),f=d[k],l=d[D];if(j>=c){if(session&&ae(session[g],b))return a;if(f)return Jg(f,l);if(!b)return a}return null}};function ae(e,a){if(a==null||U(a)=="")return true;var c=a.split(Ag);for(var b=0;b<c.length;b++){var d=U(c[b]);if(d!=""&&!Vg(e,d))return false}return true}function oc(a){return a===T?xb:a===dc?E:a}function xg(a){if(Mf(a))return;if(cg(a))return;if(Lf(a))return;var b={};b[Ub]=P;b[Nb]=ld;a.onCompleted(b)}function ih(){return window.XMLHttpRequest&&(new XMLHttpRequest).withCredentials!==undefined}function Sd(){return a[eb]}function Yd(){return a[Q]}function df(a){m(a,[{name:y,type:b,optional:false}],a[h])}function Lg(a){var b=a._properties,c=b[y];Nf(c,a)}var Nf=function(){var a=null,b=1;return function(c){var d={};d[Zg]=b;c=td(c,d);if(a===null){var e=pc();a=Jd(c,e)}else a.src=c}}();a.jsonp={};WL.Internal.jsonp=a.jsonp;function Mf(c){var i=document.getElementsByTagName("HEAD")[0],b=document.createElement("SCRIPT"),e=Qd(c._properties,e,[r,y]),f=c._id,g=rc();if(g!=null)e[d]=g;e[r]=Ie+f;e[rd]="true";var h=hb(c._url,e);if(h.length>Ed)return false;c.scriptTag=b;a.jsonp[f]=function(a){sc(f,b);c.onCompleted(a)};kg(b,c);b.setAttribute("async","async");b.type="text/javascript";b.src=h;i.appendChild(b);window.setTimeout(function(){if(c._completed)return;sc(f,b)},30000);return true}function kg(b,c){if(a._browser.ie&&b.attachEvent)b.attachEvent("onreadystatechange",function(a){Ic(a,c)});else{b.readyState="complete";b.addEventListener("load",function(a){Ic(a,c)},false);b.addEventListener("error",function(a){Ic(a,c)},false)}}function Ic(d,c){if(c._completed)return;var b=d.srcElement||d.currentTarget;if(!b.readyState)b=d.currentTarget;if(b.readyState!="complete"&&b.readyState!="loaded")return;var f=c._id;failure=d.type=="error"||a.jsonp[f]!=null;if(failure){sc(f,c.scriptTag);var e={};e[Ub]=zf;e[Nb]=od;c.onCompleted({error:e})}}function sc(b,c){delete a.jsonp[b];document.getElementsByTagName("HEAD")[0].removeChild(c)}function Lf(b){ch();if(a._browser.flashVersion<9)return false;a.xdrFlash.send(b);return true}a.xdrFlash={_id:"",_status:Cc,_flashObject:null,_requests:{},_pending:[],init:function(){if(this._status!=Cc)return;this._status=jf;var c=Ib("div");c.id="wl_xdr_container";document.body.appendChild(c);this._id=pc();var b=Cf,d=a[F]+"XDR.swf";b=b.replace(/{url}/g,d);b=b.replace(/{id}/g,this._id);b=b.replace(/{variables}/g,"domain="+document.domain);c.innerHTML=b},onReady:function(b){if(b){if(a._browser.firefox)this._flashObject=document.embeds[this._id];else this._flashObject=pb(this._id);this._status=md}else this._status=pg;while(this._pending.length>0)this.send(this._pending.shift())},onRequestCompleted:function(b,e,c,f){var d=a.xdrFlash._requests[b];delete a.xdrFlash._requests[b];zc(d,e,Kg(c),f)},send:function(a){if(this._status<md){this._pending.push(a);if(this._status==Cc)jb(f(this,this.init));return}if(this._flashObject!=null){this._requests[a._id]=a;var b=Ud(a);this.invoke("send",[a._id,b.url,b.method,b.body])}else zc(a,0,null,pf)},invoke:function(d,a){a=a||[];var c=window.__flash__argumentsToXML(a,0),e='<invoke name="'+d+'" returntype="javascript">'+c+"</invoke>",b=this._flashObject.CallFunction(e);if(b==null)return null;return eval(b)}};WL.Internal.xdrFlash=a.xdrFlash;function Kg(a){return a?a.replace(/\r/g," ").replace(/\n/g," "):a}var Cf="<object classid='clsid:d27cdb6e-ae6d-11cf-96b8-444553540000' codebase='https://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=7,0,0,0' width='300' height='300' id='{id}' name='{id}' type='application/x-shockwave-flash' data='{url}'>"+"<param name='movie' value='{url}'></param>"+"<param name='allowScriptAccess' value='always'></param>"+"<param name='FlashVars' value='{variables}'></param>"+"<embed play='true' menu='false' swLiveConnect='true' allowScriptAccess='always' type='application/x-shockwave-flash' FlashVars='{variables}' src='{url}' width='300' height='300' name='{id}'></embed>"+"</object>",tc=null;(function(){a.fileDialog=function(b){x(b[h]);if(a._pendingPickerOp!=null)throw new Error(Fe);return (new tc(b)).execute()};var i=0,b=1,g=2,e=3;tc=function(c){var b=this;b._props=c;b._startTs=(new Date).getTime();c[Bb]=c[Bb]||ic;c[Z]=c[Z]||Zc;b._state=i;b._authDelegate=f(b,b._onAuthResp);a._pendingPickerOp=b};tc.prototype={execute:function(){var a=this,b=new l(a._props[h],a,null);a._promise=b;a._process();return b},cancel:function(a){var b=this,c=b._props;if(b._state===e)return;if(!a)a=p(mb,Ob.replace("METHOD",this._props[h]));b._onComplete(a)},_process:function(){var a=this;switch(a._state){case i:a._validateAuth();break;case b:a._initPicker();break;case g:a._complete()}},_changeState:function(c,b){var a=this;if(a._state!==e&&a._state!==c){a._state=c;if(b)a._result=b;a._process()}},_onComplete:function(a){this._changeState(g,a)},_validateAuth:function(){var c=this;if(a._rpsAuth)c._changeState(b);else{var g=c._props[N]===W,d=g?Tg:Tf,f=c._props[h],e=650;d+=" "+qe;a.ensurePermission(d,e,f,c._authDelegate)}},_onAuthResp:function(c){var a=this;if(c.error){if(!a._channel)a._onComplete(c)}else{var e=c.session[d];a._props[d]=e;if(a._channel)a._channel.send(We,e);else a._changeState(b)}},_initPicker:function(){var b=this,d=b._props;m(d);b._channel=a.channel.registerOuterChannel(xf,Rc(d.url).host,d.frame.contentWindow,d.url,f(b,b._onMessage));c.subscribe(X,b._authDelegate);var e=function(a){if(a.keyCode===dh)b.cancel()};d.keydownHandler=e;z(window,"keydown",e);b._initTimeout()},_initTimeout:function(){var a=this;timeoutSeconds=a._props[Vc];if(timeoutSeconds&&timeoutSeconds>0)a._timeout=window.setTimeout(f(a,a._onTimeout),timeoutSeconds*1000)},_onTimeout:function(){var a=this,b=a._channel._connected;if(!b)a.cancel(p(Vb,ef));a._clearTimeout()},_clearTimeout:function(){var a=this;if(a._timeout){window.clearTimeout(a._timeout);a._timeout=undefined}},_complete:function(){var b=this,c=b._result,d=c.error?o:n;b._state=e;b._cleanup();b._normalizeResp();if(b._props[h]===yc)B(b._props[r],c,true);else if(c.data)B(b._props[dd],c,true);else B(b._props[nb],c,true);b._promise[d](c);if(!a._rpsAuth)ub(function(){b._report()})},_report:function(){var e=this._props,b=this._result,k=((new Date).getTime()-this._startTs)/1000,i="none",c=0,d=0;if(b.data){if(b.data.folders!=null)c=b.data.folders.length;if(b.data.files!=null)d=b.data.files.length}i=c>0&&d>0?"both":c>0?"folder":d>0?"file":"none";var j=c+d,g={client:Pb,api:e[h],mode:e[N],select:e[Z],result:b.error?b.error.code:"success",duration:k,object_selected:i,selected_count:j},f=a[Lb];a.api({path:"web_analytics",method:"POST",body:g});if(f)f(g)},_onMessage:function(a,b){zb(a);switch(a){case Ye:this._onComplete(b)}},_normalizeResp:function(){var e=this,g=e._props[N]===W,b=e._result.data,d=e._result.error,f=function(c){var b=c.upload_location;if(b)c.upload_location=b.replace("WL_APISERVICE_URL",a[Q])};if(b){if(b.folders)for(var c=0;c<b.folders.length;c++)f(b.folders[c]);if(b.files)for(var c=0;c<b.files.length;c++)f(b.files[c])}if(d&&d.message)d.message=d.message.replace("METHOD",e._props[h])},_cleanup:function(){var d=this,b=d._props,g=d._channel,f=b.resizeHandler,e=b.keydownHandler;d._clearTimeout();c.unsubscribe(X,d._authDelegate);if(b.lightBox){b.frame.style.display=Xd;b.lightBox.style.display=Xd;document.body.removeChild(b.frame);document.body.removeChild(b.lightBox);delete b.lightBox;delete b.frame}if(g){g.dispose();delete d._channel}if(f)A(window,"resize",f);if(e)A(window,"keydown",e);delete a._pendingPickerOp}};function m(c){var f=c[N]===W,e=f?800:500,d=f?600:450,g=c[Bb],n=g===Tc,i=n?0:60,o=g===ic?"white":"rgb(0,0,0)",l=i/100,h=j(e,d),m=k(c),b=document.createElement("div");b.style.top="0px";b.style.left="0px";b.style.position="fixed";b.style.width="100%";b.style.height="100%";b.style.display="block";b.style.backgroundColor=o;b.style.opacity=l;b.style.MozOpacity=l;b.style.filter="alpha(opacity="+i+")";b.style.zIndex="2600000";var a=document.createElement("iframe");a.id="picker"+(new Date).getTime();a.style.top=h.top;a.style.left=h.left;a.style.position="fixed";a.style.width=e+"px";a.style.height=d+"px";a.style.display="block";a.style.zIndex="2600001";a.style.borderWidth="1px";a.style.borderColor="gray";a.style.maxHeight="100%";a.style.maxWidth="100%";a.src=m;a.setAttribute("sutra","picker");document.body.appendChild(a);document.body.appendChild(b);c.resizeHandler=function(){var b=j(e,d);a.style.top=b.top;a.style.left=b.left};z(window,"resize",c.resizeHandler);c.lightBox=b;c.frame=a;c.url=m}function k(e){var f=e[N]===W,g=f?He:Ge,b={},c=he()+a[Yc];if(c.charAt(0)==="/")c=cc+c;b[hf]=g;b[Qf]=a._rpsAuth?gf:Ze;b[Bf]=window.location.hostname.toLowerCase();b[tf]=c;b[q]=a._appId;b[s]=(new Date).getTime();b[Xf]=a._locale;if(!a._rpsAuth)b[d]=e[d];if(f)b[Z]=e[Z];return hb(a[S],b)}function j(f,e){var b,c;if(a._browser.ie){var d=document.documentElement;b=(d.clientWidth-f)/2;c=(d.clientHeight-e)/2}else{b=(window.innerWidth-f)/2;c=(window.innerHeight-e)/2}b=b<10?10:b;c=c<10?10:c;return {left:b+"px",top:c+"px"}}})();var ie=60*1000;Fc.prototype._getStrategy=function(e){var g=this,c=e[h],a=e[cb],f="file";m(e,[{name:cb,type:Sc,optional:false}],c);if(typeof a===b)a=document.getElementById(a);if(!(a instanceof HTMLInputElement)||a.type!==f)throw Y(cb,c,"It must be an HTMLInputElement with its type attribute set to "+'"file" (i.e., <input type="file" />).');if(a.value==="")throw Y(cb,c,"It did not contain a selected file.");if(a.files&&window.FileReader){if(a.files.length!==1)throw Y(cb,c,"It must contain one selected file.");var i=a.files[0];g.setFileName(i.name);return new Cg(g,i)}var j=a.name!=="";if(!j)a.name=f;var d=null;if(a.form===null)d="It must be a child of an HTMLFormElement.";else if(a.form.length!==1)d="It must be the only HTMLInputElement in its parent HTMLFormElement.";else if(a.name!==f)d='Its name attribute must be set to "file" '+'(i.e., <input name="file" />).';if(d!==null)throw Y(cb,c,d);return new ed(g,a,c)};function ed(b,d,c){var a=this;a._op=b;a._iMethod=c;a._element=d;a._uploadIFrame=null;a._uploadTimeoutId=null;b.setFileName(undefined)}ed.prototype={getId:function(){var a=this;if(a._uploadIFrame===null)a._createUploadIFrame();return a._uploadIFrame.id},setUploadTimeout:function(){var a=this;a._uploadTimeoutId=window.setTimeout(function(){a.onTimeout()},ie)},clearUploadTimeout:function(){var a=this;if(a._uploadTimeoutId===null)return;window.clearTimeout(a._uploadTimeoutId);a._uploadTimeoutId=null},onTimeout:function(){var a=this;a._uploadTimeoutId=null;var b=a._iMethod+": did not receive a response in "+ie+" milliseconds.",c=p(Vb,b);a._op.uploadComplete(false,c)},onUploadComplete:function(a){var b=this;b.clearUploadTimeout();b._removeUploadIFrame();a=Ec(a);var d=a.error,c=typeof d===Wb;b._op.uploadComplete(c,a)},upload:function(a){this._multiPartFormUpload(a)},_getRequestUrl:function(d){var b={};b[w]=a._redirect_uri;var c={};c[ac]=Ad;c[fe]=this.getId();b[V]=v(c);return hb(d,b)},_createUploadIFrame:function(){var a=this;if(a._uploadIFrame!==null)return;a._uploadIFrame=Ib("iframe");a._uploadIFrame.name=a._uploadIFrame.id=pc();document.body.appendChild(a._uploadIFrame)},_multiPartFormUpload:function(c){var a=this;a._createUploadIFrame();var b=a._getRequestUrl(c);a._submitForm(b);a.setUploadTimeout();kb.add(a);uf()},_removeUploadIFrame:function(){var a=this;if(a._uploadIFrame===null)return;a._uploadIFrame.parentNode.removeChild(a._uploadIFrame);a._uploadIFrame=null},_submitForm:function(c){var b=this,a=b._element.form;a.target=b._uploadIFrame.name;a.method=Zd;a.enctype="multipart/form-data";a.action=c;a.submit()}};function Uc(){this._pendingUploads={}}Uc.prototype={add:function(a){var b=a.getId();this._pendingUploads[b]=a},hasPendingUploads:function(){for(var a in this._pendingUploads)return true;return false},isPending:function(a){return a in this._pendingUploads},get:function(a){return this._pendingUploads[a]},remove:function(a){delete this._pendingUploads[a]}};var kb=new Uc,uf=function(){var b=false,a=new tb(ke),c=function(){var d=a.getStates(),c=false;for(var b in d){if(!kb.isPending(b))continue;var f=d[b],e=kb.get(b);kb.remove(b);a.remove(b);c=true;e.onUploadComplete(f)}if(!kb.hasPendingUploads())a.stopMonitor();if(c){a.save();c=false}};return function(){if(a.isBeingMonitored())return;if(b)a.startMonitor();else{a.addCookieChanged(c);b=true}}}();function Cg(a,b){var c=this;c.upload=function(d){var c=null;if(window.File&&b instanceof window.File)c=new FileReader;c.onerror=function(b){error=b.target.error;a.onErr(error.name)};c.onload=function(e){var c=e.target.result,b=new XMLHttpRequest;b.open(Ng,d,true);b.onload=function(b){a.onResp(b.currentTarget.responseText)};b.onerror=function(b){a.onErr(b.currentTarget.statusText)};if(b.upload)b.upload.onprogress=function(b){if(b.lengthComputable){var c={bytesTransferred:b.loaded,totalBytes:b.total,progressPercentage:b.total===0?0:b.loaded/b.total*100};a.uploadProgress(c)}};a._cancel=f(b,b.abort);b.send(c)};c.readAsArrayBuffer(b)}}function Gf(){a._isHttps=document.location.protocol.toLowerCase()==cc}function ch(){if(a._browser.flash!==undefined)return;var b=0;try{if(a._browser.ie){var k=new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7"),f=k.GetVariable("$version"),i=f.split(" "),g=i[1],d=g.split(",");b=d[0]}else if(navigator.plugins&&navigator.plugins.length>0)if(navigator.plugins["Shockwave Flash 2.0"]||navigator.plugins["Shockwave Flash"]){var j=navigator.plugins["Shockwave Flash 2.0"]?" 2.0":"",e=navigator.plugins["Shockwave Flash"+j].description,h=e.split(" "),c=h[2].split(".");b=c[0]}}catch(l){}a._browser.flashVersion=b;a._browser.flash=b>=8}function Og(){if(a._documentReady===undefined)a._documentReady=(new Date).getTime()}function hg(b){jb(function(){if(a._browser.firefox&&(!a._documentReady||(new Date).getTime()-a._documentReady<1000))window.setTimeout(b,1000);else b()})}function jb(b){if(document.body)switch(document.readyState){case "complete":b();return;case "loaded":if(a._browser.webkit){b();return}break;case "interactive":case undefined:if(a._browser.firefox||a._browser.webkit){b();return}}if(document.addEventListener){document.addEventListener("DOMContentLoaded",b,false);document.addEventListener("load",b,false)}else if(window.attachEvent)window.attachEvent("onload",b);if(a._browser.ie&&document.attachEvent)document.attachEvent("onreadystatechange",function(){if(document.readyState==="complete"){document.detachEvent("onreadystatechange",arguments.callee);b()}})}function re(b,a){b.innerHTML=a}function z(a,b,c){if(a.addEventListener)a.addEventListener(b,c,false);else if(a.attachEvent)a.attachEvent("on"+b,c)}function A(a,b,c){if(a.removeEventListener)a.removeEventListener(b,c,false);else if(a.detachEvent)a.detachEvent("on"+b,c)}var Gc={registerOuterChannel:function(e,b,c,d,a){return G.registerChannel(e,b,c,d,a)},registerInnerChannel:function(c,b,a){return G.registerChannel(c,b,null,null,a)},isSupported:function(){return G.isSupported()}},G={_channels:[],isSupported:function(){return window.postMessage!=null},registerChannel:function(h,e,f,g,d){var b=G,c=b._channels,a=null;if(b.isSupported()){a=new Ld(h,e,f,g,d);if(c.length===0)z(window,"message",b._onMessage);c.push(a)}return a},unregisterChannel:function(d){var c=G,a=c._channels;for(var b=0;b<a.length;b++)if(a[b]==d){a.splice(b,1);break}if(a.length===0)A(window,"message",c._onMessage)},_onMessage:function(a){var d=G,a=a||window.event,c=Pg(a);if(c!=null){var b=d._findChannel(a,c);if(b!=null)switch(c.text){case ue:b._onConnectReq(a.source,a.origin);break;case te:b._onConnectAck(a.source);break;default:b._onMessage(c.text)}}},_findChannel:function(g,f){var d=G,c=d._channels,e=Xg(g.origin);for(var b=0;b<c.length;b++){var a=c[b];if(id(a._name,f.name)&&id(a._allowedDomain,e))return a}return null}},ue="@ConnectReq",te="@ConnectAck";function Ld(f,d,b,e,c){var a=this;a._name=f;a._allowedDomain=d;a._msgHandler=c;if(b){a._targetWindow=b;a._targetUrl=Mg(e);a._connect()}}Ld.prototype={_disposed:false,_connected:false,_allowedDomain:null,_targetWindow:null,_targetUrl:null,_msgHandler:null,_connectSchedule:-1,_pendingQueue:[],_recvQueue:[],dispose:function(){var a=this;if(!a._disposed){a._disposed=true;a._cancelConnect();G.unregisterChannel(a)}},send:function(c,d){var a=this;if(a._disposed)return;var b=Vf(c,d);if(a._connected)a._post(b);else a._pendingQueue.push(b)},_connect:function(){var a=this;if(a._disposed||a._connected)return;var b=function(){a._post(ue)};if(a._connectSchedule===-1){a._connectSchedule=window.setInterval(b,500);b()}},_post:function(b){var a=this,c=wg(a._name,b);a._targetWindow.postMessage(c,a._targetUrl)},_onConnectReq:function(c,b){var a=this;if(!a._connected){a._connected=true;a._targetWindow=c;a._targetUrl=b;a._post(te);a._onConnected()}},_onConnectAck:function(b){var a=this;if(!a._connected){a._targetWindow=b;a._onConnected()}},_onConnected:function(){var a=this,c=a._pendingQueue;a._connected=true;for(var b=0;b<c.length;b++)a._post(c[b]);a._pendingQueue=[];a._cancelConnect()},_cancelConnect:function(){var a=this;if(a._connectSchedule!=-1){window.clearInterval(a._connectSchedule);a._connectSchedule=-1}},_onMessage:function(b){if(this._msgHandler){var a=Uf(b);this._msgHandler(a.cmd,a.args)}}};function Mg(b){var a=b.indexOf("://");if(a>=0){a=b.indexOf("/",a+3);if(a>=0)b=b.substring(0,a)}return b}function Pg(a){var b=null;if(!Gd(a.origin)&&!Gd(a.data)&&a.source!=null)b=vg(a.data);return b}function wg(a,b){return "<"+a+">"+b}function vg(a){var c=null;if(a.charAt(0)=="<"){var b=a.indexOf(">");if(b>0){var d=a.substring(1,b),e=a.substr(b+1);c={name:d,text:e}}}return c}function Vf(a,c){var b={cmd:a,args:c};return JSON.stringify(b)}function Uf(b){var a=JSON.parse(b);return a}if(window.WL)a.channel=Gc;else window.WL={channel:Gc};var u={connect:"Connect",signIn:"Sign in",signOut:"Sign out",login:"Log in",logout:"Log out",skyDriveOpenPickerButtonText:"Open from SkyDrive",skyDriveOpenPickerButtonTooltip:"Open from SkyDrive",skyDriveSavePickerButtonText:"Save to SkyDrive",skyDriveSavePickerButtonTooltip:"Save to SkyDrive"};a._locale="en";a[M]="Web/DEVICE_"+Of("5.5.3501.0920");a.testInit=function(b){if(b.env)a._settings.init(b.env);if(b.skydrive_uri)a._settings[S]=b.skydrive_uri;if(b[Lb])a[Lb]=b[Lb]};var qb={};qb[eb]="login.live.com";qb[Q]="https://apis.live.net/v5.0/";qb[S]="https://skydrive.live.com/";qb[F]="//js.live.net/v5.0/";var yb={};yb[eb]="login.live.com";yb[Q]="https://df.apis.live.net/v5.0/";yb[S]="https://skydrive.live.com/";yb[F]="//df-js.live.net/v5.0/";var vb={};vb[eb]="login.live-int.com";vb[Q]="https://apis.live-int.net/v5.0/";vb[S]="https://skydrive.live-int.com/";vb[F]="//js.live-int.net/v5.0/";var ob={};ob[eb]="login.live-int.com";ob[Q]="https://current.apis.live-tst.net/v5.0/";ob[S]="https://skydrive.live-int.com/";ob[F]="//current-js.live-int.net/v5.0/";var sb={};sb[eb]="login.live-int.com";sb[Q]="https://bvt.apis.live-tst.net/v5.0/";sb[S]="https://skydrive-bvt.live-int.com/";sb[F]="//bvt-js.live-int.net/v5.0/";a._settings={PROD:qb,DF:yb,INT:vb,CURRENT:ob,BVT:sb,init:function(b){b=b.toUpperCase();var c=this[b];if(c)K(c,a)}};a._settings.init("PROD");a[Yc]="wl.skydrivepicker.debug.js";a.onloadInit()}})();
/*
 * ******************************************************************************
 *  jquery.mb.components
 *  file: jquery.browser.js
 *
 *  Copyright (c) 2001-2013. Matteo Bicocchi (Pupunzi);
 *  Open lab srl, Firenze - Italy
 *  email: matteo@open-lab.com
 *  site: 	http://pupunzi.com
 *  blog:	http://pupunzi.open-lab.com
 * 	http://open-lab.com
 *
 *  Licences: MIT, GPL
 *  http://www.opensource.org/licenses/mit-license.php
 *  http://www.gnu.org/licenses/gpl.html
 *
 *  last modified: 16/01/13 20.38
 *  *****************************************************************************
 */

/*******************************************************************************
 *
 * jquery.browser
 * Author: pupunzi
 * Creation date: 16/01/13
 *
 ******************************************************************************/
/*Browser detection patch*/

(function ($) {

    var jQversion = jQuery.fn.jquery.split(".");
    jQversion = parseInt(jQversion[0]) + (parseInt(jQversion[1]) / 10);

    if (jQversion[0] >= 0 || jQversion[1] < 8)
        return;

    jQuery.browser = {};
    jQuery.browser.mozilla = false;
    jQuery.browser.webkit = false;
    jQuery.browser.opera = false;
    jQuery.browser.msie = false;

    var nAgt = navigator.userAgent;
    jQuery.browser.name = navigator.appName;
    jQuery.browser.fullVersion = '' + parseFloat(navigator.appVersion);
    jQuery.browser.majorVersion = parseInt(navigator.appVersion, 10);
    var nameOffset, verOffset, ix;

    // In Opera, the true version is after "Opera" or after "Version"
    if ((verOffset = nAgt.indexOf("Opera")) != -1) {
        jQuery.browser.opera = true;
        jQuery.browser.name = "Opera";
        jQuery.browser.fullVersion = nAgt.substring(verOffset + 6);
        if ((verOffset = nAgt.indexOf("Version")) != -1)
            jQuery.browser.fullVersion = nAgt.substring(verOffset + 8);
    }
        // In MSIE, the true version is after "MSIE" in userAgent
    else if ((verOffset = nAgt.indexOf("MSIE")) != -1) {
        jQuery.browser.msie = true;
        jQuery.browser.name = "Microsoft Internet Explorer";
        jQuery.browser.fullVersion = nAgt.substring(verOffset + 5);
    }
        // In Chrome, the true version is after "Chrome"
    else if ((verOffset = nAgt.indexOf("Chrome")) != -1) {
        jQuery.browser.webkit = true;
        jQuery.browser.name = "Chrome";
        jQuery.browser.fullVersion = nAgt.substring(verOffset + 7);
    }
        // In Safari, the true version is after "Safari" or after "Version"
    else if ((verOffset = nAgt.indexOf("Safari")) != -1) {
        jQuery.browser.webkit = true;
        jQuery.browser.name = "Safari";
        jQuery.browser.fullVersion = nAgt.substring(verOffset + 7);
        if ((verOffset = nAgt.indexOf("Version")) != -1)
            jQuery.browser.fullVersion = nAgt.substring(verOffset + 8);
    }
        // In Firefox, the true version is after "Firefox"
    else if ((verOffset = nAgt.indexOf("Firefox")) != -1) {
        jQuery.browser.mozilla = true;
        jQuery.browser.name = "Firefox";
        jQuery.browser.fullVersion = nAgt.substring(verOffset + 8);
    }
        // In most other browsers, "name/version" is at the end of userAgent
    else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) <
            (verOffset = nAgt.lastIndexOf('/'))) {
        jQuery.browser.name = nAgt.substring(nameOffset, verOffset);
        jQuery.browser.fullVersion = nAgt.substring(verOffset + 1);
        if (jQuery.browser.name.toLowerCase() == jQuery.browser.name.toUpperCase()) {
            jQuery.browser.name = navigator.appName;
        }
    }
    // trim the fullVersion string at semicolon/space if present
    if ((ix = jQuery.browser.fullVersion.indexOf(";")) != -1)
        jQuery.browser.fullVersion = jQuery.browser.fullVersion.substring(0, ix);
    if ((ix = jQuery.browser.fullVersion.indexOf(" ")) != -1)
        jQuery.browser.fullVersion = jQuery.browser.fullVersion.substring(0, ix);

    jQuery.browser.majorVersion = parseInt('' + jQuery.browser.fullVersion, 10);
    if (isNaN(jQuery.browser.majorVersion)) {
        jQuery.browser.fullVersion = '' + parseFloat(navigator.appVersion);
        jQuery.browser.majorVersion = parseInt(navigator.appVersion, 10);
    }
    jQuery.browser.version = jQuery.browser.majorVersion;
})(jQuery);
/*
 AngularJS v1.2.0
 (c) 2010-2012 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(W,O,s){'use strict';function L(b){return function(){var a=arguments[0],c,a="["+(b?b+":":"")+a+"] http://errors.angularjs.org/undefined/"+(b?b+"/":"")+a;for(c=1;c<arguments.length;c++)a=a+(1==c?"?":"&")+"p"+(c-1)+"="+encodeURIComponent("function"==typeof arguments[c]?arguments[c].toString().replace(/ \{[\s\S]*$/,""):"undefined"==typeof arguments[c]?"undefined":"string"!=typeof arguments[c]?JSON.stringify(arguments[c]):arguments[c]);return Error(a)}}function pb(b){if(null==b||ya(b))return!1;
var a=b.length;return 1===b.nodeType&&a?!0:D(b)||J(b)||0===a||"number"===typeof a&&0<a&&a-1 in b}function q(b,a,c){var d;if(b)if(B(b))for(d in b)"prototype"!=d&&("length"!=d&&"name"!=d&&b.hasOwnProperty(d))&&a.call(c,b[d],d);else if(b.forEach&&b.forEach!==q)b.forEach(a,c);else if(pb(b))for(d=0;d<b.length;d++)a.call(c,b[d],d);else for(d in b)b.hasOwnProperty(d)&&a.call(c,b[d],d);return b}function Nb(b){var a=[],c;for(c in b)b.hasOwnProperty(c)&&a.push(c);return a.sort()}function Jc(b,a,c){for(var d=
Nb(b),e=0;e<d.length;e++)a.call(c,b[d[e]],d[e]);return d}function Ob(b){return function(a,c){b(c,a)}}function Za(){for(var b=ia.length,a;b;){b--;a=ia[b].charCodeAt(0);if(57==a)return ia[b]="A",ia.join("");if(90==a)ia[b]="0";else return ia[b]=String.fromCharCode(a+1),ia.join("")}ia.unshift("0");return ia.join("")}function Pb(b,a){a?b.$$hashKey=a:delete b.$$hashKey}function u(b){var a=b.$$hashKey;q(arguments,function(a){a!==b&&q(a,function(a,c){b[c]=a})});Pb(b,a);return b}function U(b){return parseInt(b,
10)}function Qb(b,a){return u(new (u(function(){},{prototype:b})),a)}function t(){}function za(b){return b}function aa(b){return function(){return b}}function x(b){return"undefined"==typeof b}function z(b){return"undefined"!=typeof b}function T(b){return null!=b&&"object"==typeof b}function D(b){return"string"==typeof b}function qb(b){return"number"==typeof b}function Ja(b){return"[object Date]"==Ka.apply(b)}function J(b){return"[object Array]"==Ka.apply(b)}function B(b){return"function"==typeof b}
function $a(b){return"[object RegExp]"==Ka.apply(b)}function ya(b){return b&&b.document&&b.location&&b.alert&&b.setInterval}function Kc(b){return b&&(b.nodeName||b.on&&b.find)}function Lc(b,a,c){var d=[];q(b,function(b,f,g){d.push(a.call(c,b,f,g))});return d}function ab(b,a){if(b.indexOf)return b.indexOf(a);for(var c=0;c<b.length;c++)if(a===b[c])return c;return-1}function La(b,a){var c=ab(b,a);0<=c&&b.splice(c,1);return a}function da(b,a){if(ya(b)||b&&b.$evalAsync&&b.$watch)throw Ma("cpws");if(a){if(b===
a)throw Ma("cpi");if(J(b))for(var c=a.length=0;c<b.length;c++)a.push(da(b[c]));else{c=a.$$hashKey;q(a,function(b,c){delete a[c]});for(var d in b)a[d]=da(b[d]);Pb(a,c)}}else(a=b)&&(J(b)?a=da(b,[]):Ja(b)?a=new Date(b.getTime()):$a(b)?a=RegExp(b.source):T(b)&&(a=da(b,{})));return a}function Mc(b,a){a=a||{};for(var c in b)b.hasOwnProperty(c)&&"$$"!==c.substr(0,2)&&(a[c]=b[c]);return a}function Aa(b,a){if(b===a)return!0;if(null===b||null===a)return!1;if(b!==b&&a!==a)return!0;var c=typeof b,d;if(c==typeof a&&
"object"==c)if(J(b)){if(!J(a))return!1;if((c=b.length)==a.length){for(d=0;d<c;d++)if(!Aa(b[d],a[d]))return!1;return!0}}else{if(Ja(b))return Ja(a)&&b.getTime()==a.getTime();if($a(b)&&$a(a))return b.toString()==a.toString();if(b&&b.$evalAsync&&b.$watch||a&&a.$evalAsync&&a.$watch||ya(b)||ya(a)||J(a))return!1;c={};for(d in b)if("$"!==d.charAt(0)&&!B(b[d])){if(!Aa(b[d],a[d]))return!1;c[d]=!0}for(d in a)if(!c.hasOwnProperty(d)&&"$"!==d.charAt(0)&&a[d]!==s&&!B(a[d]))return!1;return!0}return!1}function Rb(){return O.securityPolicy&&
O.securityPolicy.isActive||O.querySelector&&!(!O.querySelector("[ng-csp]")&&!O.querySelector("[data-ng-csp]"))}function rb(b,a){var c=2<arguments.length?ta.call(arguments,2):[];return!B(a)||a instanceof RegExp?a:c.length?function(){return arguments.length?a.apply(b,c.concat(ta.call(arguments,0))):a.apply(b,c)}:function(){return arguments.length?a.apply(b,arguments):a.call(b)}}function Nc(b,a){var c=a;"string"===typeof b&&"$"===b.charAt(0)?c=s:ya(a)?c="$WINDOW":a&&O===a?c="$DOCUMENT":a&&(a.$evalAsync&&
a.$watch)&&(c="$SCOPE");return c}function ma(b,a){return"undefined"===typeof b?s:JSON.stringify(b,Nc,a?"  ":null)}function Sb(b){return D(b)?JSON.parse(b):b}function Na(b){b&&0!==b.length?(b=w(""+b),b=!("f"==b||"0"==b||"false"==b||"no"==b||"n"==b||"[]"==b)):b=!1;return b}function ea(b){b=y(b).clone();try{b.html("")}catch(a){}var c=y("<div>").append(b).html();try{return 3===b[0].nodeType?w(c):c.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/,function(a,b){return"<"+w(b)})}catch(d){return w(c)}}function Tb(b){try{return decodeURIComponent(b)}catch(a){}}
function Ub(b){var a={},c,d;q((b||"").split("&"),function(b){b&&(c=b.split("="),d=Tb(c[0]),z(d)&&(b=z(c[1])?Tb(c[1]):!0,a[d]?J(a[d])?a[d].push(b):a[d]=[a[d],b]:a[d]=b))});return a}function Vb(b){var a=[];q(b,function(b,d){J(b)?q(b,function(b){a.push(ua(d,!0)+(!0===b?"":"="+ua(b,!0)))}):a.push(ua(d,!0)+(!0===b?"":"="+ua(b,!0)))});return a.length?a.join("&"):""}function sb(b){return ua(b,!0).replace(/%26/gi,"&").replace(/%3D/gi,"=").replace(/%2B/gi,"+")}function ua(b,a){return encodeURIComponent(b).replace(/%40/gi,
"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,a?"%20":"+")}function Oc(b,a){function c(a){a&&d.push(a)}var d=[b],e,f,g=["ng:app","ng-app","x-ng-app","data-ng-app"],h=/\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;q(g,function(a){g[a]=!0;c(O.getElementById(a));a=a.replace(":","\\:");b.querySelectorAll&&(q(b.querySelectorAll("."+a),c),q(b.querySelectorAll("."+a+"\\:"),c),q(b.querySelectorAll("["+a+"]"),c))});q(d,function(a){if(!e){var b=h.exec(" "+a.className+" ");b?(e=a,f=
(b[2]||"").replace(/\s+/g,",")):q(a.attributes,function(b){!e&&g[b.name]&&(e=a,f=b.value)})}});e&&a(e,f?[f]:[])}function Wb(b,a){var c=function(){b=y(b);if(b.injector()){var c=b[0]===O?"document":ea(b);throw Ma("btstrpd",c);}a=a||[];a.unshift(["$provide",function(a){a.value("$rootElement",b)}]);a.unshift("ng");c=Xb(a);c.invoke(["$rootScope","$rootElement","$compile","$injector","$animate",function(a,b,c,d,e){a.$apply(function(){b.data("$injector",d);c(b)(a)})}]);return c},d=/^NG_DEFER_BOOTSTRAP!/;
if(W&&!d.test(W.name))return c();W.name=W.name.replace(d,"");bb.resumeBootstrap=function(b){q(b,function(b){a.push(b)});c()}}function cb(b,a){a=a||"_";return b.replace(Pc,function(b,d){return(d?a:"")+b.toLowerCase()})}function tb(b,a,c){if(!b)throw Ma("areq",a||"?",c||"required");return b}function Oa(b,a,c){c&&J(b)&&(b=b[b.length-1]);tb(B(b),a,"not a function, got "+(b&&"object"==typeof b?b.constructor.name||"Object":typeof b));return b}function na(b,a){if("hasOwnProperty"===b)throw Ma("badname",
a);}function ub(b,a,c){if(!a)return b;a=a.split(".");for(var d,e=b,f=a.length,g=0;g<f;g++)d=a[g],b&&(b=(e=b)[d]);return!c&&B(b)?rb(e,b):b}function vb(b){if(b.startNode===b.endNode)return y(b.startNode);var a=b.startNode,c=[a];do{a=a.nextSibling;if(!a)break;c.push(a)}while(a!==b.endNode);return y(c)}function Qc(b){function a(a,b,c){return a[b]||(a[b]=c())}var c=L("$injector");return a(a(b,"angular",Object),"module",function(){var b={};return function(e,f,g){na(e,"module");f&&b.hasOwnProperty(e)&&(b[e]=
null);return a(b,e,function(){function a(c,d,e){return function(){b[e||"push"]([c,d,arguments]);return n}}if(!f)throw c("nomod",e);var b=[],d=[],l=a("$injector","invoke"),n={_invokeQueue:b,_runBlocks:d,requires:f,name:e,provider:a("$provide","provider"),factory:a("$provide","factory"),service:a("$provide","service"),value:a("$provide","value"),constant:a("$provide","constant","unshift"),animation:a("$animateProvider","register"),filter:a("$filterProvider","register"),controller:a("$controllerProvider",
"register"),directive:a("$compileProvider","directive"),config:l,run:function(a){d.push(a);return this}};g&&l(g);return n})}})}function Pa(b){return b.replace(Rc,function(a,b,d,e){return e?d.toUpperCase():d}).replace(Sc,"Moz$1")}function wb(b,a,c,d){function e(b){var e=c&&b?[this.filter(b)]:[this],m=a,k,l,n,r,p,C;if(!d||null!=b)for(;e.length;)for(k=e.shift(),l=0,n=k.length;l<n;l++)for(r=y(k[l]),m?r.triggerHandler("$destroy"):m=!m,p=0,r=(C=r.children()).length;p<r;p++)e.push(Ba(C[p]));return f.apply(this,
arguments)}var f=Ba.fn[b],f=f.$original||f;e.$original=f;Ba.fn[b]=e}function Q(b){if(b instanceof Q)return b;if(!(this instanceof Q)){if(D(b)&&"<"!=b.charAt(0))throw xb("nosel");return new Q(b)}if(D(b)){var a=O.createElement("div");a.innerHTML="<div>&#160;</div>"+b;a.removeChild(a.firstChild);yb(this,a.childNodes);y(O.createDocumentFragment()).append(this)}else yb(this,b)}function zb(b){return b.cloneNode(!0)}function Qa(b){Yb(b);var a=0;for(b=b.childNodes||[];a<b.length;a++)Qa(b[a])}function Zb(b,
a,c,d){if(z(d))throw xb("offargs");var e=ja(b,"events");ja(b,"handle")&&(x(a)?q(e,function(a,c){Ab(b,c,a);delete e[c]}):q(a.split(" "),function(a){x(c)?(Ab(b,a,e[a]),delete e[a]):La(e[a]||[],c)}))}function Yb(b,a){var c=b[db],d=Ra[c];d&&(a?delete Ra[c].data[a]:(d.handle&&(d.events.$destroy&&d.handle({},"$destroy"),Zb(b)),delete Ra[c],b[db]=s))}function ja(b,a,c){var d=b[db],d=Ra[d||-1];if(z(c))d||(b[db]=d=++Tc,d=Ra[d]={}),d[a]=c;else return d&&d[a]}function $b(b,a,c){var d=ja(b,"data"),e=z(c),f=!e&&
z(a),g=f&&!T(a);d||g||ja(b,"data",d={});if(e)d[a]=c;else if(f){if(g)return d&&d[a];u(d,a)}else return d}function Bb(b,a){return b.getAttribute?-1<(" "+(b.getAttribute("class")||"")+" ").replace(/[\n\t]/g," ").indexOf(" "+a+" "):!1}function Cb(b,a){a&&b.setAttribute&&q(a.split(" "),function(a){b.setAttribute("class",Y((" "+(b.getAttribute("class")||"")+" ").replace(/[\n\t]/g," ").replace(" "+Y(a)+" "," ")))})}function Db(b,a){if(a&&b.setAttribute){var c=(" "+(b.getAttribute("class")||"")+" ").replace(/[\n\t]/g,
" ");q(a.split(" "),function(a){a=Y(a);-1===c.indexOf(" "+a+" ")&&(c+=a+" ")});b.setAttribute("class",Y(c))}}function yb(b,a){if(a){a=a.nodeName||!z(a.length)||ya(a)?[a]:a;for(var c=0;c<a.length;c++)b.push(a[c])}}function ac(b,a){return eb(b,"$"+(a||"ngController")+"Controller")}function eb(b,a,c){b=y(b);9==b[0].nodeType&&(b=b.find("html"));for(a=J(a)?a:[a];b.length;){for(var d=0,e=a.length;d<e;d++)if((c=b.data(a[d]))!==s)return c;b=b.parent()}}function bc(b,a){var c=fb[a.toLowerCase()];return c&&
cc[b.nodeName]&&c}function Uc(b,a){var c=function(c,e){c.preventDefault||(c.preventDefault=function(){c.returnValue=!1});c.stopPropagation||(c.stopPropagation=function(){c.cancelBubble=!0});c.target||(c.target=c.srcElement||O);if(x(c.defaultPrevented)){var f=c.preventDefault;c.preventDefault=function(){c.defaultPrevented=!0;f.call(c)};c.defaultPrevented=!1}c.isDefaultPrevented=function(){return c.defaultPrevented||!1===c.returnValue};q(a[e||c.type],function(a){a.call(b,c)});8>=P?(c.preventDefault=
null,c.stopPropagation=null,c.isDefaultPrevented=null):(delete c.preventDefault,delete c.stopPropagation,delete c.isDefaultPrevented)};c.elem=b;return c}function Ca(b){var a=typeof b,c;"object"==a&&null!==b?"function"==typeof(c=b.$$hashKey)?c=b.$$hashKey():c===s&&(c=b.$$hashKey=Za()):c=b;return a+":"+c}function Sa(b){q(b,this.put,this)}function dc(b){var a,c;"function"==typeof b?(a=b.$inject)||(a=[],b.length&&(c=b.toString().replace(Vc,""),c=c.match(Wc),q(c[1].split(Xc),function(b){b.replace(Yc,function(b,
c,d){a.push(d)})})),b.$inject=a):J(b)?(c=b.length-1,Oa(b[c],"fn"),a=b.slice(0,c)):Oa(b,"fn",!0);return a}function Xb(b){function a(a){return function(b,c){if(T(b))q(b,Ob(a));else return a(b,c)}}function c(a,b){na(a,"service");if(B(b)||J(b))b=n.instantiate(b);if(!b.$get)throw Ta("pget",a);return l[a+h]=b}function d(a,b){return c(a,{$get:b})}function e(a){var b=[],c,d,f,h;q(a,function(a){if(!k.get(a)){k.put(a,!0);try{if(D(a))for(c=Ua(a),b=b.concat(e(c.requires)).concat(c._runBlocks),d=c._invokeQueue,
f=0,h=d.length;f<h;f++){var g=d[f],m=n.get(g[0]);m[g[1]].apply(m,g[2])}else B(a)?b.push(n.invoke(a)):J(a)?b.push(n.invoke(a)):Oa(a,"module")}catch(l){throw J(a)&&(a=a[a.length-1]),l.message&&(l.stack&&-1==l.stack.indexOf(l.message))&&(l=l.message+"\n"+l.stack),Ta("modulerr",a,l.stack||l.message||l);}}});return b}function f(a,b){function c(d){if(a.hasOwnProperty(d)){if(a[d]===g)throw Ta("cdep",m.join(" <- "));return a[d]}try{return m.unshift(d),a[d]=g,a[d]=b(d)}finally{m.shift()}}function d(a,b,e){var f=
[],h=dc(a),g,k,m;k=0;for(g=h.length;k<g;k++){m=h[k];if("string"!==typeof m)throw Ta("itkn",m);f.push(e&&e.hasOwnProperty(m)?e[m]:c(m))}a.$inject||(a=a[g]);switch(b?-1:f.length){case 0:return a();case 1:return a(f[0]);case 2:return a(f[0],f[1]);case 3:return a(f[0],f[1],f[2]);case 4:return a(f[0],f[1],f[2],f[3]);case 5:return a(f[0],f[1],f[2],f[3],f[4]);case 6:return a(f[0],f[1],f[2],f[3],f[4],f[5]);case 7:return a(f[0],f[1],f[2],f[3],f[4],f[5],f[6]);case 8:return a(f[0],f[1],f[2],f[3],f[4],f[5],f[6],
f[7]);case 9:return a(f[0],f[1],f[2],f[3],f[4],f[5],f[6],f[7],f[8]);case 10:return a(f[0],f[1],f[2],f[3],f[4],f[5],f[6],f[7],f[8],f[9]);default:return a.apply(b,f)}}return{invoke:d,instantiate:function(a,b){var c=function(){},e;c.prototype=(J(a)?a[a.length-1]:a).prototype;c=new c;e=d(a,c,b);return T(e)||B(e)?e:c},get:c,annotate:dc,has:function(b){return l.hasOwnProperty(b+h)||a.hasOwnProperty(b)}}}var g={},h="Provider",m=[],k=new Sa,l={$provide:{provider:a(c),factory:a(d),service:a(function(a,b){return d(a,
["$injector",function(a){return a.instantiate(b)}])}),value:a(function(a,b){return d(a,aa(b))}),constant:a(function(a,b){na(a,"constant");l[a]=b;r[a]=b}),decorator:function(a,b){var c=n.get(a+h),d=c.$get;c.$get=function(){var a=p.invoke(d,c);return p.invoke(b,null,{$delegate:a})}}}},n=l.$injector=f(l,function(){throw Ta("unpr",m.join(" <- "));}),r={},p=r.$injector=f(r,function(a){a=n.get(a+h);return p.invoke(a.$get,a)});q(e(b),function(a){p.invoke(a||t)});return p}function Zc(){var b=!0;this.disableAutoScrolling=
function(){b=!1};this.$get=["$window","$location","$rootScope",function(a,c,d){function e(a){var b=null;q(a,function(a){b||"a"!==w(a.nodeName)||(b=a)});return b}function f(){var b=c.hash(),d;b?(d=g.getElementById(b))?d.scrollIntoView():(d=e(g.getElementsByName(b)))?d.scrollIntoView():"top"===b&&a.scrollTo(0,0):a.scrollTo(0,0)}var g=a.document;b&&d.$watch(function(){return c.hash()},function(){d.$evalAsync(f)});return f}]}function $c(b,a,c,d){function e(a){try{a.apply(null,ta.call(arguments,1))}finally{if(C--,
0===C)for(;H.length;)try{H.pop()()}catch(b){c.error(b)}}}function f(a,b){(function gb(){q(I,function(a){a()});A=b(gb,a)})()}function g(){v=null;S!=h.url()&&(S=h.url(),q(Z,function(a){a(h.url())}))}var h=this,m=a[0],k=b.location,l=b.history,n=b.setTimeout,r=b.clearTimeout,p={};h.isMock=!1;var C=0,H=[];h.$$completeOutstandingRequest=e;h.$$incOutstandingRequestCount=function(){C++};h.notifyWhenNoOutstandingRequests=function(a){q(I,function(a){a()});0===C?a():H.push(a)};var I=[],A;h.addPollFn=function(a){x(A)&&
f(100,n);I.push(a);return a};var S=k.href,G=a.find("base"),v=null;h.url=function(a,c){k!==b.location&&(k=b.location);if(a){if(S!=a)return S=a,d.history?c?l.replaceState(null,"",a):(l.pushState(null,"",a),G.attr("href",G.attr("href"))):(v=a,c?k.replace(a):k.href=a),h}else return v||k.href.replace(/%27/g,"'")};var Z=[],E=!1;h.onUrlChange=function(a){if(!E){if(d.history)y(b).on("popstate",g);if(d.hashchange)y(b).on("hashchange",g);else h.addPollFn(g);E=!0}Z.push(a);return a};h.baseHref=function(){var a=
G.attr("href");return a?a.replace(/^https?\:\/\/[^\/]*/,""):""};var oa={},$="",va=h.baseHref();h.cookies=function(a,b){var d,e,f,h;if(a)b===s?m.cookie=escape(a)+"=;path="+va+";expires=Thu, 01 Jan 1970 00:00:00 GMT":D(b)&&(d=(m.cookie=escape(a)+"="+escape(b)+";path="+va).length+1,4096<d&&c.warn("Cookie '"+a+"' possibly not set or overflowed because it was too large ("+d+" > 4096 bytes)!"));else{if(m.cookie!==$)for($=m.cookie,d=$.split("; "),oa={},f=0;f<d.length;f++)e=d[f],h=e.indexOf("="),0<h&&(a=
unescape(e.substring(0,h)),oa[a]===s&&(oa[a]=unescape(e.substring(h+1))));return oa}};h.defer=function(a,b){var c;C++;c=n(function(){delete p[c];e(a)},b||0);p[c]=!0;return c};h.defer.cancel=function(a){return p[a]?(delete p[a],r(a),e(t),!0):!1}}function bd(){this.$get=["$window","$log","$sniffer","$document",function(b,a,c,d){return new $c(b,d,a,c)}]}function cd(){this.$get=function(){function b(b,d){function e(a){a!=n&&(r?r==a&&(r=a.n):r=a,f(a.n,a.p),f(a,n),n=a,n.n=null)}function f(a,b){a!=b&&(a&&
(a.p=b),b&&(b.n=a))}if(b in a)throw L("$cacheFactory")("iid",b);var g=0,h=u({},d,{id:b}),m={},k=d&&d.capacity||Number.MAX_VALUE,l={},n=null,r=null;return a[b]={put:function(a,b){var c=l[a]||(l[a]={key:a});e(c);if(!x(b))return a in m||g++,m[a]=b,g>k&&this.remove(r.key),b},get:function(a){var b=l[a];if(b)return e(b),m[a]},remove:function(a){var b=l[a];b&&(b==n&&(n=b.p),b==r&&(r=b.n),f(b.n,b.p),delete l[a],delete m[a],g--)},removeAll:function(){m={};g=0;l={};n=r=null},destroy:function(){l=h=m=null;delete a[b]},
info:function(){return u({},h,{size:g})}}}var a={};b.info=function(){var b={};q(a,function(a,e){b[e]=a.info()});return b};b.get=function(b){return a[b]};return b}}function dd(){this.$get=["$cacheFactory",function(b){return b("templates")}]}function ec(b){var a={},c="Directive",d=/^\s*directive\:\s*([\d\w\-_]+)\s+(.*)$/,e=/(([\d\w\-_]+)(?:\:([^;]+))?;?)/,f=/^\s*(https?|ftp|mailto|tel|file):/,g=/^\s*(https?|ftp|file):|data:image\//,h=/^(on[a-z]+|formaction)$/;this.directive=function k(d,e){na(d,"directive");
D(d)?(tb(e,"directiveFactory"),a.hasOwnProperty(d)||(a[d]=[],b.factory(d+c,["$injector","$exceptionHandler",function(b,c){var e=[];q(a[d],function(a,f){try{var h=b.invoke(a);B(h)?h={compile:aa(h)}:!h.compile&&h.link&&(h.compile=aa(h.link));h.priority=h.priority||0;h.index=f;h.name=h.name||d;h.require=h.require||h.controller&&h.name;h.restrict=h.restrict||"A";e.push(h)}catch(g){c(g)}});return e}])),a[d].push(e)):q(d,Ob(k));return this};this.aHrefSanitizationWhitelist=function(a){return z(a)?(f=a,this):
f};this.imgSrcSanitizationWhitelist=function(a){return z(a)?(g=a,this):g};this.$get=["$injector","$interpolate","$exceptionHandler","$http","$templateCache","$parse","$controller","$rootScope","$document","$sce","$animate",function(b,l,n,r,p,C,H,I,A,S,G){function v(a,b,c,d,e){a instanceof y||(a=y(a));q(a,function(b,c){3==b.nodeType&&b.nodeValue.match(/\S+/)&&(a[c]=y(b).wrap("<span></span>").parent()[0])});var f=E(a,b,a,c,d,e);return function(b,c){tb(b,"scope");for(var d=c?Da.clone.call(a):a,e=0,h=
d.length;e<h;e++){var g=d[e];1!=g.nodeType&&9!=g.nodeType||d.eq(e).data("$scope",b)}Z(d,"ng-scope");c&&c(d,b);f&&f(b,d,d);return d}}function Z(a,b){try{a.addClass(b)}catch(c){}}function E(a,b,c,d,e,f){function h(a,c,d,e){var f,k,l,n,p,r,C,X=[];p=0;for(r=c.length;p<r;p++)X.push(c[p]);C=p=0;for(r=g.length;p<r;C++)k=X[C],c=g[p++],f=g[p++],l=y(k),c?(c.scope?(n=a.$new(),l.data("$scope",n),Z(l,"ng-scope")):n=a,(l=c.transclude)||!e&&b?c(f,n,k,d,function(b){return function(c){var d=a.$new();d.$$transcluded=
!0;return b(d,c).on("$destroy",rb(d,d.$destroy))}}(l||b)):c(f,n,k,s,e)):f&&f(a,k.childNodes,s,e)}for(var g=[],k,l,n,p=0;p<a.length;p++)l=new R,k=oa(a[p],[],l,0===p?d:s,e),k=(f=k.length?M(k,a[p],l,b,c,null,[],[],f):null)&&f.terminal||!a[p].childNodes||!a[p].childNodes.length?null:E(a[p].childNodes,f?f.transclude:b),g.push(f),g.push(k),n=n||f||k,f=null;return n?h:null}function oa(a,b,c,f,h){var g=c.$attr,k;switch(a.nodeType){case 1:N(b,ka(Ea(a).toLowerCase()),"E",f,h);var l,n,p;k=a.attributes;for(var r=
0,C=k&&k.length;r<C;r++){var H=!1,v=!1;l=k[r];if(!P||8<=P||l.specified){n=l.name;p=ka(n);Fa.test(p)&&(n=cb(p.substr(6),"-"));var q=p.replace(/(Start|End)$/,"");p===q+"Start"&&(H=n,v=n.substr(0,n.length-5)+"end",n=n.substr(0,n.length-6));p=ka(n.toLowerCase());g[p]=n;c[p]=l=Y(P&&"href"==n?decodeURIComponent(a.getAttribute(n,2)):l.value);bc(a,p)&&(c[p]=!0);w(a,b,l,p);N(b,p,"A",f,h,H,v)}}a=a.className;if(D(a)&&""!==a)for(;k=e.exec(a);)p=ka(k[2]),N(b,p,"C",f,h)&&(c[p]=Y(k[3])),a=a.substr(k.index+k[0].length);
break;case 3:t(b,a.nodeValue);break;case 8:try{if(k=d.exec(a.nodeValue))p=ka(k[1]),N(b,p,"M",f,h)&&(c[p]=Y(k[2]))}catch(S){}}b.sort(wa);return b}function $(a,b,c){var d=[],e=0;if(b&&a.hasAttribute&&a.hasAttribute(b)){do{if(!a)throw fa("uterdir",b,c);1==a.nodeType&&(a.hasAttribute(b)&&e++,a.hasAttribute(c)&&e--);d.push(a);a=a.nextSibling}while(0<e)}else d.push(a);return y(d)}function va(a,b,c){return function(d,e,f,h){e=$(e[0],b,c);return a(d,e,f,h)}}function M(a,b,c,d,e,f,h,k,g){function p(a,b,c,
d){if(a){c&&(a=va(a,c,d));a.require=F.require;if(G===F||F.$$isolateScope)a=Q(a,{isolateScope:!0});h.push(a)}if(b){c&&(b=va(b,c,d));b.require=F.require;if(G===F||F.$$isolateScope)b=Q(b,{isolateScope:!0});k.push(b)}}function r(a,b){var c,d="data",e=!1;if(D(a)){for(;"^"==(c=a.charAt(0))||"?"==c;)a=a.substr(1),"^"==c&&(d="inheritedData"),e=e||"?"==c;c=b[d]("$"+a+"Controller");8==b[0].nodeType&&b[0].$$controller&&(c=c||b[0].$$controller,b[0].$$controller=null);if(!c&&!e)throw fa("ctreq",a,ba);}else J(a)&&
(c=[],q(a,function(a){c.push(r(a,b))}));return c}function S(a,d,e,f,g){var p,X,v,E,I,K;p=b===e?c:Mc(c,new R(y(e),c.$attr));X=p.$$element;if(G){var va=/^\s*([@=&])(\??)\s*(\w*)\s*$/;f=y(e);K=d.$new(!0);N&&N===G.$$originalDirective?f.data("$isolateScope",K):f.data("$isolateScopeNoTemplate",K);Z(f,"ng-isolate-scope");q(G.scope,function(a,b){var c=a.match(va)||[],e=c[3]||b,f="?"==c[2],c=c[1],h,g,k;K.$$isolateBindings[b]=c+e;switch(c){case "@":p.$observe(e,function(a){K[b]=a});p.$$observers[e].$$scope=
d;p[e]&&(K[b]=l(p[e])(d));break;case "=":if(f&&!p[e])break;g=C(p[e]);k=g.assign||function(){h=K[b]=g(d);throw fa("nonassign",p[e],G.name);};h=K[b]=g(d);K.$watch(function(){var a=g(d);a!==K[b]&&(a!==h?h=K[b]=a:k(d,a=h=K[b]));return a});break;case "&":g=C(p[e]);K[b]=function(a){return g(d,a)};break;default:throw fa("iscp",G.name,b,a);}})}A&&q(A,function(a){var b={$scope:a===G||a.$$isolateScope?K:d,$element:X,$attrs:p,$transclude:g},c;I=a.controller;"@"==I&&(I=p[a.name]);c=H(I,b);8==X[0].nodeType?X[0].$$controller=
c:X.data("$"+a.name+"Controller",c);a.controllerAs&&(b.$scope[a.controllerAs]=c)});f=0;for(v=h.length;f<v;f++)try{E=h[f],E(E.isolateScope?K:d,X,p,E.require&&r(E.require,X))}catch(M){n(M,ea(X))}f=d;G&&(G.template||null===G.templateUrl)&&(f=K);a&&a(f,e.childNodes,s,g);for(f=k.length-1;0<=f;f--)try{E=k[f],E(E.isolateScope?K:d,X,p,E.require&&r(E.require,X))}catch($){n($,ea(X))}}g=g||{};var E=-Number.MAX_VALUE,I,A=g.controllerDirectives,G=g.newIsolateScopeDirective,N=g.templateDirective;g=g.transcludeDirective;
for(var M=c.$$element=y(b),F,ba,t,wa=d,x,ga=0,w=a.length;ga<w;ga++){F=a[ga];var u=F.$$start,Fa=F.$$end;u&&(M=$(b,u,Fa));t=s;if(E>F.priority)break;if(t=F.scope)I=I||F,F.templateUrl||(Va("new/isolated scope",G,F,M),T(t)&&(G=F));ba=F.name;!F.templateUrl&&F.controller&&(t=F.controller,A=A||{},Va("'"+ba+"' controller",A[ba],F,M),A[ba]=F);if(t=F.transclude)F.$$tlb||(Va("transclusion",g,F,M),g=F),"element"==t?(E=F.priority,t=$(b,u,Fa),M=c.$$element=y(O.createComment(" "+ba+": "+c[ba]+" ")),b=M[0],L(e,y(ta.call(t,
0)),b),wa=v(t,d,E,f&&f.name,{transcludeDirective:g})):(t=y(zb(b)).contents(),M.html(""),wa=v(t,d));if(F.template)if(Va("template",N,F,M),N=F,t=B(F.template)?F.template(M,c):F.template,t=fc(t),F.replace){f=F;t=y("<div>"+Y(t)+"</div>").contents();b=t[0];if(1!=t.length||1!==b.nodeType)throw fa("tplrt",ba,"");L(e,M,b);w={$attr:{}};t=oa(b,[],w);var P=a.splice(ga+1,a.length-(ga+1));G&&z(t);a=a.concat(t).concat(P);gb(c,w);w=a.length}else M.html(t);if(F.templateUrl)Va("template",N,F,M),N=F,F.replace&&(f=
F),S=ad(a.splice(ga,a.length-ga),M,c,e,wa,h,k,{controllerDirectives:A,newIsolateScopeDirective:G,templateDirective:N,transcludeDirective:g}),w=a.length;else if(F.compile)try{x=F.compile(M,c,wa),B(x)?p(null,x,u,Fa):x&&p(x.pre,x.post,u,Fa)}catch(ed){n(ed,ea(M))}F.terminal&&(S.terminal=!0,E=Math.max(E,F.priority))}S.scope=I&&!0===I.scope;S.transclude=g&&wa;return S}function z(a){for(var b=0,c=a.length;b<c;b++)a[b]=Qb(a[b],{$$isolateScope:!0})}function N(d,e,f,h,g,l,p){if(e===g)return null;g=null;if(a.hasOwnProperty(e)){var r;
e=b.get(e+c);for(var C=0,H=e.length;C<H;C++)try{r=e[C],(h===s||h>r.priority)&&-1!=r.restrict.indexOf(f)&&(l&&(r=Qb(r,{$$start:l,$$end:p})),d.push(r),g=r)}catch(E){n(E)}}return g}function gb(a,b){var c=b.$attr,d=a.$attr,e=a.$$element;q(a,function(d,e){"$"!=e.charAt(0)&&(b[e]&&(d+=("style"===e?";":" ")+b[e]),a.$set(e,d,!0,c[e]))});q(b,function(b,f){"class"==f?(Z(e,b),a["class"]=(a["class"]?a["class"]+" ":"")+b):"style"==f?e.attr("style",e.attr("style")+";"+b):"$"==f.charAt(0)||a.hasOwnProperty(f)||
(a[f]=b,d[f]=c[f])})}function ad(a,b,c,d,e,f,h,g){var k=[],n,l,C=b[0],H=a.shift(),v=u({},H,{templateUrl:null,transclude:null,replace:null,$$originalDirective:H}),I=B(H.templateUrl)?H.templateUrl(b,c):H.templateUrl;b.html("");r.get(S.getTrustedResourceUrl(I),{cache:p}).success(function(p){var r;p=fc(p);if(H.replace){p=y("<div>"+Y(p)+"</div>").contents();r=p[0];if(1!=p.length||1!==r.nodeType)throw fa("tplrt",H.name,I);p={$attr:{}};L(d,b,r);var S=oa(r,[],p);T(H.scope)&&z(S);a=S.concat(a);gb(c,p)}else r=
C,b.html(p);a.unshift(v);n=M(a,r,c,e,b,H,f,h,g);q(d,function(a,c){a==r&&(d[c]=b[0])});for(l=E(b[0].childNodes,e);k.length;){p=k.shift();var S=k.shift(),Z=k.shift(),G=k.shift(),A=b[0];S!==C&&(A=zb(r),L(Z,y(S),A));n(l,p,A,d,G)}k=null}).error(function(a,b,c,d){throw fa("tpload",d.url);});return function(a,b,c,d,e){k?(k.push(b),k.push(c),k.push(d),k.push(e)):n(l,b,c,d,e)}}function wa(a,b){var c=b.priority-a.priority;return 0!==c?c:a.name!==b.name?a.name<b.name?-1:1:a.index-b.index}function Va(a,b,c,d){if(b)throw fa("multidir",
b.name,c.name,a,ea(d));}function t(a,b){var c=l(b,!0);c&&a.push({priority:0,compile:aa(function(a,b){var d=b.parent(),e=d.data("$binding")||[];e.push(c);Z(d.data("$binding",e),"ng-binding");a.$watch(c,function(a){b[0].nodeValue=a})})})}function x(a,b){if("xlinkHref"==b||"IMG"!=Ea(a)&&("src"==b||"ngSrc"==b))return S.RESOURCE_URL}function w(a,b,c,d){var e=l(c,!0);if(e){if("multiple"===d&&"SELECT"===Ea(a))throw fa("selmulti",ea(a));b.push({priority:100,compile:function(){return{pre:function(b,c,f){c=
f.$$observers||(f.$$observers={});if(h.test(d))throw fa("nodomevents");if(e=l(f[d],!0,x(a,d)))f[d]=e(b),(c[d]||(c[d]=[])).$$inter=!0,(f.$$observers&&f.$$observers[d].$$scope||b).$watch(e,function(a){f.$set(d,a)})}}}})}}function L(a,b,c){var d=b[0],e=b.length,f=d.parentNode,h,g;if(a)for(h=0,g=a.length;h<g;h++)if(a[h]==d){a[h++]=c;g=h+e-1;for(var k=a.length;h<k;h++,g++)g<k?a[h]=a[g]:delete a[h];a.length-=e-1;break}f&&f.replaceChild(c,d);a=O.createDocumentFragment();a.appendChild(d);c[y.expando]=d[y.expando];
d=1;for(e=b.length;d<e;d++)f=b[d],y(f).remove(),a.appendChild(f),delete b[d];b[0]=c;b.length=1}function Q(a,b){return u(function(){return a.apply(null,arguments)},a,b)}var R=function(a,b){this.$$element=a;this.$attr=b||{}};R.prototype={$normalize:ka,$addClass:function(a){a&&0<a.length&&G.addClass(this.$$element,a)},$removeClass:function(a){a&&0<a.length&&G.removeClass(this.$$element,a)},$set:function(a,b,c,d){function e(a,b){var c=[],d=a.split(/\s+/),f=b.split(/\s+/),h=0;a:for(;h<d.length;h++){for(var g=
d[h],k=0;k<f.length;k++)if(g==f[k])continue a;c.push(g)}return c}if("class"==a)b=b||"",c=this.$$element.attr("class")||"",this.$removeClass(e(c,b).join(" ")),this.$addClass(e(b,c).join(" "));else{var h=bc(this.$$element[0],a);h&&(this.$$element.prop(a,b),d=h);this[a]=b;d?this.$attr[a]=d:(d=this.$attr[a])||(this.$attr[a]=d=cb(a,"-"));h=Ea(this.$$element);if("A"===h&&"href"===a||"IMG"===h&&"src"===a)if(!P||8<=P)h=xa(b).href,""!==h&&("href"===a&&!h.match(f)||"src"===a&&!h.match(g))&&(this[a]=b="unsafe:"+
h);!1!==c&&(null===b||b===s?this.$$element.removeAttr(d):this.$$element.attr(d,b))}(c=this.$$observers)&&q(c[a],function(a){try{a(b)}catch(c){n(c)}})},$observe:function(a,b){var c=this,d=c.$$observers||(c.$$observers={}),e=d[a]||(d[a]=[]);e.push(b);I.$evalAsync(function(){e.$$inter||b(c[a])});return b}};var ba=l.startSymbol(),ga=l.endSymbol(),fc="{{"==ba||"}}"==ga?za:function(a){return a.replace(/\{\{/g,ba).replace(/}}/g,ga)},Fa=/^ngAttr[A-Z]/;return v}]}function ka(b){return Pa(b.replace(fd,""))}
function gd(){var b={},a=/^(\S+)(\s+as\s+(\w+))?$/;this.register=function(a,d){na(a,"controller");T(a)?u(b,a):b[a]=d};this.$get=["$injector","$window",function(c,d){return function(e,f){var g,h,m;D(e)&&(g=e.match(a),h=g[1],m=g[3],e=b.hasOwnProperty(h)?b[h]:ub(f.$scope,h,!0)||ub(d,h,!0),Oa(e,h,!0));g=c.instantiate(e,f);if(m){if(!f||"object"!=typeof f.$scope)throw L("$controller")("noscp",h||e.name,m);f.$scope[m]=g}return g}}]}function hd(){this.$get=["$window",function(b){return y(b.document)}]}function id(){this.$get=
["$log",function(b){return function(a,c){b.error.apply(b,arguments)}}]}function gc(b){var a={},c,d,e;if(!b)return a;q(b.split("\n"),function(b){e=b.indexOf(":");c=w(Y(b.substr(0,e)));d=Y(b.substr(e+1));c&&(a[c]=a[c]?a[c]+(", "+d):d)});return a}function hc(b){var a=T(b)?b:s;return function(c){a||(a=gc(b));return c?a[w(c)]||null:a}}function ic(b,a,c){if(B(c))return c(b,a);q(c,function(c){b=c(b,a)});return b}function jd(){var b=/^\s*(\[|\{[^\{])/,a=/[\}\]]\s*$/,c=/^\)\]\}',?\n/,d={"Content-Type":"application/json;charset=utf-8"},
e=this.defaults={transformResponse:[function(d){D(d)&&(d=d.replace(c,""),b.test(d)&&a.test(d)&&(d=Sb(d)));return d}],transformRequest:[function(a){return T(a)&&"[object File]"!==Ka.apply(a)?ma(a):a}],headers:{common:{Accept:"application/json, text/plain, */*"},post:d,put:d,patch:d},xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN"},f=this.interceptors=[],g=this.responseInterceptors=[];this.$get=["$httpBackend","$browser","$cacheFactory","$rootScope","$q","$injector",function(a,b,c,d,n,r){function p(a){function c(a){var b=
u({},a,{data:ic(a.data,a.headers,d.transformResponse)});return 200<=a.status&&300>a.status?b:n.reject(b)}var d={transformRequest:e.transformRequest,transformResponse:e.transformResponse},f=function(a){function b(a){var c;q(a,function(b,d){B(b)&&(c=b(),null!=c?a[d]=c:delete a[d])})}var c=e.headers,d=u({},a.headers),f,h,c=u({},c.common,c[w(a.method)]);b(c);b(d);a:for(f in c){a=w(f);for(h in d)if(w(h)===a)continue a;d[f]=c[f]}return d}(a);u(d,a);d.headers=f;d.method=Ga(d.method);(a=Eb(d.url)?b.cookies()[d.xsrfCookieName||
e.xsrfCookieName]:s)&&(f[d.xsrfHeaderName||e.xsrfHeaderName]=a);var h=[function(a){f=a.headers;var b=ic(a.data,hc(f),a.transformRequest);x(a.data)&&q(f,function(a,b){"content-type"===w(b)&&delete f[b]});x(a.withCredentials)&&!x(e.withCredentials)&&(a.withCredentials=e.withCredentials);return C(a,b,f).then(c,c)},s],g=n.when(d);for(q(A,function(a){(a.request||a.requestError)&&h.unshift(a.request,a.requestError);(a.response||a.responseError)&&h.push(a.response,a.responseError)});h.length;){a=h.shift();
var k=h.shift(),g=g.then(a,k)}g.success=function(a){g.then(function(b){a(b.data,b.status,b.headers,d)});return g};g.error=function(a){g.then(null,function(b){a(b.data,b.status,b.headers,d)});return g};return g}function C(b,c,f){function g(a,b,c){q&&(200<=a&&300>a?q.put(s,[a,b,gc(c)]):q.remove(s));k(b,a,c);d.$$phase||d.$apply()}function k(a,c,d){c=Math.max(c,0);(200<=c&&300>c?r.resolve:r.reject)({data:a,status:c,headers:hc(d),config:b})}function m(){var a=ab(p.pendingRequests,b);-1!==a&&p.pendingRequests.splice(a,
1)}var r=n.defer(),C=r.promise,q,A,s=H(b.url,b.params);p.pendingRequests.push(b);C.then(m,m);(b.cache||e.cache)&&(!1!==b.cache&&"GET"==b.method)&&(q=T(b.cache)?b.cache:T(e.cache)?e.cache:I);if(q)if(A=q.get(s),z(A)){if(A.then)return A.then(m,m),A;J(A)?k(A[1],A[0],da(A[2])):k(A,200,{})}else q.put(s,C);x(A)&&a(b.method,s,c,g,f,b.timeout,b.withCredentials,b.responseType);return C}function H(a,b){if(!b)return a;var c=[];Jc(b,function(a,b){null===a||x(a)||(J(a)||(a=[a]),q(a,function(a){T(a)&&(a=ma(a));
c.push(ua(b)+"="+ua(a))}))});return a+(-1==a.indexOf("?")?"?":"&")+c.join("&")}var I=c("$http"),A=[];q(f,function(a){A.unshift(D(a)?r.get(a):r.invoke(a))});q(g,function(a,b){var c=D(a)?r.get(a):r.invoke(a);A.splice(b,0,{response:function(a){return c(n.when(a))},responseError:function(a){return c(n.reject(a))}})});p.pendingRequests=[];(function(a){q(arguments,function(a){p[a]=function(b,c){return p(u(c||{},{method:a,url:b}))}})})("get","delete","head","jsonp");(function(a){q(arguments,function(a){p[a]=
function(b,c,d){return p(u(d||{},{method:a,url:b,data:c}))}})})("post","put");p.defaults=e;return p}]}function kd(){this.$get=["$browser","$window","$document",function(b,a,c){return ld(b,md,b.defer,a.angular.callbacks,c[0],a.location.protocol.replace(":",""))}]}function ld(b,a,c,d,e,f){function g(a,b){var c=e.createElement("script"),d=function(){e.body.removeChild(c);b&&b()};c.type="text/javascript";c.src=a;P?c.onreadystatechange=function(){/loaded|complete/.test(c.readyState)&&d()}:c.onload=c.onerror=
d;e.body.appendChild(c);return d}return function(e,m,k,l,n,r,p,C){function H(){A=-1;G&&G();v&&v.abort()}function I(a,d,e,h){var g=f||xa(m).protocol;Z&&c.cancel(Z);G=v=null;d="file"==g?e?200:404:d;a(1223==d?204:d,e,h);b.$$completeOutstandingRequest(t)}var A;b.$$incOutstandingRequestCount();m=m||b.url();if("jsonp"==w(e)){var s="_"+(d.counter++).toString(36);d[s]=function(a){d[s].data=a};var G=g(m.replace("JSON_CALLBACK","angular.callbacks."+s),function(){d[s].data?I(l,200,d[s].data):I(l,A||-2);delete d[s]})}else{var v=
new a;v.open(e,m,!0);q(n,function(a,b){z(a)&&v.setRequestHeader(b,a)});v.onreadystatechange=function(){if(4==v.readyState){var a=v.getAllResponseHeaders();I(l,A||v.status,v.responseType?v.response:v.responseText,a)}};p&&(v.withCredentials=!0);C&&(v.responseType=C);v.send(k||null)}if(0<r)var Z=c(H,r);else r&&r.then&&r.then(H)}}function nd(){var b="{{",a="}}";this.startSymbol=function(a){return a?(b=a,this):b};this.endSymbol=function(b){return b?(a=b,this):a};this.$get=["$parse","$exceptionHandler",
"$sce",function(c,d,e){function f(f,k,l){for(var n,r,p=0,C=[],H=f.length,q=!1,A=[];p<H;)-1!=(n=f.indexOf(b,p))&&-1!=(r=f.indexOf(a,n+g))?(p!=n&&C.push(f.substring(p,n)),C.push(p=c(q=f.substring(n+g,r))),p.exp=q,p=r+h,q=!0):(p!=H&&C.push(f.substring(p)),p=H);(H=C.length)||(C.push(""),H=1);if(l&&1<C.length)throw jc("noconcat",f);if(!k||q)return A.length=H,p=function(a){try{for(var b=0,c=H,h;b<c;b++)"function"==typeof(h=C[b])&&(h=h(a),h=l?e.getTrusted(l,h):e.valueOf(h),null===h||x(h)?h="":"string"!=
typeof h&&(h=ma(h))),A[b]=h;return A.join("")}catch(g){a=jc("interr",f,g.toString()),d(a)}},p.exp=f,p.parts=C,p}var g=b.length,h=a.length;f.startSymbol=function(){return b};f.endSymbol=function(){return a};return f}]}function od(){this.$get=["$rootScope","$window","$q",function(b,a,c){function d(d,g,h,m){var k=a.setInterval,l=a.clearInterval,n=c.defer(),r=n.promise,p=0,C=z(m)&&!m;h=z(h)?h:0;r.then(null,null,d);r.$$intervalId=k(function(){n.notify(p++);0<h&&p>=h&&(n.resolve(p),l(r.$$intervalId),delete e[r.$$intervalId]);
C||b.$apply()},g);e[r.$$intervalId]=n;return r}var e={};d.cancel=function(a){return a&&a.$$intervalId in e?(e[a.$$intervalId].reject("canceled"),clearInterval(a.$$intervalId),delete e[a.$$intervalId],!0):!1};return d}]}function pd(){this.$get=function(){return{id:"en-us",NUMBER_FORMATS:{DECIMAL_SEP:".",GROUP_SEP:",",PATTERNS:[{minInt:1,minFrac:0,maxFrac:3,posPre:"",posSuf:"",negPre:"-",negSuf:"",gSize:3,lgSize:3},{minInt:1,minFrac:2,maxFrac:2,posPre:"\u00a4",posSuf:"",negPre:"(\u00a4",negSuf:")",
gSize:3,lgSize:3}],CURRENCY_SYM:"$"},DATETIME_FORMATS:{MONTH:"January February March April May June July August September October November December".split(" "),SHORTMONTH:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),DAY:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),SHORTDAY:"Sun Mon Tue Wed Thu Fri Sat".split(" "),AMPMS:["AM","PM"],medium:"MMM d, y h:mm:ss a","short":"M/d/yy h:mm a",fullDate:"EEEE, MMMM d, y",longDate:"MMMM d, y",mediumDate:"MMM d, y",shortDate:"M/d/yy",
mediumTime:"h:mm:ss a",shortTime:"h:mm a"},pluralCat:function(b){return 1===b?"one":"other"}}}}function kc(b){b=b.split("/");for(var a=b.length;a--;)b[a]=sb(b[a]);return b.join("/")}function lc(b,a){var c=xa(b);a.$$protocol=c.protocol;a.$$host=c.hostname;a.$$port=U(c.port)||qd[c.protocol]||null}function mc(b,a){var c="/"!==b.charAt(0);c&&(b="/"+b);var d=xa(b);a.$$path=decodeURIComponent(c&&"/"===d.pathname.charAt(0)?d.pathname.substring(1):d.pathname);a.$$search=Ub(d.search);a.$$hash=decodeURIComponent(d.hash);
a.$$path&&"/"!=a.$$path.charAt(0)&&(a.$$path="/"+a.$$path)}function la(b,a){if(0===a.indexOf(b))return a.substr(b.length)}function Wa(b){var a=b.indexOf("#");return-1==a?b:b.substr(0,a)}function Fb(b){return b.substr(0,Wa(b).lastIndexOf("/")+1)}function nc(b,a){this.$$html5=!0;a=a||"";var c=Fb(b);lc(b,this);this.$$parse=function(a){var b=la(c,a);if(!D(b))throw Gb("ipthprfx",a,c);mc(b,this);this.$$path||(this.$$path="/");this.$$compose()};this.$$compose=function(){var a=Vb(this.$$search),b=this.$$hash?
"#"+sb(this.$$hash):"";this.$$url=kc(this.$$path)+(a?"?"+a:"")+b;this.$$absUrl=c+this.$$url.substr(1)};this.$$rewrite=function(d){var e;if((e=la(b,d))!==s)return d=e,(e=la(a,e))!==s?c+(la("/",e)||e):b+d;if((e=la(c,d))!==s)return c+e;if(c==d+"/")return c}}function Hb(b,a){var c=Fb(b);lc(b,this);this.$$parse=function(d){var e=la(b,d)||la(c,d),e="#"==e.charAt(0)?la(a,e):this.$$html5?e:"";if(!D(e))throw Gb("ihshprfx",d,a);mc(e,this);this.$$compose()};this.$$compose=function(){var c=Vb(this.$$search),
e=this.$$hash?"#"+sb(this.$$hash):"";this.$$url=kc(this.$$path)+(c?"?"+c:"")+e;this.$$absUrl=b+(this.$$url?a+this.$$url:"")};this.$$rewrite=function(a){if(Wa(b)==Wa(a))return a}}function oc(b,a){this.$$html5=!0;Hb.apply(this,arguments);var c=Fb(b);this.$$rewrite=function(d){var e;if(b==Wa(d))return d;if(e=la(c,d))return b+a+e;if(c===d+"/")return c}}function hb(b){return function(){return this[b]}}function pc(b,a){return function(c){if(x(c))return this[b];this[b]=a(c);this.$$compose();return this}}
function rd(){var b="",a=!1;this.hashPrefix=function(a){return z(a)?(b=a,this):b};this.html5Mode=function(b){return z(b)?(a=b,this):a};this.$get=["$rootScope","$browser","$sniffer","$rootElement",function(c,d,e,f){function g(a){c.$broadcast("$locationChangeSuccess",h.absUrl(),a)}var h,m=d.baseHref(),k=d.url();a?(m=k.substring(0,k.indexOf("/",k.indexOf("//")+2))+(m||"/"),e=e.history?nc:oc):(m=Wa(k),e=Hb);h=new e(m,"#"+b);h.$$parse(h.$$rewrite(k));f.on("click",function(a){if(!a.ctrlKey&&!a.metaKey&&
2!=a.which){for(var b=y(a.target);"a"!==w(b[0].nodeName);)if(b[0]===f[0]||!(b=b.parent())[0])return;var e=b.prop("href"),g=h.$$rewrite(e);e&&(!b.attr("target")&&g&&!a.isDefaultPrevented())&&(a.preventDefault(),g!=d.url()&&(h.$$parse(g),c.$apply(),W.angular["ff-684208-preventDefault"]=!0))}});h.absUrl()!=k&&d.url(h.absUrl(),!0);d.onUrlChange(function(a){h.absUrl()!=a&&(c.$broadcast("$locationChangeStart",a,h.absUrl()).defaultPrevented?d.url(h.absUrl()):(c.$evalAsync(function(){var b=h.absUrl();h.$$parse(a);
g(b)}),c.$$phase||c.$digest()))});var l=0;c.$watch(function(){var a=d.url(),b=h.$$replace;l&&a==h.absUrl()||(l++,c.$evalAsync(function(){c.$broadcast("$locationChangeStart",h.absUrl(),a).defaultPrevented?h.$$parse(a):(d.url(h.absUrl(),b),g(a))}));h.$$replace=!1;return l});return h}]}function sd(){var b=!0,a=this;this.debugEnabled=function(a){return z(a)?(b=a,this):b};this.$get=["$window",function(c){function d(a){a instanceof Error&&(a.stack?a=a.message&&-1===a.stack.indexOf(a.message)?"Error: "+
a.message+"\n"+a.stack:a.stack:a.sourceURL&&(a=a.message+"\n"+a.sourceURL+":"+a.line));return a}function e(a){var b=c.console||{},e=b[a]||b.log||t;return e.apply?function(){var a=[];q(arguments,function(b){a.push(d(b))});return e.apply(b,a)}:function(a,b){e(a,null==b?"":b)}}return{log:e("log"),info:e("info"),warn:e("warn"),error:e("error"),debug:function(){var c=e("debug");return function(){b&&c.apply(a,arguments)}}()}}]}function ha(b,a,c){if("string"!==typeof b&&"[object String]"!==Ka.apply(b))return b;
if("constructor"===b&&!c)throw pa("isecfld",a);if("_"===b.charAt(0)||"_"===b.charAt(b.length-1))throw pa("isecprv",a);return b}function Xa(b,a){if(b&&b.constructor===b)throw pa("isecfn",a);if(b&&b.document&&b.location&&b.alert&&b.setInterval)throw pa("isecwindow",a);if(b&&(b.nodeName||b.on&&b.find))throw pa("isecdom",a);return b}function ib(b,a,c,d,e){e=e||{};a=a.split(".");for(var f,g=0;1<a.length;g++){f=ha(a.shift(),d);var h=b[f];h||(h={},b[f]=h);b=h;b.then&&e.unwrapPromises&&(qa(d),"$$v"in b||
function(a){a.then(function(b){a.$$v=b})}(b),b.$$v===s&&(b.$$v={}),b=b.$$v)}f=ha(a.shift(),d);return b[f]=c}function qc(b,a,c,d,e,f,g){ha(b,f);ha(a,f);ha(c,f);ha(d,f);ha(e,f);return g.unwrapPromises?function(h,g){var k=g&&g.hasOwnProperty(b)?g:h,l;if(null===k||k===s)return k;(k=k[b])&&k.then&&(qa(f),"$$v"in k||(l=k,l.$$v=s,l.then(function(a){l.$$v=a})),k=k.$$v);if(!a||null===k||k===s)return k;(k=k[a])&&k.then&&(qa(f),"$$v"in k||(l=k,l.$$v=s,l.then(function(a){l.$$v=a})),k=k.$$v);if(!c||null===k||
k===s)return k;(k=k[c])&&k.then&&(qa(f),"$$v"in k||(l=k,l.$$v=s,l.then(function(a){l.$$v=a})),k=k.$$v);if(!d||null===k||k===s)return k;(k=k[d])&&k.then&&(qa(f),"$$v"in k||(l=k,l.$$v=s,l.then(function(a){l.$$v=a})),k=k.$$v);if(!e||null===k||k===s)return k;(k=k[e])&&k.then&&(qa(f),"$$v"in k||(l=k,l.$$v=s,l.then(function(a){l.$$v=a})),k=k.$$v);return k}:function(f,g){var k=g&&g.hasOwnProperty(b)?g:f;if(null===k||k===s)return k;k=k[b];if(!a||null===k||k===s)return k;k=k[a];if(!c||null===k||k===s)return k;
k=k[c];if(!d||null===k||k===s)return k;k=k[d];return e&&null!==k&&k!==s?k=k[e]:k}}function rc(b,a,c){if(Ib.hasOwnProperty(b))return Ib[b];var d=b.split("."),e=d.length,f;if(a.csp)f=6>e?qc(d[0],d[1],d[2],d[3],d[4],c,a):function(b,f){var h=0,g;do g=qc(d[h++],d[h++],d[h++],d[h++],d[h++],c,a)(b,f),f=s,b=g;while(h<e);return g};else{var g="var l, fn, p;\n";q(d,function(b,d){ha(b,c);g+="if(s === null || s === undefined) return s;\nl=s;\ns="+(d?"s":'((k&&k.hasOwnProperty("'+b+'"))?k:s)')+'["'+b+'"];\n'+(a.unwrapPromises?
'if (s && s.then) {\n pw("'+c.replace(/\"/g,'\\"')+'");\n if (!("$$v" in s)) {\n p=s;\n p.$$v = undefined;\n p.then(function(v) {p.$$v=v;});\n}\n s=s.$$v\n}\n':"")});var g=g+"return s;",h=new Function("s","k","pw",g);h.toString=function(){return g};f=function(a,b){return h(a,b,qa)}}"hasOwnProperty"!==b&&(Ib[b]=f);return f}function td(){var b={},a={csp:!1,unwrapPromises:!1,logPromiseWarnings:!0};this.unwrapPromises=function(b){return z(b)?(a.unwrapPromises=!!b,this):a.unwrapPromises};this.logPromiseWarnings=
function(b){return z(b)?(a.logPromiseWarnings=b,this):a.logPromiseWarnings};this.$get=["$filter","$sniffer","$log",function(c,d,e){a.csp=d.csp;qa=function(b){a.logPromiseWarnings&&!sc.hasOwnProperty(b)&&(sc[b]=!0,e.warn("[$parse] Promise found in the expression `"+b+"`. Automatic unwrapping of promises in Angular expressions is deprecated."))};return function(d){var e;switch(typeof d){case "string":if(b.hasOwnProperty(d))return b[d];e=new Jb(a);e=(new Ya(e,c,a)).parse(d,!1);"hasOwnProperty"!==d&&
(b[d]=e);return e;case "function":return d;default:return t}}}]}function ud(){this.$get=["$rootScope","$exceptionHandler",function(b,a){return vd(function(a){b.$evalAsync(a)},a)}]}function vd(b,a){function c(a){return a}function d(a){return g(a)}var e=function(){var h=[],m,k;return k={resolve:function(a){if(h){var c=h;h=s;m=f(a);c.length&&b(function(){for(var a,b=0,d=c.length;b<d;b++)a=c[b],m.then(a[0],a[1],a[2])})}},reject:function(a){k.resolve(g(a))},notify:function(a){if(h){var c=h;h.length&&b(function(){for(var b,
d=0,e=c.length;d<e;d++)b=c[d],b[2](a)})}},promise:{then:function(b,f,g){var k=e(),C=function(d){try{k.resolve((B(b)?b:c)(d))}catch(e){k.reject(e),a(e)}},H=function(b){try{k.resolve((B(f)?f:d)(b))}catch(c){k.reject(c),a(c)}},q=function(b){try{k.notify((B(g)?g:c)(b))}catch(d){a(d)}};h?h.push([C,H,q]):m.then(C,H,q);return k.promise},"catch":function(a){return this.then(null,a)},"finally":function(a){function b(a,c){var d=e();c?d.resolve(a):d.reject(a);return d.promise}function d(e,f){var h=null;try{h=
(a||c)()}catch(g){return b(g,!1)}return h&&B(h.then)?h.then(function(){return b(e,f)},function(a){return b(a,!1)}):b(e,f)}return this.then(function(a){return d(a,!0)},function(a){return d(a,!1)})}}}},f=function(a){return a&&B(a.then)?a:{then:function(c){var d=e();b(function(){d.resolve(c(a))});return d.promise}}},g=function(c){return{then:function(f,g){var l=e();b(function(){try{l.resolve((B(g)?g:d)(c))}catch(b){l.reject(b),a(b)}});return l.promise}}};return{defer:e,reject:g,when:function(h,m,k,l){var n=
e(),r,p=function(b){try{return(B(m)?m:c)(b)}catch(d){return a(d),g(d)}},C=function(b){try{return(B(k)?k:d)(b)}catch(c){return a(c),g(c)}},q=function(b){try{return(B(l)?l:c)(b)}catch(d){a(d)}};b(function(){f(h).then(function(a){r||(r=!0,n.resolve(f(a).then(p,C,q)))},function(a){r||(r=!0,n.resolve(C(a)))},function(a){r||n.notify(q(a))})});return n.promise},all:function(a){var b=e(),c=0,d=J(a)?[]:{};q(a,function(a,e){c++;f(a).then(function(a){d.hasOwnProperty(e)||(d[e]=a,--c||b.resolve(d))},function(a){d.hasOwnProperty(e)||
b.reject(a)})});0===c&&b.resolve(d);return b.promise}}}function wd(){var b=10,a=L("$rootScope");this.digestTtl=function(a){arguments.length&&(b=a);return b};this.$get=["$injector","$exceptionHandler","$parse","$browser",function(c,d,e,f){function g(){this.$id=Za();this.$$phase=this.$parent=this.$$watchers=this.$$nextSibling=this.$$prevSibling=this.$$childHead=this.$$childTail=null;this["this"]=this.$root=this;this.$$destroyed=!1;this.$$asyncQueue=[];this.$$postDigestQueue=[];this.$$listeners={};this.$$isolateBindings=
{}}function h(b){if(l.$$phase)throw a("inprog",l.$$phase);l.$$phase=b}function m(a,b){var c=e(a);Oa(c,b);return c}function k(){}g.prototype={constructor:g,$new:function(a){a?(a=new g,a.$root=this.$root,a.$$asyncQueue=this.$$asyncQueue,a.$$postDigestQueue=this.$$postDigestQueue):(a=function(){},a.prototype=this,a=new a,a.$id=Za());a["this"]=a;a.$$listeners={};a.$parent=this;a.$$watchers=a.$$nextSibling=a.$$childHead=a.$$childTail=null;a.$$prevSibling=this.$$childTail;this.$$childHead?this.$$childTail=
this.$$childTail.$$nextSibling=a:this.$$childHead=this.$$childTail=a;return a},$watch:function(a,b,c){var d=m(a,"watch"),e=this.$$watchers,f={fn:b,last:k,get:d,exp:a,eq:!!c};if(!B(b)){var h=m(b||t,"listener");f.fn=function(a,b,c){h(c)}}if("string"==typeof a&&d.constant){var g=f.fn;f.fn=function(a,b,c){g.call(this,a,b,c);La(e,f)}}e||(e=this.$$watchers=[]);e.unshift(f);return function(){La(e,f)}},$watchCollection:function(a,b){var c=this,d,f,h=0,g=e(a),k=[],l={},m=0;return this.$watch(function(){f=
g(c);var a,b;if(T(f))if(pb(f))for(d!==k&&(d=k,m=d.length=0,h++),a=f.length,m!==a&&(h++,d.length=m=a),b=0;b<a;b++)d[b]!==f[b]&&(h++,d[b]=f[b]);else{d!==l&&(d=l={},m=0,h++);a=0;for(b in f)f.hasOwnProperty(b)&&(a++,d.hasOwnProperty(b)?d[b]!==f[b]&&(h++,d[b]=f[b]):(m++,d[b]=f[b],h++));if(m>a)for(b in h++,d)d.hasOwnProperty(b)&&!f.hasOwnProperty(b)&&(m--,delete d[b])}else d!==f&&(d=f,h++);return h},function(){b(f,d,c)})},$digest:function(){var c,e,f,g,m=this.$$asyncQueue,q=this.$$postDigestQueue,s,t,G=
b,v,y=[],E,z,$;h("$digest");do{t=!1;for(v=this;m.length;)try{$=m.shift(),$.scope.$eval($.expression)}catch(x){d(x)}do{if(g=v.$$watchers)for(s=g.length;s--;)try{(c=g[s])&&((e=c.get(v))!==(f=c.last)&&!(c.eq?Aa(e,f):"number"==typeof e&&"number"==typeof f&&isNaN(e)&&isNaN(f)))&&(t=!0,c.last=c.eq?da(e):e,c.fn(e,f===k?e:f,v),5>G&&(E=4-G,y[E]||(y[E]=[]),z=B(c.exp)?"fn: "+(c.exp.name||c.exp.toString()):c.exp,z+="; newVal: "+ma(e)+"; oldVal: "+ma(f),y[E].push(z)))}catch(M){d(M)}if(!(g=v.$$childHead||v!==this&&
v.$$nextSibling))for(;v!==this&&!(g=v.$$nextSibling);)v=v.$parent}while(v=g);if(t&&!G--)throw l.$$phase=null,a("infdig",b,ma(y));}while(t||m.length);for(l.$$phase=null;q.length;)try{q.shift()()}catch(w){d(w)}},$destroy:function(){if(l!=this&&!this.$$destroyed){var a=this.$parent;this.$broadcast("$destroy");this.$$destroyed=!0;a.$$childHead==this&&(a.$$childHead=this.$$nextSibling);a.$$childTail==this&&(a.$$childTail=this.$$prevSibling);this.$$prevSibling&&(this.$$prevSibling.$$nextSibling=this.$$nextSibling);
this.$$nextSibling&&(this.$$nextSibling.$$prevSibling=this.$$prevSibling);this.$parent=this.$$nextSibling=this.$$prevSibling=this.$$childHead=this.$$childTail=null}},$eval:function(a,b){return e(a)(this,b)},$evalAsync:function(a){l.$$phase||l.$$asyncQueue.length||f.defer(function(){l.$$asyncQueue.length&&l.$digest()});this.$$asyncQueue.push({scope:this,expression:a})},$$postDigest:function(a){this.$$postDigestQueue.push(a)},$apply:function(a){try{return h("$apply"),this.$eval(a)}catch(b){d(b)}finally{l.$$phase=
null;try{l.$digest()}catch(c){throw d(c),c;}}},$on:function(a,b){var c=this.$$listeners[a];c||(this.$$listeners[a]=c=[]);c.push(b);return function(){c[ab(c,b)]=null}},$emit:function(a,b){var c=[],e,f=this,h=!1,g={name:a,targetScope:f,stopPropagation:function(){h=!0},preventDefault:function(){g.defaultPrevented=!0},defaultPrevented:!1},k=[g].concat(ta.call(arguments,1)),l,m;do{e=f.$$listeners[a]||c;g.currentScope=f;l=0;for(m=e.length;l<m;l++)if(e[l])try{e[l].apply(null,k)}catch(q){d(q)}else e.splice(l,
1),l--,m--;if(h)break;f=f.$parent}while(f);return g},$broadcast:function(a,b){var c=this,e=this,f={name:a,targetScope:this,preventDefault:function(){f.defaultPrevented=!0},defaultPrevented:!1},h=[f].concat(ta.call(arguments,1)),g,k;do{c=e;f.currentScope=c;e=c.$$listeners[a]||[];g=0;for(k=e.length;g<k;g++)if(e[g])try{e[g].apply(null,h)}catch(l){d(l)}else e.splice(g,1),g--,k--;if(!(e=c.$$childHead||c!==this&&c.$$nextSibling))for(;c!==this&&!(e=c.$$nextSibling);)c=c.$parent}while(c=e);return f}};var l=
new g;return l}]}function xd(b){if("self"===b)return b;if(D(b)){if(-1<b.indexOf("***"))throw ra("iwcard",b);b=b.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08").replace("\\*\\*",".*").replace("\\*","[^:/.?&;]*");return RegExp("^"+b+"$")}if($a(b))return RegExp("^"+b.source+"$");throw ra("imatcher");}function tc(b){var a=[];z(b)&&q(b,function(b){a.push(xd(b))});return a}function yd(){this.SCE_CONTEXTS=ca;var b=["self"],a=[];this.resourceUrlWhitelist=function(a){arguments.length&&
(b=tc(a));return b};this.resourceUrlBlacklist=function(b){arguments.length&&(a=tc(b));return a};this.$get=["$log","$document","$injector",function(c,d,e){function f(a){var b=function(a){this.$$unwrapTrustedValue=function(){return a}};a&&(b.prototype=new a);b.prototype.valueOf=function(){return this.$$unwrapTrustedValue()};b.prototype.toString=function(){return this.$$unwrapTrustedValue().toString()};return b}var g=function(a){throw ra("unsafe");};e.has("$sanitize")&&(g=e.get("$sanitize"));var h=f(),
m={};m[ca.HTML]=f(h);m[ca.CSS]=f(h);m[ca.URL]=f(h);m[ca.JS]=f(h);m[ca.RESOURCE_URL]=f(m[ca.URL]);return{trustAs:function(a,b){var c=m.hasOwnProperty(a)?m[a]:null;if(!c)throw ra("icontext",a,b);if(null===b||b===s||""===b)return b;if("string"!==typeof b)throw ra("itype",a);return new c(b)},getTrusted:function(c,d){if(null===d||d===s||""===d)return d;var e=m.hasOwnProperty(c)?m[c]:null;if(e&&d instanceof e)return d.$$unwrapTrustedValue();if(c===ca.RESOURCE_URL){var e=xa(d.toString()),f,h,q=!1;f=0;for(h=
b.length;f<h;f++)if("self"===b[f]?Eb(e):b[f].exec(e.href)){q=!0;break}if(q)for(f=0,h=a.length;f<h;f++)if("self"===a[f]?Eb(e):a[f].exec(e.href)){q=!1;break}if(q)return d;throw ra("insecurl",d.toString());}if(c===ca.HTML)return g(d);throw ra("unsafe");},valueOf:function(a){return a instanceof h?a.$$unwrapTrustedValue():a}}}]}function zd(){var b=!0;this.enabled=function(a){arguments.length&&(b=!!a);return b};this.$get=["$parse","$document","$sceDelegate",function(a,c,d){if(b&&P&&(c=c[0].documentMode,
c!==s&&8>c))throw ra("iequirks");var e=da(ca);e.isEnabled=function(){return b};e.trustAs=d.trustAs;e.getTrusted=d.getTrusted;e.valueOf=d.valueOf;b||(e.trustAs=e.getTrusted=function(a,b){return b},e.valueOf=za);e.parseAs=function(b,c){var d=a(c);return d.literal&&d.constant?d:function(a,c){return e.getTrusted(b,d(a,c))}};var f=e.parseAs,g=e.getTrusted,h=e.trustAs;q(ca,function(a,b){var c=w(b);e[Pa("parse_as_"+c)]=function(b){return f(a,b)};e[Pa("get_trusted_"+c)]=function(b){return g(a,b)};e[Pa("trust_as_"+
c)]=function(b){return h(a,b)}});return e}]}function Ad(){this.$get=["$window","$document",function(b,a){var c={},d=U((/android (\d+)/.exec(w((b.navigator||{}).userAgent))||[])[1]),e=/Boxee/i.test((b.navigator||{}).userAgent),f=a[0]||{},g,h=/^(Moz|webkit|O|ms)(?=[A-Z])/,m=f.body&&f.body.style,k=!1,l=!1;if(m){for(var n in m)if(k=h.exec(n)){g=k[0];g=g.substr(0,1).toUpperCase()+g.substr(1);break}g||(g="WebkitOpacity"in m&&"webkit");k=!!("transition"in m||g+"Transition"in m);l=!!("animation"in m||g+"Animation"in
m);!d||k&&l||(k=D(f.body.style.webkitTransition),l=D(f.body.style.webkitAnimation))}return{history:!(!b.history||!b.history.pushState||4>d||e),hashchange:"onhashchange"in b&&(!f.documentMode||7<f.documentMode),hasEvent:function(a){if("input"==a&&9==P)return!1;if(x(c[a])){var b=f.createElement("div");c[a]="on"+a in b}return c[a]},csp:Rb(),vendorPrefix:g,transitions:k,animations:l,msie:P}}]}function Bd(){this.$get=["$rootScope","$browser","$q","$exceptionHandler",function(b,a,c,d){function e(e,h,m){var k=
c.defer(),l=k.promise,n=z(m)&&!m;h=a.defer(function(){try{k.resolve(e())}catch(a){k.reject(a),d(a)}finally{delete f[l.$$timeoutId]}n||b.$apply()},h);l.$$timeoutId=h;f[h]=k;return l}var f={};e.cancel=function(b){return b&&b.$$timeoutId in f?(f[b.$$timeoutId].reject("canceled"),delete f[b.$$timeoutId],a.defer.cancel(b.$$timeoutId)):!1};return e}]}function xa(b){P&&(R.setAttribute("href",b),b=R.href);R.setAttribute("href",b);return{href:R.href,protocol:R.protocol?R.protocol.replace(/:$/,""):"",host:R.host,
search:R.search?R.search.replace(/^\?/,""):"",hash:R.hash?R.hash.replace(/^#/,""):"",hostname:R.hostname,port:R.port,pathname:R.pathname&&"/"===R.pathname.charAt(0)?R.pathname:"/"+R.pathname}}function Eb(b){b=D(b)?xa(b):b;return b.protocol===uc.protocol&&b.host===uc.host}function Cd(){this.$get=aa(W)}function vc(b){function a(d,e){if(T(d)){var f={};q(d,function(b,c){f[c]=a(c,b)});return f}return b.factory(d+c,e)}var c="Filter";this.register=a;this.$get=["$injector",function(a){return function(b){return a.get(b+
c)}}];a("currency",wc);a("date",xc);a("filter",Dd);a("json",Ed);a("limitTo",Fd);a("lowercase",Gd);a("number",yc);a("orderBy",zc);a("uppercase",Hd)}function Dd(){return function(b,a,c){if(!J(b))return b;var d=typeof c,e=[];e.check=function(a){for(var b=0;b<e.length;b++)if(!e[b](a))return!1;return!0};"function"!==d&&(c="boolean"===d&&c?function(a,b){return bb.equals(a,b)}:function(a,b){b=(""+b).toLowerCase();return-1<(""+a).toLowerCase().indexOf(b)});var f=function(a,b){if("string"==typeof b&&"!"===
b.charAt(0))return!f(a,b.substr(1));switch(typeof a){case "boolean":case "number":case "string":return c(a,b);case "object":switch(typeof b){case "object":return c(a,b);default:for(var d in a)if("$"!==d.charAt(0)&&f(a[d],b))return!0}return!1;case "array":for(d=0;d<a.length;d++)if(f(a[d],b))return!0;return!1;default:return!1}};switch(typeof a){case "boolean":case "number":case "string":a={$:a};case "object":for(var g in a)"$"==g?function(){if(a[g]){var b=g;e.push(function(c){return f(c,a[b])})}}():
function(){if("undefined"!=typeof a[g]){var b=g;e.push(function(c){return f(ub(c,b),a[b])})}}();break;case "function":e.push(a);break;default:return b}for(var d=[],h=0;h<b.length;h++){var m=b[h];e.check(m)&&d.push(m)}return d}}function wc(b){var a=b.NUMBER_FORMATS;return function(b,d){x(d)&&(d=a.CURRENCY_SYM);return Ac(b,a.PATTERNS[1],a.GROUP_SEP,a.DECIMAL_SEP,2).replace(/\u00A4/g,d)}}function yc(b){var a=b.NUMBER_FORMATS;return function(b,d){return Ac(b,a.PATTERNS[0],a.GROUP_SEP,a.DECIMAL_SEP,d)}}
function Ac(b,a,c,d,e){if(isNaN(b)||!isFinite(b))return"";var f=0>b;b=Math.abs(b);var g=b+"",h="",m=[],k=!1;if(-1!==g.indexOf("e")){var l=g.match(/([\d\.]+)e(-?)(\d+)/);l&&"-"==l[2]&&l[3]>e+1?g="0":(h=g,k=!0)}if(k)0<e&&(-1<b&&1>b)&&(h=b.toFixed(e));else{g=(g.split(Bc)[1]||"").length;x(e)&&(e=Math.min(Math.max(a.minFrac,g),a.maxFrac));g=Math.pow(10,e);b=Math.round(b*g)/g;b=(""+b).split(Bc);g=b[0];b=b[1]||"";var l=0,n=a.lgSize,r=a.gSize;if(g.length>=n+r)for(l=g.length-n,k=0;k<l;k++)0===(l-k)%r&&0!==
k&&(h+=c),h+=g.charAt(k);for(k=l;k<g.length;k++)0===(g.length-k)%n&&0!==k&&(h+=c),h+=g.charAt(k);for(;b.length<e;)b+="0";e&&"0"!==e&&(h+=d+b.substr(0,e))}m.push(f?a.negPre:a.posPre);m.push(h);m.push(f?a.negSuf:a.posSuf);return m.join("")}function Kb(b,a,c){var d="";0>b&&(d="-",b=-b);for(b=""+b;b.length<a;)b="0"+b;c&&(b=b.substr(b.length-a));return d+b}function V(b,a,c,d){c=c||0;return function(e){e=e["get"+b]();if(0<c||e>-c)e+=c;0===e&&-12==c&&(e=12);return Kb(e,a,d)}}function jb(b,a){return function(c,
d){var e=c["get"+b](),f=Ga(a?"SHORT"+b:b);return d[f][e]}}function xc(b){function a(a){var b;if(b=a.match(c)){a=new Date(0);var f=0,g=0,h=b[8]?a.setUTCFullYear:a.setFullYear,m=b[8]?a.setUTCHours:a.setHours;b[9]&&(f=U(b[9]+b[10]),g=U(b[9]+b[11]));h.call(a,U(b[1]),U(b[2])-1,U(b[3]));f=U(b[4]||0)-f;g=U(b[5]||0)-g;h=U(b[6]||0);b=Math.round(1E3*parseFloat("0."+(b[7]||0)));m.call(a,f,g,h,b)}return a}var c=/^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
return function(c,e){var f="",g=[],h,m;e=e||"mediumDate";e=b.DATETIME_FORMATS[e]||e;D(c)&&(c=Id.test(c)?U(c):a(c));qb(c)&&(c=new Date(c));if(!Ja(c))return c;for(;e;)(m=Jd.exec(e))?(g=g.concat(ta.call(m,1)),e=g.pop()):(g.push(e),e=null);q(g,function(a){h=Kd[a];f+=h?h(c,b.DATETIME_FORMATS):a.replace(/(^'|'$)/g,"").replace(/''/g,"'")});return f}}function Ed(){return function(b){return ma(b,!0)}}function Fd(){return function(b,a){if(!J(b)&&!D(b))return b;a=U(a);if(D(b))return a?0<=a?b.slice(0,a):b.slice(a,
b.length):"";var c=[],d,e;a>b.length?a=b.length:a<-b.length&&(a=-b.length);0<a?(d=0,e=a):(d=b.length+a,e=b.length);for(;d<e;d++)c.push(b[d]);return c}}function zc(b){return function(a,c,d){function e(a,b){return Na(b)?function(b,c){return a(c,b)}:a}if(!J(a)||!c)return a;c=J(c)?c:[c];c=Lc(c,function(a){var c=!1,d=a||za;if(D(a)){if("+"==a.charAt(0)||"-"==a.charAt(0))c="-"==a.charAt(0),a=a.substring(1);d=b(a)}return e(function(a,b){var c;c=d(a);var e=d(b),f=typeof c,g=typeof e;f==g?("string"==f&&(c=
c.toLowerCase(),e=e.toLowerCase()),c=c===e?0:c<e?-1:1):c=f<g?-1:1;return c},c)});for(var f=[],g=0;g<a.length;g++)f.push(a[g]);return f.sort(e(function(a,b){for(var d=0;d<c.length;d++){var e=c[d](a,b);if(0!==e)return e}return 0},d))}}function sa(b){B(b)&&(b={link:b});b.restrict=b.restrict||"AC";return aa(b)}function Cc(b,a){function c(a,c){c=c?"-"+cb(c,"-"):"";b.removeClass((a?kb:lb)+c).addClass((a?lb:kb)+c)}var d=this,e=b.parent().controller("form")||mb,f=0,g=d.$error={},h=[];d.$name=a.name||a.ngForm;
d.$dirty=!1;d.$pristine=!0;d.$valid=!0;d.$invalid=!1;e.$addControl(d);b.addClass(Ha);c(!0);d.$addControl=function(a){na(a.$name,"input");h.push(a);a.$name&&(d[a.$name]=a)};d.$removeControl=function(a){a.$name&&d[a.$name]===a&&delete d[a.$name];q(g,function(b,c){d.$setValidity(c,!0,a)});La(h,a)};d.$setValidity=function(a,b,h){var n=g[a];if(b)n&&(La(n,h),n.length||(f--,f||(c(b),d.$valid=!0,d.$invalid=!1),g[a]=!1,c(!0,a),e.$setValidity(a,!0,d)));else{f||c(b);if(n){if(-1!=ab(n,h))return}else g[a]=n=[],
f++,c(!1,a),e.$setValidity(a,!1,d);n.push(h);d.$valid=!1;d.$invalid=!0}};d.$setDirty=function(){b.removeClass(Ha).addClass(nb);d.$dirty=!0;d.$pristine=!1;e.$setDirty()};d.$setPristine=function(){b.removeClass(nb).addClass(Ha);d.$dirty=!1;d.$pristine=!0;q(h,function(a){a.$setPristine()})}}function ob(b,a,c,d,e,f){var g=function(){var e=a.val();Na(c.ngTrim||"T")&&(e=Y(e));d.$viewValue!==e&&b.$apply(function(){d.$setViewValue(e)})};if(e.hasEvent("input"))a.on("input",g);else{var h,m=function(){h||(h=
f.defer(function(){g();h=null}))};a.on("keydown",function(a){a=a.keyCode;91===a||(15<a&&19>a||37<=a&&40>=a)||m()});a.on("change",g);if(e.hasEvent("paste"))a.on("paste cut",m)}d.$render=function(){a.val(d.$isEmpty(d.$viewValue)?"":d.$viewValue)};var k=c.ngPattern,l=function(a,b){if(d.$isEmpty(b)||a.test(b))return d.$setValidity("pattern",!0),b;d.$setValidity("pattern",!1);return s};k&&((e=k.match(/^\/(.*)\/([gim]*)$/))?(k=RegExp(e[1],e[2]),e=function(a){return l(k,a)}):e=function(c){var d=b.$eval(k);
if(!d||!d.test)throw L("ngPattern")("noregexp",k,d,ea(a));return l(d,c)},d.$formatters.push(e),d.$parsers.push(e));if(c.ngMinlength){var n=U(c.ngMinlength);e=function(a){if(!d.$isEmpty(a)&&a.length<n)return d.$setValidity("minlength",!1),s;d.$setValidity("minlength",!0);return a};d.$parsers.push(e);d.$formatters.push(e)}if(c.ngMaxlength){var r=U(c.ngMaxlength);e=function(a){if(!d.$isEmpty(a)&&a.length>r)return d.$setValidity("maxlength",!1),s;d.$setValidity("maxlength",!0);return a};d.$parsers.push(e);
d.$formatters.push(e)}}function Lb(b,a){b="ngClass"+b;return function(){return{restrict:"AC",link:function(c,d,e){function f(b){if(!0===a||c.$index%2===a)h&&!Aa(b,h)&&e.$removeClass(g(h)),e.$addClass(g(b));h=da(b)}function g(a){if(J(a))return a.join(" ");if(T(a)){var b=[];q(a,function(a,c){a&&b.push(c)});return b.join(" ")}return a}var h;c.$watch(e[b],f,!0);e.$observe("class",function(a){f(c.$eval(e[b]))});"ngClass"!==b&&c.$watch("$index",function(d,f){var h=d&1;h!==f&1&&(h===a?(h=c.$eval(e[b]),e.$addClass(g(h))):
(h=c.$eval(e[b]),e.$removeClass(g(h))))})}}}}var w=function(b){return D(b)?b.toLowerCase():b},Ga=function(b){return D(b)?b.toUpperCase():b},P,y,Ba,ta=[].slice,Ld=[].push,Ka=Object.prototype.toString,Ma=L("ng"),bb=W.angular||(W.angular={}),Ua,Ea,ia=["0","0","0"];P=U((/msie (\d+)/.exec(w(navigator.userAgent))||[])[1]);isNaN(P)&&(P=U((/trident\/.*; rv:(\d+)/.exec(w(navigator.userAgent))||[])[1]));t.$inject=[];za.$inject=[];var Y=function(){return String.prototype.trim?function(b){return D(b)?b.trim():
b}:function(b){return D(b)?b.replace(/^\s*/,"").replace(/\s*$/,""):b}}();Ea=9>P?function(b){b=b.nodeName?b:b[0];return b.scopeName&&"HTML"!=b.scopeName?Ga(b.scopeName+":"+b.nodeName):b.nodeName}:function(b){return b.nodeName?b.nodeName:b[0].nodeName};var Pc=/[A-Z]/g,Md={full:"1.2.0",major:1,minor:"NG_VERSION_MINOR",dot:0,codeName:"timely-delivery"},Ra=Q.cache={},db=Q.expando="ng-"+(new Date).getTime(),Tc=1,Dc=W.document.addEventListener?function(b,a,c){b.addEventListener(a,c,!1)}:function(b,a,c){b.attachEvent("on"+
a,c)},Ab=W.document.removeEventListener?function(b,a,c){b.removeEventListener(a,c,!1)}:function(b,a,c){b.detachEvent("on"+a,c)},Rc=/([\:\-\_]+(.))/g,Sc=/^moz([A-Z])/,xb=L("jqLite"),Da=Q.prototype={ready:function(b){function a(){c||(c=!0,b())}var c=!1;"complete"===O.readyState?setTimeout(a):(this.on("DOMContentLoaded",a),Q(W).on("load",a))},toString:function(){var b=[];q(this,function(a){b.push(""+a)});return"["+b.join(", ")+"]"},eq:function(b){return 0<=b?y(this[b]):y(this[this.length+b])},length:0,
push:Ld,sort:[].sort,splice:[].splice},fb={};q("multiple selected checked disabled readOnly required open".split(" "),function(b){fb[w(b)]=b});var cc={};q("input select option textarea button form details".split(" "),function(b){cc[Ga(b)]=!0});q({data:$b,inheritedData:eb,scope:function(b){return y(b).data("$scope")||eb(b.parentNode||b,["$isolateScope","$scope"])},isolateScope:function(b){return y(b).data("$isolateScope")||y(b).data("$isolateScopeNoTemplate")},controller:ac,injector:function(b){return eb(b,
"$injector")},removeAttr:function(b,a){b.removeAttribute(a)},hasClass:Bb,css:function(b,a,c){a=Pa(a);if(z(c))b.style[a]=c;else{var d;8>=P&&(d=b.currentStyle&&b.currentStyle[a],""===d&&(d="auto"));d=d||b.style[a];8>=P&&(d=""===d?s:d);return d}},attr:function(b,a,c){var d=w(a);if(fb[d])if(z(c))c?(b[a]=!0,b.setAttribute(a,d)):(b[a]=!1,b.removeAttribute(d));else return b[a]||(b.attributes.getNamedItem(a)||t).specified?d:s;else if(z(c))b.setAttribute(a,c);else if(b.getAttribute)return b=b.getAttribute(a,
2),null===b?s:b},prop:function(b,a,c){if(z(c))b[a]=c;else return b[a]},text:function(){function b(b,d){var e=a[b.nodeType];if(x(d))return e?b[e]:"";b[e]=d}var a=[];9>P?(a[1]="innerText",a[3]="nodeValue"):a[1]=a[3]="textContent";b.$dv="";return b}(),val:function(b,a){if(x(a)){if("SELECT"===Ea(b)&&b.multiple){var c=[];q(b.options,function(a){a.selected&&c.push(a.value||a.text)});return 0===c.length?null:c}return b.value}b.value=a},html:function(b,a){if(x(a))return b.innerHTML;for(var c=0,d=b.childNodes;c<
d.length;c++)Qa(d[c]);b.innerHTML=a}},function(b,a){Q.prototype[a]=function(a,d){var e,f;if((2==b.length&&b!==Bb&&b!==ac?a:d)===s){if(T(a)){for(e=0;e<this.length;e++)if(b===$b)b(this[e],a);else for(f in a)b(this[e],f,a[f]);return this}e=b.$dv;f=e===s?Math.min(this.length,1):this.length;for(var g=0;g<f;g++){var h=b(this[g],a,d);e=e?e+h:h}return e}for(e=0;e<this.length;e++)b(this[e],a,d);return this}});q({removeData:Yb,dealoc:Qa,on:function a(c,d,e,f){if(z(f))throw xb("onargs");var g=ja(c,"events"),
h=ja(c,"handle");g||ja(c,"events",g={});h||ja(c,"handle",h=Uc(c,g));q(d.split(" "),function(d){var f=g[d];if(!f){if("mouseenter"==d||"mouseleave"==d){var l=O.body.contains||O.body.compareDocumentPosition?function(a,c){var d=9===a.nodeType?a.documentElement:a,e=c&&c.parentNode;return a===e||!!(e&&1===e.nodeType&&(d.contains?d.contains(e):a.compareDocumentPosition&&a.compareDocumentPosition(e)&16))}:function(a,c){if(c)for(;c=c.parentNode;)if(c===a)return!0;return!1};g[d]=[];a(c,{mouseleave:"mouseout",
mouseenter:"mouseover"}[d],function(a){var c=a.relatedTarget;c&&(c===this||l(this,c))||h(a,d)})}else Dc(c,d,h),g[d]=[];f=g[d]}f.push(e)})},off:Zb,replaceWith:function(a,c){var d,e=a.parentNode;Qa(a);q(new Q(c),function(c){d?e.insertBefore(c,d.nextSibling):e.replaceChild(c,a);d=c})},children:function(a){var c=[];q(a.childNodes,function(a){1===a.nodeType&&c.push(a)});return c},contents:function(a){return a.childNodes||[]},append:function(a,c){q(new Q(c),function(c){1!==a.nodeType&&11!==a.nodeType||
a.appendChild(c)})},prepend:function(a,c){if(1===a.nodeType){var d=a.firstChild;q(new Q(c),function(c){a.insertBefore(c,d)})}},wrap:function(a,c){c=y(c)[0];var d=a.parentNode;d&&d.replaceChild(c,a);c.appendChild(a)},remove:function(a){Qa(a);var c=a.parentNode;c&&c.removeChild(a)},after:function(a,c){var d=a,e=a.parentNode;q(new Q(c),function(a){e.insertBefore(a,d.nextSibling);d=a})},addClass:Db,removeClass:Cb,toggleClass:function(a,c,d){x(d)&&(d=!Bb(a,c));(d?Db:Cb)(a,c)},parent:function(a){return(a=
a.parentNode)&&11!==a.nodeType?a:null},next:function(a){if(a.nextElementSibling)return a.nextElementSibling;for(a=a.nextSibling;null!=a&&1!==a.nodeType;)a=a.nextSibling;return a},find:function(a,c){return a.getElementsByTagName(c)},clone:zb,triggerHandler:function(a,c,d){c=(ja(a,"events")||{})[c];d=d||[];var e=[{preventDefault:t,stopPropagation:t}];q(c,function(c){c.apply(a,e.concat(d))})}},function(a,c){Q.prototype[c]=function(c,e,f){for(var g,h=0;h<this.length;h++)x(g)?(g=a(this[h],c,e,f),z(g)&&
(g=y(g))):yb(g,a(this[h],c,e,f));return z(g)?g:this};Q.prototype.bind=Q.prototype.on;Q.prototype.unbind=Q.prototype.off});Sa.prototype={put:function(a,c){this[Ca(a)]=c},get:function(a){return this[Ca(a)]},remove:function(a){var c=this[a=Ca(a)];delete this[a];return c}};var Wc=/^function\s*[^\(]*\(\s*([^\)]*)\)/m,Xc=/,/,Yc=/^\s*(_?)(\S+?)\1\s*$/,Vc=/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg,Ta=L("$injector"),Nd=L("$animate"),Od=["$provide",function(a){this.$$selectors={};this.register=function(c,d){var e=
c+"-animation";if(c&&"."!=c.charAt(0))throw Nd("notcsel",c);this.$$selectors[c.substr(1)]=e;a.factory(e,d)};this.$get=["$timeout",function(a){return{enter:function(d,e,f,g){f=f&&f[f.length-1];var h=e&&e[0]||f&&f.parentNode,m=f&&f.nextSibling||null;q(d,function(a){h.insertBefore(a,m)});g&&a(g,0,!1)},leave:function(d,e){d.remove();e&&a(e,0,!1)},move:function(a,c,f,g){this.enter(a,c,f,g)},addClass:function(d,e,f){e=D(e)?e:J(e)?e.join(" "):"";q(d,function(a){Db(a,e)});f&&a(f,0,!1)},removeClass:function(d,
e,f){e=D(e)?e:J(e)?e.join(" "):"";q(d,function(a){Cb(a,e)});f&&a(f,0,!1)},enabled:t}}]}],fa=L("$compile");ec.$inject=["$provide"];var fd=/^(x[\:\-_]|data[\:\-_])/i,md=W.XMLHttpRequest||function(){try{return new ActiveXObject("Msxml2.XMLHTTP.6.0")}catch(a){}try{return new ActiveXObject("Msxml2.XMLHTTP.3.0")}catch(c){}try{return new ActiveXObject("Msxml2.XMLHTTP")}catch(d){}throw L("$httpBackend")("noxhr");},jc=L("$interpolate"),Pd=/^([^\?#]*)(\?([^#]*))?(#(.*))?$/,qd={http:80,https:443,ftp:21},Gb=
L("$location");oc.prototype=Hb.prototype=nc.prototype={$$html5:!1,$$replace:!1,absUrl:hb("$$absUrl"),url:function(a,c){if(x(a))return this.$$url;var d=Pd.exec(a);d[1]&&this.path(decodeURIComponent(d[1]));(d[2]||d[1])&&this.search(d[3]||"");this.hash(d[5]||"",c);return this},protocol:hb("$$protocol"),host:hb("$$host"),port:hb("$$port"),path:pc("$$path",function(a){return"/"==a.charAt(0)?a:"/"+a}),search:function(a,c){switch(arguments.length){case 0:return this.$$search;case 1:if(D(a))this.$$search=
Ub(a);else if(T(a))this.$$search=a;else throw Gb("isrcharg");break;default:x(c)||null===c?delete this.$$search[a]:this.$$search[a]=c}this.$$compose();return this},hash:pc("$$hash",za),replace:function(){this.$$replace=!0;return this}};var pa=L("$parse"),sc={},qa,Ia={"null":function(){return null},"true":function(){return!0},"false":function(){return!1},undefined:t,"+":function(a,c,d,e){d=d(a,c);e=e(a,c);return z(d)?z(e)?d+e:d:z(e)?e:s},"-":function(a,c,d,e){d=d(a,c);e=e(a,c);return(z(d)?d:0)-(z(e)?
e:0)},"*":function(a,c,d,e){return d(a,c)*e(a,c)},"/":function(a,c,d,e){return d(a,c)/e(a,c)},"%":function(a,c,d,e){return d(a,c)%e(a,c)},"^":function(a,c,d,e){return d(a,c)^e(a,c)},"=":t,"===":function(a,c,d,e){return d(a,c)===e(a,c)},"!==":function(a,c,d,e){return d(a,c)!==e(a,c)},"==":function(a,c,d,e){return d(a,c)==e(a,c)},"!=":function(a,c,d,e){return d(a,c)!=e(a,c)},"<":function(a,c,d,e){return d(a,c)<e(a,c)},">":function(a,c,d,e){return d(a,c)>e(a,c)},"<=":function(a,c,d,e){return d(a,c)<=
e(a,c)},">=":function(a,c,d,e){return d(a,c)>=e(a,c)},"&&":function(a,c,d,e){return d(a,c)&&e(a,c)},"||":function(a,c,d,e){return d(a,c)||e(a,c)},"&":function(a,c,d,e){return d(a,c)&e(a,c)},"|":function(a,c,d,e){return e(a,c)(a,c,d(a,c))},"!":function(a,c,d){return!d(a,c)}},Qd={n:"\n",f:"\f",r:"\r",t:"\t",v:"\v","'":"'",'"':'"'},Jb=function(a){this.options=a};Jb.prototype={constructor:Jb,lex:function(a){this.text=a;this.index=0;this.ch=s;this.lastCh=":";this.tokens=[];var c;for(a=[];this.index<this.text.length;){this.ch=
this.text.charAt(this.index);if(this.is("\"'"))this.readString(this.ch);else if(this.isNumber(this.ch)||this.is(".")&&this.isNumber(this.peek()))this.readNumber();else if(this.isIdent(this.ch))this.readIdent(),this.was("{,")&&("{"===a[0]&&(c=this.tokens[this.tokens.length-1]))&&(c.json=-1===c.text.indexOf("."));else if(this.is("(){}[].,;:?"))this.tokens.push({index:this.index,text:this.ch,json:this.was(":[,")&&this.is("{[")||this.is("}]:,")}),this.is("{[")&&a.unshift(this.ch),this.is("}]")&&a.shift(),
this.index++;else if(this.isWhitespace(this.ch)){this.index++;continue}else{var d=this.ch+this.peek(),e=d+this.peek(2),f=Ia[this.ch],g=Ia[d],h=Ia[e];h?(this.tokens.push({index:this.index,text:e,fn:h}),this.index+=3):g?(this.tokens.push({index:this.index,text:d,fn:g}),this.index+=2):f?(this.tokens.push({index:this.index,text:this.ch,fn:f,json:this.was("[,:")&&this.is("+-")}),this.index+=1):this.throwError("Unexpected next character ",this.index,this.index+1)}this.lastCh=this.ch}return this.tokens},
is:function(a){return-1!==a.indexOf(this.ch)},was:function(a){return-1!==a.indexOf(this.lastCh)},peek:function(a){a=a||1;return this.index+a<this.text.length?this.text.charAt(this.index+a):!1},isNumber:function(a){return"0"<=a&&"9">=a},isWhitespace:function(a){return" "===a||"\r"===a||"\t"===a||"\n"===a||"\v"===a||"\u00a0"===a},isIdent:function(a){return"a"<=a&&"z">=a||"A"<=a&&"Z">=a||"_"===a||"$"===a},isExpOperator:function(a){return"-"===a||"+"===a||this.isNumber(a)},throwError:function(a,c,d){d=
d||this.index;c=z(c)?"s "+c+"-"+this.index+" ["+this.text.substring(c,d)+"]":" "+d;throw pa("lexerr",a,c,this.text);},readNumber:function(){for(var a="",c=this.index;this.index<this.text.length;){var d=w(this.text.charAt(this.index));if("."==d||this.isNumber(d))a+=d;else{var e=this.peek();if("e"==d&&this.isExpOperator(e))a+=d;else if(this.isExpOperator(d)&&e&&this.isNumber(e)&&"e"==a.charAt(a.length-1))a+=d;else if(!this.isExpOperator(d)||e&&this.isNumber(e)||"e"!=a.charAt(a.length-1))break;else this.throwError("Invalid exponent")}this.index++}a*=
1;this.tokens.push({index:c,text:a,json:!0,fn:function(){return a}})},readIdent:function(){for(var a=this,c="",d=this.index,e,f,g,h;this.index<this.text.length;){h=this.text.charAt(this.index);if("."===h||this.isIdent(h)||this.isNumber(h))"."===h&&(e=this.index),c+=h;else break;this.index++}if(e)for(f=this.index;f<this.text.length;){h=this.text.charAt(f);if("("===h){g=c.substr(e-d+1);c=c.substr(0,e-d);this.index=f;break}if(this.isWhitespace(h))f++;else break}d={index:d,text:c};if(Ia.hasOwnProperty(c))d.fn=
Ia[c],d.json=Ia[c];else{var m=rc(c,this.options,this.text);d.fn=u(function(a,c){return m(a,c)},{assign:function(d,e){return ib(d,c,e,a.text,a.options)}})}this.tokens.push(d);g&&(this.tokens.push({index:e,text:".",json:!1}),this.tokens.push({index:e+1,text:g,json:!1}))},readString:function(a){var c=this.index;this.index++;for(var d="",e=a,f=!1;this.index<this.text.length;){var g=this.text.charAt(this.index),e=e+g;if(f)"u"===g?(g=this.text.substring(this.index+1,this.index+5),g.match(/[\da-f]{4}/i)||
this.throwError("Invalid unicode escape [\\u"+g+"]"),this.index+=4,d+=String.fromCharCode(parseInt(g,16))):d=(f=Qd[g])?d+f:d+g,f=!1;else if("\\"===g)f=!0;else{if(g===a){this.index++;this.tokens.push({index:c,text:e,string:d,json:!0,fn:function(){return d}});return}d+=g}this.index++}this.throwError("Unterminated quote",c)}};var Ya=function(a,c,d){this.lexer=a;this.$filter=c;this.options=d};Ya.ZERO=function(){return 0};Ya.prototype={constructor:Ya,parse:function(a,c){this.text=a;this.json=c;this.tokens=
this.lexer.lex(a);c&&(this.assignment=this.logicalOR,this.functionCall=this.fieldAccess=this.objectIndex=this.filterChain=function(){this.throwError("is not valid json",{text:a,index:0})});var d=c?this.primary():this.statements();0!==this.tokens.length&&this.throwError("is an unexpected token",this.tokens[0]);d.literal=!!d.literal;d.constant=!!d.constant;return d},primary:function(){var a;if(this.expect("("))a=this.filterChain(),this.consume(")");else if(this.expect("["))a=this.arrayDeclaration();
else if(this.expect("{"))a=this.object();else{var c=this.expect();(a=c.fn)||this.throwError("not a primary expression",c);c.json&&(a.constant=!0,a.literal=!0)}for(var d;c=this.expect("(","[",".");)"("===c.text?(a=this.functionCall(a,d),d=null):"["===c.text?(d=a,a=this.objectIndex(a)):"."===c.text?(d=a,a=this.fieldAccess(a)):this.throwError("IMPOSSIBLE");return a},throwError:function(a,c){throw pa("syntax",c.text,a,c.index+1,this.text,this.text.substring(c.index));},peekToken:function(){if(0===this.tokens.length)throw pa("ueoe",
this.text);return this.tokens[0]},peek:function(a,c,d,e){if(0<this.tokens.length){var f=this.tokens[0],g=f.text;if(g===a||g===c||g===d||g===e||!(a||c||d||e))return f}return!1},expect:function(a,c,d,e){return(a=this.peek(a,c,d,e))?(this.json&&!a.json&&this.throwError("is not valid json",a),this.tokens.shift(),a):!1},consume:function(a){this.expect(a)||this.throwError("is unexpected, expecting ["+a+"]",this.peek())},unaryFn:function(a,c){return u(function(d,e){return a(d,e,c)},{constant:c.constant})},
ternaryFn:function(a,c,d){return u(function(e,f){return a(e,f)?c(e,f):d(e,f)},{constant:a.constant&&c.constant&&d.constant})},binaryFn:function(a,c,d){return u(function(e,f){return c(e,f,a,d)},{constant:a.constant&&d.constant})},statements:function(){for(var a=[];;)if(0<this.tokens.length&&!this.peek("}",")",";","]")&&a.push(this.filterChain()),!this.expect(";"))return 1===a.length?a[0]:function(c,d){for(var e,f=0;f<a.length;f++){var g=a[f];g&&(e=g(c,d))}return e}},filterChain:function(){for(var a=
this.expression(),c;;)if(c=this.expect("|"))a=this.binaryFn(a,c.fn,this.filter());else return a},filter:function(){for(var a=this.expect(),c=this.$filter(a.text),d=[];;)if(a=this.expect(":"))d.push(this.expression());else{var e=function(a,e,h){h=[h];for(var m=0;m<d.length;m++)h.push(d[m](a,e));return c.apply(a,h)};return function(){return e}}},expression:function(){return this.assignment()},assignment:function(){var a=this.ternary(),c,d;return(d=this.expect("="))?(a.assign||this.throwError("implies assignment but ["+
this.text.substring(0,d.index)+"] can not be assigned to",d),c=this.ternary(),function(d,f){return a.assign(d,c(d,f),f)}):a},ternary:function(){var a=this.logicalOR(),c,d;if(this.expect("?")){c=this.ternary();if(d=this.expect(":"))return this.ternaryFn(a,c,this.ternary());this.throwError("expected :",d)}else return a},logicalOR:function(){for(var a=this.logicalAND(),c;;)if(c=this.expect("||"))a=this.binaryFn(a,c.fn,this.logicalAND());else return a},logicalAND:function(){var a=this.equality(),c;if(c=
this.expect("&&"))a=this.binaryFn(a,c.fn,this.logicalAND());return a},equality:function(){var a=this.relational(),c;if(c=this.expect("==","!=","===","!=="))a=this.binaryFn(a,c.fn,this.equality());return a},relational:function(){var a=this.additive(),c;if(c=this.expect("<",">","<=",">="))a=this.binaryFn(a,c.fn,this.relational());return a},additive:function(){for(var a=this.multiplicative(),c;c=this.expect("+","-");)a=this.binaryFn(a,c.fn,this.multiplicative());return a},multiplicative:function(){for(var a=
this.unary(),c;c=this.expect("*","/","%");)a=this.binaryFn(a,c.fn,this.unary());return a},unary:function(){var a;return this.expect("+")?this.primary():(a=this.expect("-"))?this.binaryFn(Ya.ZERO,a.fn,this.unary()):(a=this.expect("!"))?this.unaryFn(a.fn,this.unary()):this.primary()},fieldAccess:function(a){var c=this,d=this.expect().text,e=rc(d,this.options,this.text);return u(function(c,d,h){return e(h||a(c,d),d)},{assign:function(e,g,h){return ib(a(e,h),d,g,c.text,c.options)}})},objectIndex:function(a){var c=
this,d=this.expression();this.consume("]");return u(function(e,f){var g=a(e,f),h=ha(d(e,f),c.text,!0),m;if(!g)return s;(g=Xa(g[h],c.text))&&(g.then&&c.options.unwrapPromises)&&(m=g,"$$v"in g||(m.$$v=s,m.then(function(a){m.$$v=a})),g=g.$$v);return g},{assign:function(e,f,g){var h=ha(d(e,g),c.text);return Xa(a(e,g),c.text)[h]=f}})},functionCall:function(a,c){var d=[];if(")"!==this.peekToken().text){do d.push(this.expression());while(this.expect(","))}this.consume(")");var e=this;return function(f,g){for(var h=
[],m=c?c(f,g):f,k=0;k<d.length;k++)h.push(d[k](f,g));k=a(f,g,m)||t;Xa(m,e.text);Xa(k,e.text);h=k.apply?k.apply(m,h):k(h[0],h[1],h[2],h[3],h[4]);return Xa(h,e.text)}},arrayDeclaration:function(){var a=[],c=!0;if("]"!==this.peekToken().text){do{var d=this.expression();a.push(d);d.constant||(c=!1)}while(this.expect(","))}this.consume("]");return u(function(c,d){for(var g=[],h=0;h<a.length;h++)g.push(a[h](c,d));return g},{literal:!0,constant:c})},object:function(){var a=[],c=!0;if("}"!==this.peekToken().text){do{var d=
this.expect(),d=d.string||d.text;this.consume(":");var e=this.expression();a.push({key:d,value:e});e.constant||(c=!1)}while(this.expect(","))}this.consume("}");return u(function(c,d){for(var e={},m=0;m<a.length;m++){var k=a[m];e[k.key]=k.value(c,d)}return e},{literal:!0,constant:c})}};var Ib={},ra=L("$sce"),ca={HTML:"html",CSS:"css",URL:"url",RESOURCE_URL:"resourceUrl",JS:"js"},R=O.createElement("a"),uc=xa(W.location.href,!0);vc.$inject=["$provide"];wc.$inject=["$locale"];yc.$inject=["$locale"];var Bc=
".",Kd={yyyy:V("FullYear",4),yy:V("FullYear",2,0,!0),y:V("FullYear",1),MMMM:jb("Month"),MMM:jb("Month",!0),MM:V("Month",2,1),M:V("Month",1,1),dd:V("Date",2),d:V("Date",1),HH:V("Hours",2),H:V("Hours",1),hh:V("Hours",2,-12),h:V("Hours",1,-12),mm:V("Minutes",2),m:V("Minutes",1),ss:V("Seconds",2),s:V("Seconds",1),sss:V("Milliseconds",3),EEEE:jb("Day"),EEE:jb("Day",!0),a:function(a,c){return 12>a.getHours()?c.AMPMS[0]:c.AMPMS[1]},Z:function(a){a=-1*a.getTimezoneOffset();return a=(0<=a?"+":"")+(Kb(Math[0<
a?"floor":"ceil"](a/60),2)+Kb(Math.abs(a%60),2))}},Jd=/((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/,Id=/^\-?\d+$/;xc.$inject=["$locale"];var Gd=aa(w),Hd=aa(Ga);zc.$inject=["$parse"];var Rd=aa({restrict:"E",compile:function(a,c){8>=P&&(c.href||c.name||c.$set("href",""),a.append(O.createComment("IE fix")));return function(a,c){c.on("click",function(a){c.attr("href")||a.preventDefault()})}}}),Mb={};q(fb,function(a,c){if("multiple"!=a){var d=ka("ng-"+c);Mb[d]=function(){return{priority:100,
compile:function(){return function(a,f,g){a.$watch(g[d],function(a){g.$set(c,!!a)})}}}}}});q(["src","srcset","href"],function(a){var c=ka("ng-"+a);Mb[c]=function(){return{priority:99,link:function(d,e,f){f.$observe(c,function(c){c&&(f.$set(a,c),P&&e.prop(a,f[a]))})}}}});var mb={$addControl:t,$removeControl:t,$setValidity:t,$setDirty:t,$setPristine:t};Cc.$inject=["$element","$attrs","$scope"];var Ec=function(a){return["$timeout",function(c){return{name:"form",restrict:a?"EAC":"E",controller:Cc,compile:function(){return{pre:function(a,
e,f,g){if(!f.action){var h=function(a){a.preventDefault?a.preventDefault():a.returnValue=!1};Dc(e[0],"submit",h);e.on("$destroy",function(){c(function(){Ab(e[0],"submit",h)},0,!1)})}var m=e.parent().controller("form"),k=f.name||f.ngForm;k&&ib(a,k,g,k);if(m)e.on("$destroy",function(){m.$removeControl(g);k&&ib(a,k,s,k);u(g,mb)})}}}}}]},Sd=Ec(),Td=Ec(!0),Ud=/^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/,Vd=/^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}$/,Wd=
/^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/,Fc={text:ob,number:function(a,c,d,e,f,g){ob(a,c,d,e,f,g);e.$parsers.push(function(a){var c=e.$isEmpty(a);if(c||Wd.test(a))return e.$setValidity("number",!0),""===a?null:c?a:parseFloat(a);e.$setValidity("number",!1);return s});e.$formatters.push(function(a){return e.$isEmpty(a)?"":""+a});d.min&&(a=function(a){var c=parseFloat(d.min);if(!e.$isEmpty(a)&&a<c)return e.$setValidity("min",!1),s;e.$setValidity("min",!0);return a},e.$parsers.push(a),e.$formatters.push(a));
d.max&&(a=function(a){var c=parseFloat(d.max);if(!e.$isEmpty(a)&&a>c)return e.$setValidity("max",!1),s;e.$setValidity("max",!0);return a},e.$parsers.push(a),e.$formatters.push(a));e.$formatters.push(function(a){if(e.$isEmpty(a)||qb(a))return e.$setValidity("number",!0),a;e.$setValidity("number",!1);return s})},url:function(a,c,d,e,f,g){ob(a,c,d,e,f,g);a=function(a){if(e.$isEmpty(a)||Ud.test(a))return e.$setValidity("url",!0),a;e.$setValidity("url",!1);return s};e.$formatters.push(a);e.$parsers.push(a)},
email:function(a,c,d,e,f,g){ob(a,c,d,e,f,g);a=function(a){if(e.$isEmpty(a)||Vd.test(a))return e.$setValidity("email",!0),a;e.$setValidity("email",!1);return s};e.$formatters.push(a);e.$parsers.push(a)},radio:function(a,c,d,e){x(d.name)&&c.attr("name",Za());c.on("click",function(){c[0].checked&&a.$apply(function(){e.$setViewValue(d.value)})});e.$render=function(){c[0].checked=d.value==e.$viewValue};d.$observe("value",e.$render)},checkbox:function(a,c,d,e){var f=d.ngTrueValue,g=d.ngFalseValue;D(f)||
(f=!0);D(g)||(g=!1);c.on("click",function(){a.$apply(function(){e.$setViewValue(c[0].checked)})});e.$render=function(){c[0].checked=e.$viewValue};e.$isEmpty=function(a){return a!==f};e.$formatters.push(function(a){return a===f});e.$parsers.push(function(a){return a?f:g})},hidden:t,button:t,submit:t,reset:t},Gc=["$browser","$sniffer",function(a,c){return{restrict:"E",require:"?ngModel",link:function(d,e,f,g){g&&(Fc[w(f.type)]||Fc.text)(d,e,f,g,c,a)}}}],lb="ng-valid",kb="ng-invalid",Ha="ng-pristine",
nb="ng-dirty",Xd=["$scope","$exceptionHandler","$attrs","$element","$parse",function(a,c,d,e,f){function g(a,c){c=c?"-"+cb(c,"-"):"";e.removeClass((a?kb:lb)+c).addClass((a?lb:kb)+c)}this.$modelValue=this.$viewValue=Number.NaN;this.$parsers=[];this.$formatters=[];this.$viewChangeListeners=[];this.$pristine=!0;this.$dirty=!1;this.$valid=!0;this.$invalid=!1;this.$name=d.name;var h=f(d.ngModel),m=h.assign;if(!m)throw L("ngModel")("nonassign",d.ngModel,ea(e));this.$render=t;this.$isEmpty=function(a){return x(a)||
""===a||null===a||a!==a};var k=e.inheritedData("$formController")||mb,l=0,n=this.$error={};e.addClass(Ha);g(!0);this.$setValidity=function(a,c){n[a]!==!c&&(c?(n[a]&&l--,l||(g(!0),this.$valid=!0,this.$invalid=!1)):(g(!1),this.$invalid=!0,this.$valid=!1,l++),n[a]=!c,g(c,a),k.$setValidity(a,c,this))};this.$setPristine=function(){this.$dirty=!1;this.$pristine=!0;e.removeClass(nb).addClass(Ha)};this.$setViewValue=function(d){this.$viewValue=d;this.$pristine&&(this.$dirty=!0,this.$pristine=!1,e.removeClass(Ha).addClass(nb),
k.$setDirty());q(this.$parsers,function(a){d=a(d)});this.$modelValue!==d&&(this.$modelValue=d,m(a,d),q(this.$viewChangeListeners,function(a){try{a()}catch(d){c(d)}}))};var r=this;a.$watch(function(){var c=h(a);if(r.$modelValue!==c){var d=r.$formatters,e=d.length;for(r.$modelValue=c;e--;)c=d[e](c);r.$viewValue!==c&&(r.$viewValue=c,r.$render())}})}],Yd=function(){return{require:["ngModel","^?form"],controller:Xd,link:function(a,c,d,e){var f=e[0],g=e[1]||mb;g.$addControl(f);a.$on("$destroy",function(){g.$removeControl(f)})}}},
Zd=aa({require:"ngModel",link:function(a,c,d,e){e.$viewChangeListeners.push(function(){a.$eval(d.ngChange)})}}),Hc=function(){return{require:"?ngModel",link:function(a,c,d,e){if(e){d.required=!0;var f=function(a){if(d.required&&e.$isEmpty(a))e.$setValidity("required",!1);else return e.$setValidity("required",!0),a};e.$formatters.push(f);e.$parsers.unshift(f);d.$observe("required",function(){f(e.$viewValue)})}}}},$d=function(){return{require:"ngModel",link:function(a,c,d,e){var f=(a=/\/(.*)\//.exec(d.ngList))&&
RegExp(a[1])||d.ngList||",";e.$parsers.push(function(a){if(!x(a)){var c=[];a&&q(a.split(f),function(a){a&&c.push(Y(a))});return c}});e.$formatters.push(function(a){return J(a)?a.join(", "):s});e.$isEmpty=function(a){return!a||!a.length}}}},ae=/^(true|false|\d+)$/,be=function(){return{priority:100,compile:function(a,c){return ae.test(c.ngValue)?function(a,c,f){f.$set("value",a.$eval(f.ngValue))}:function(a,c,f){a.$watch(f.ngValue,function(a){f.$set("value",a)})}}}},ce=sa(function(a,c,d){c.addClass("ng-binding").data("$binding",
d.ngBind);a.$watch(d.ngBind,function(a){c.text(a==s?"":a)})}),de=["$interpolate",function(a){return function(c,d,e){c=a(d.attr(e.$attr.ngBindTemplate));d.addClass("ng-binding").data("$binding",c);e.$observe("ngBindTemplate",function(a){d.text(a)})}}],ee=["$sce","$parse",function(a,c){return function(d,e,f){e.addClass("ng-binding").data("$binding",f.ngBindHtml);var g=c(f.ngBindHtml);d.$watch(function(){return(g(d)||"").toString()},function(c){e.html(a.getTrustedHtml(g(d))||"")})}}],fe=Lb("",!0),ge=
Lb("Odd",0),he=Lb("Even",1),ie=sa({compile:function(a,c){c.$set("ngCloak",s);a.removeClass("ng-cloak")}}),je=[function(){return{scope:!0,controller:"@"}}],Ic={};q("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "),function(a){var c=ka("ng-"+a);Ic[c]=["$parse",function(d){return{compile:function(e,f){var g=d(f[c]);return function(c,d,e){d.on(w(a),function(a){c.$apply(function(){g(c,{$event:a})})})}}}}]});
var ke=["$animate",function(a){return{transclude:"element",priority:600,terminal:!0,restrict:"A",$$tlb:!0,compile:function(c,d,e){return function(c,d,h){var m,k;c.$watch(h.ngIf,function(l){Na(l)?(k=c.$new(),e(k,function(c){m={startNode:c[0],endNode:c[c.length++]=O.createComment(" end ngIf: "+h.ngIf+" ")};a.enter(c,d.parent(),d)})):(k&&(k.$destroy(),k=null),m&&(a.leave(vb(m)),m=null))})}}}}],le=["$http","$templateCache","$anchorScroll","$compile","$animate","$sce",function(a,c,d,e,f,g){return{restrict:"ECA",
priority:400,terminal:!0,transclude:"element",compile:function(h,m,k){var l=m.ngInclude||m.src,n=m.onload||"",r=m.autoscroll;return function(h,m){var q=0,s,t,y=function(){s&&(s.$destroy(),s=null);t&&(f.leave(t),t=null)};h.$watch(g.parseAsResourceUrl(l),function(g){var l=function(){!z(r)||r&&!h.$eval(r)||d()},x=++q;g?(a.get(g,{cache:c}).success(function(a){if(x===q){var c=h.$new();k(c,function(d){y();s=c;t=d;t.html(a);f.enter(t,null,m,l);e(t.contents())(s);s.$emit("$includeContentLoaded");h.$eval(n)})}}).error(function(){x===
q&&y()}),h.$emit("$includeContentRequested")):y()})}}}}],me=sa({compile:function(){return{pre:function(a,c,d){a.$eval(d.ngInit)}}}}),ne=sa({terminal:!0,priority:1E3}),oe=["$locale","$interpolate",function(a,c){var d=/{}/g;return{restrict:"EA",link:function(e,f,g){var h=g.count,m=g.$attr.when&&f.attr(g.$attr.when),k=g.offset||0,l=e.$eval(m)||{},n={},r=c.startSymbol(),p=c.endSymbol(),s=/^when(Minus)?(.+)$/;q(g,function(a,c){s.test(c)&&(l[w(c.replace("when","").replace("Minus","-"))]=f.attr(g.$attr[c]))});
q(l,function(a,e){n[e]=c(a.replace(d,r+h+"-"+k+p))});e.$watch(function(){var c=parseFloat(e.$eval(h));if(isNaN(c))return"";c in l||(c=a.pluralCat(c-k));return n[c](e,f,!0)},function(a){f.text(a)})}}}],pe=["$parse","$animate",function(a,c){var d=L("ngRepeat");return{transclude:"element",priority:1E3,terminal:!0,$$tlb:!0,compile:function(e,f,g){return function(e,f,k){var l=k.ngRepeat,n=l.match(/^\s*(.+)\s+in\s+(.*?)\s*(\s+track\s+by\s+(.+)\s*)?$/),r,p,s,t,z,A,x,G={$id:Ca};if(!n)throw d("iexp",l);k=
n[1];z=n[2];(n=n[4])?(r=a(n),p=function(a,c,d){x&&(G[x]=a);G[A]=c;G.$index=d;return r(e,G)}):(s=function(a,c){return Ca(c)},t=function(a){return a});n=k.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);if(!n)throw d("iidexp",k);A=n[3]||n[1];x=n[2];var v={};e.$watchCollection(z,function(a){var k,n,r=f[0],z,M={},G,N,w,I,D,u,J=[];if(pb(a))D=a,z=p||s;else{z=p||t;D=[];for(w in a)a.hasOwnProperty(w)&&"$"!=w.charAt(0)&&D.push(w);D.sort()}G=D.length;n=J.length=D.length;for(k=0;k<n;k++)if(w=a===D?k:
D[k],I=a[w],I=z(w,I,k),na(I,"`track by` id"),v.hasOwnProperty(I))u=v[I],delete v[I],M[I]=u,J[k]=u;else{if(M.hasOwnProperty(I))throw q(J,function(a){a&&a.startNode&&(v[a.id]=a)}),d("dupes",l,I);J[k]={id:I};M[I]=!1}for(w in v)v.hasOwnProperty(w)&&(u=v[w],k=vb(u),c.leave(k),q(k,function(a){a.$$NG_REMOVED=!0}),u.scope.$destroy());k=0;for(n=D.length;k<n;k++){w=a===D?k:D[k];I=a[w];u=J[k];J[k-1]&&(r=J[k-1].endNode);if(u.startNode){N=u.scope;z=r;do z=z.nextSibling;while(z&&z.$$NG_REMOVED);u.startNode!=z&&
c.move(vb(u),null,y(r));r=u.endNode}else N=e.$new();N[A]=I;x&&(N[x]=w);N.$index=k;N.$first=0===k;N.$last=k===G-1;N.$middle=!(N.$first||N.$last);N.$odd=!(N.$even=0===(k&1));u.startNode||g(N,function(a){a[a.length++]=O.createComment(" end ngRepeat: "+l+" ");c.enter(a,null,y(r));r=a;u.scope=N;u.startNode=r&&r.endNode?r.endNode:a[0];u.endNode=a[a.length-1];M[u.id]=u})}v=M})}}}}],qe=["$animate",function(a){return function(c,d,e){c.$watch(e.ngShow,function(c){a[Na(c)?"removeClass":"addClass"](d,"ng-hide")})}}],
re=["$animate",function(a){return function(c,d,e){c.$watch(e.ngHide,function(c){a[Na(c)?"addClass":"removeClass"](d,"ng-hide")})}}],se=sa(function(a,c,d){a.$watch(d.ngStyle,function(a,d){d&&a!==d&&q(d,function(a,d){c.css(d,"")});a&&c.css(a)},!0)}),te=["$animate",function(a){return{restrict:"EA",require:"ngSwitch",controller:["$scope",function(){this.cases={}}],link:function(c,d,e,f){var g,h,m=[];c.$watch(e.ngSwitch||e.on,function(d){for(var l=0,n=m.length;l<n;l++)m[l].$destroy(),a.leave(h[l]);h=[];
m=[];if(g=f.cases["!"+d]||f.cases["?"])c.$eval(e.change),q(g,function(d){var e=c.$new();m.push(e);d.transclude(e,function(c){var e=d.element;h.push(c);a.enter(c,e.parent(),e)})})})}}}],ue=sa({transclude:"element",priority:800,require:"^ngSwitch",compile:function(a,c,d){return function(a,f,g,h){h.cases["!"+c.ngSwitchWhen]=h.cases["!"+c.ngSwitchWhen]||[];h.cases["!"+c.ngSwitchWhen].push({transclude:d,element:f})}}}),ve=sa({transclude:"element",priority:800,require:"^ngSwitch",compile:function(a,c,d){return function(a,
c,g,h){h.cases["?"]=h.cases["?"]||[];h.cases["?"].push({transclude:d,element:c})}}}),we=sa({controller:["$element","$transclude",function(a,c){if(!c)throw L("ngTransclude")("orphan",ea(a));this.$transclude=c}],link:function(a,c,d,e){e.$transclude(function(a){c.html("");c.append(a)})}}),xe=["$templateCache",function(a){return{restrict:"E",terminal:!0,compile:function(c,d){"text/ng-template"==d.type&&a.put(d.id,c[0].text)}}}],ye=L("ngOptions"),ze=aa({terminal:!0}),Ae=["$compile","$parse",function(a,
c){var d=/^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/,e={$setViewValue:t};return{restrict:"E",require:["select","?ngModel"],controller:["$element","$scope","$attrs",function(a,c,d){var m=this,k={},l=e,n;m.databound=d.ngModel;m.init=function(a,c,d){l=a;n=d};m.addOption=function(c){na(c,'"option value"');k[c]=!0;l.$viewValue==c&&(a.val(c),n.parent()&&n.remove())};m.removeOption=
function(a){this.hasOption(a)&&(delete k[a],l.$viewValue==a&&this.renderUnknownOption(a))};m.renderUnknownOption=function(c){c="? "+Ca(c)+" ?";n.val(c);a.prepend(n);a.val(c);n.prop("selected",!0)};m.hasOption=function(a){return k.hasOwnProperty(a)};c.$on("$destroy",function(){m.renderUnknownOption=t})}],link:function(e,g,h,m){function k(a,c,d,e){d.$render=function(){var a=d.$viewValue;e.hasOption(a)?(v.parent()&&v.remove(),c.val(a),""===a&&A.prop("selected",!0)):x(a)&&A?c.val(""):e.renderUnknownOption(a)};
c.on("change",function(){a.$apply(function(){v.parent()&&v.remove();d.$setViewValue(c.val())})})}function l(a,c,d){var e;d.$render=function(){var a=new Sa(d.$viewValue);q(c.find("option"),function(c){c.selected=z(a.get(c.value))})};a.$watch(function(){Aa(e,d.$viewValue)||(e=da(d.$viewValue),d.$render())});c.on("change",function(){a.$apply(function(){var a=[];q(c.find("option"),function(c){c.selected&&a.push(c.value)});d.$setViewValue(a)})})}function n(e,f,g){function h(){var a={"":[]},c=[""],d,k,
s,u,x;u=g.$modelValue;x=r(e)||[];var A=n?Nb(x):x,H,K,B;K={};s=!1;var E,L;if(t)if(v&&J(u))for(s=new Sa([]),B=0;B<u.length;B++)K[m]=u[B],s.put(v(e,K),u[B]);else s=new Sa(u);for(B=0;H=A.length,B<H;B++){k=B;if(n){k=A[B];if("$"===k.charAt(0))continue;K[n]=k}K[m]=x[k];d=p(e,K)||"";(k=a[d])||(k=a[d]=[],c.push(d));t?d=z(s.remove(v?v(e,K):q(e,K))):(v?(d={},d[m]=u,d=v(e,d)===v(e,K)):d=u===q(e,K),s=s||d);E=l(e,K);E=z(E)?E:"";k.push({id:v?v(e,K):n?A[B]:B,label:E,selected:d})}t||(w||null===u?a[""].unshift({id:"",
label:"",selected:!s}):s||a[""].unshift({id:"?",label:"",selected:!0}));K=0;for(A=c.length;K<A;K++){d=c[K];k=a[d];y.length<=K?(u={element:G.clone().attr("label",d),label:k.label},x=[u],y.push(x),f.append(u.element)):(x=y[K],u=x[0],u.label!=d&&u.element.attr("label",u.label=d));E=null;B=0;for(H=k.length;B<H;B++)s=k[B],(d=x[B+1])?(E=d.element,d.label!==s.label&&E.text(d.label=s.label),d.id!==s.id&&E.val(d.id=s.id),E[0].selected!==s.selected&&E.prop("selected",d.selected=s.selected)):(""===s.id&&w?L=
w:(L=D.clone()).val(s.id).attr("selected",s.selected).text(s.label),x.push({element:L,label:s.label,id:s.id,selected:s.selected}),E?E.after(L):u.element.append(L),E=L);for(B++;x.length>B;)x.pop().element.remove()}for(;y.length>K;)y.pop()[0].element.remove()}var k;if(!(k=u.match(d)))throw ye("iexp",u,ea(f));var l=c(k[2]||k[1]),m=k[4]||k[6],n=k[5],p=c(k[3]||""),q=c(k[2]?k[1]:m),r=c(k[7]),v=k[8]?c(k[8]):null,y=[[{element:f,label:""}]];w&&(a(w)(e),w.removeClass("ng-scope"),w.remove());f.html("");f.on("change",
function(){e.$apply(function(){var a,c=r(e)||[],d={},h,k,l,p,u,x,w;if(t)for(k=[],p=0,x=y.length;p<x;p++)for(a=y[p],l=1,u=a.length;l<u;l++){if((h=a[l].element)[0].selected){h=h.val();n&&(d[n]=h);if(v)for(w=0;w<c.length&&(d[m]=c[w],v(e,d)!=h);w++);else d[m]=c[h];k.push(q(e,d))}}else if(h=f.val(),"?"==h)k=s;else if(""===h)k=null;else if(v)for(w=0;w<c.length;w++){if(d[m]=c[w],v(e,d)==h){k=q(e,d);break}}else d[m]=c[h],n&&(d[n]=h),k=q(e,d);g.$setViewValue(k)})});g.$render=h;e.$watch(h)}if(m[1]){var r=m[0],
p=m[1],t=h.multiple,u=h.ngOptions,w=!1,A,D=y(O.createElement("option")),G=y(O.createElement("optgroup")),v=D.clone();m=0;for(var B=g.children(),E=B.length;m<E;m++)if(""===B[m].value){A=w=B.eq(m);break}r.init(p,w,v);if(t&&(h.required||h.ngRequired)){var L=function(a){p.$setValidity("required",!h.required||a&&a.length);return a};p.$parsers.push(L);p.$formatters.unshift(L);h.$observe("required",function(){L(p.$viewValue)})}u?n(e,g,p):t?l(e,g,p):k(e,g,p,r)}}}}],Be=["$interpolate",function(a){var c={addOption:t,
removeOption:t};return{restrict:"E",priority:100,compile:function(d,e){if(x(e.value)){var f=a(d.text(),!0);f||e.$set("value",d.text())}return function(a,d,e){var k=d.parent(),l=k.data("$selectController")||k.parent().data("$selectController");l&&l.databound?d.prop("selected",!1):l=c;f?a.$watch(f,function(a,c){e.$set("value",a);a!==c&&l.removeOption(c);l.addOption(a)}):l.addOption(e.value);d.on("$destroy",function(){l.removeOption(e.value)})}}}}],Ce=aa({restrict:"E",terminal:!0});(Ba=W.jQuery)?(y=
Ba,u(Ba.fn,{scope:Da.scope,isolateScope:Da.isolateScope,controller:Da.controller,injector:Da.injector,inheritedData:Da.inheritedData}),wb("remove",!0,!0,!1),wb("empty",!1,!1,!1),wb("html",!1,!1,!0)):y=Q;bb.element=y;(function(a){u(a,{bootstrap:Wb,copy:da,extend:u,equals:Aa,element:y,forEach:q,injector:Xb,noop:t,bind:rb,toJson:ma,fromJson:Sb,identity:za,isUndefined:x,isDefined:z,isString:D,isFunction:B,isObject:T,isNumber:qb,isElement:Kc,isArray:J,version:Md,isDate:Ja,lowercase:w,uppercase:Ga,callbacks:{counter:0},
$$minErr:L,$$csp:Rb});Ua=Qc(W);try{Ua("ngLocale")}catch(c){Ua("ngLocale",[]).provider("$locale",pd)}Ua("ng",["ngLocale"],["$provide",function(a){a.provider("$compile",ec).directive({a:Rd,input:Gc,textarea:Gc,form:Sd,script:xe,select:Ae,style:Ce,option:Be,ngBind:ce,ngBindHtml:ee,ngBindTemplate:de,ngClass:fe,ngClassEven:he,ngClassOdd:ge,ngCloak:ie,ngController:je,ngForm:Td,ngHide:re,ngIf:ke,ngInclude:le,ngInit:me,ngNonBindable:ne,ngPluralize:oe,ngRepeat:pe,ngShow:qe,ngStyle:se,ngSwitch:te,ngSwitchWhen:ue,
ngSwitchDefault:ve,ngOptions:ze,ngTransclude:we,ngModel:Yd,ngList:$d,ngChange:Zd,required:Hc,ngRequired:Hc,ngValue:be}).directive(Mb).directive(Ic);a.provider({$anchorScroll:Zc,$animate:Od,$browser:bd,$cacheFactory:cd,$controller:gd,$document:hd,$exceptionHandler:id,$filter:vc,$interpolate:nd,$interval:od,$http:jd,$httpBackend:kd,$location:rd,$log:sd,$parse:td,$rootScope:wd,$q:ud,$sce:zd,$sceDelegate:yd,$sniffer:Ad,$templateCache:dd,$timeout:Bd,$window:Cd})}])})(bb);y(O).ready(function(){Oc(O,Wb)})})(window,
document);!angular.$$csp()&&angular.element(document).find("head").prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide{display:none !important;}ng\\:form{display:block;}.ng-animate-start{clip:rect(0,auto,auto,0);-ms-zoom:1.0001;}.ng-animate-active{clip:rect(-1px,auto,auto,0);-ms-zoom:1;}</style>');
//# sourceMappingURL=angular.min.js.map

/*
 AngularJS v1.2.0
 (c) 2010-2012 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(A,s,B){'use strict';s.module("ngAnimate",["ng"]).config(["$provide","$animateProvider",function(N,D){var z=s.noop,k=s.forEach,X=D.$$selectors,T=1,f="$$ngAnimateState",E="ng-animate",g={running:!0};N.decorator("$animate",["$delegate","$injector","$sniffer","$rootElement","$timeout","$rootScope","$document",function(t,A,F,m,G,p,H){function B(a){if(a){var d=[],b={};a=a.substr(1).split(".");(F.transitions||F.animations)&&a.push("");for(var c=0;c<a.length;c++){var h=a[c],f=X[h];f&&!b[h]&&(d.push(A.get(f)),
b[h]=!0)}return d}}function n(a,d,b,c,h,g,m){function p(a){g();if(!0===a)u();else{if(a=b.data(f))a.done=u,b.data(f,a);s(v,"after",u)}}function s(c,h,g){var f=h+"End";k(c,function(k,t){var e=function(){a:{var e=h+"Complete",a=c[t];a[e]=!0;(a[f]||z)();for(a=0;a<c.length;a++)if(!c[a][e])break a;g()}};"before"!=h||"enter"!=a&&"move"!=a?k[h]?k[f]=n?k[h](b,d,e):k[h](b,e):e():e()})}function t(){m&&G(m,0,!1)}function u(){if(!u.hasBeenRun){u.hasBeenRun=!0;var a=b.data(f);a&&(n?q(b):(a.closeAnimationTimeout=
G(function(){q(b)},0,!1),b.data(f,a)));t()}}var r=(" "+((b.attr("class")||"")+" "+d)).replace(/\s+/g,".");c||(c=h?h.parent():b.parent());h=B(r);var n="addClass"==a||"removeClass"==a,r=b.data(f)||{};if(J(b,c)||0===h.length)g(),u();else{var v=[];r.running&&n&&r.structural||k(h,function(c){if(!c.allowCancel||c.allowCancel(b,a,d)){var h=c[a];"leave"==a?(c=h,h=null):c=c["before"+a.charAt(0).toUpperCase()+a.substr(1)];v.push({before:c,after:h})}});0===v.length?(g(),t()):(r.running&&(G.cancel(r.closeAnimationTimeout),
q(b),K(r.animations),(r.done||z)(!0)),"addClass"==a&&b.hasClass(d)||"removeClass"==a&&!b.hasClass(d)?(g(),t()):(b.addClass(E),b.data(f,{running:!0,structural:!n,animations:v,done:p}),s(v,"before",p)))}}function L(a){a=a[0];a.nodeType==T&&k(a.querySelectorAll("."+E),function(a){a=s.element(a);var b=a.data(f);b&&(K(b.animations),q(a))})}function K(a){k(a,function(d){a.beforeComplete||(d.beforeEnd||z)(!0);a.afterComplete||(d.afterEnd||z)(!0)})}function q(a){a[0]==m[0]?g.disabled||(g.running=!1,g.structural=
!1):(a.removeClass(E),a.removeData(f))}function J(a,d){if(g.disabled)return!0;if(a[0]==m[0])return g.disabled||g.running;do{if(0===d.length)break;var b=d[0]==m[0],c=b?g:d.data(f),c=c&&(!!c.disabled||!!c.running);if(b||c)return c;if(b)break}while(d=d.parent());return!0}m.data(f,g);p.$$postDigest(function(){g.running=!1});return{enter:function(a,d,b,c){this.enabled(!1,a);t.enter(a,d,b);p.$$postDigest(function(){n("enter","ng-enter",a,d,b,z,c)})},leave:function(a,d){L(a);this.enabled(!1,a);p.$$postDigest(function(){n("leave",
"ng-leave",a,null,null,function(){t.leave(a)},d)})},move:function(a,d,b,c){L(a);this.enabled(!1,a);t.move(a,d,b);p.$$postDigest(function(){n("move","ng-move",a,d,b,z,c)})},addClass:function(a,d,b){n("addClass",d,a,null,null,function(){t.addClass(a,d)},b)},removeClass:function(a,d,b){n("removeClass",d,a,null,null,function(){t.removeClass(a,d)},b)},enabled:function(a,d){switch(arguments.length){case 2:if(a)q(d);else{var b=d.data(f)||{};b.disabled=!0;d.data(f,b)}break;case 1:g.disabled=!a;break;default:a=
!g.disabled}return!!a}}}]);D.register("",["$window","$sniffer","$timeout",function(f,g,F){function m(e){Q.push(e);F.cancel(R);R=F(function(){k(Q,function(e){e()});Q=[];R=null;C={}},10,!1)}function G(e,a){var w=e.getAttribute("style")||"";e.setAttribute("style",(0<w.length?"; ":"")+a);return w}function p(e,a){var w=a?C[a]:null;if(!w){var b=0,d=0,c=0,l=0,g,n,m,p;k(e,function(e){if(e.nodeType==T){e=f.getComputedStyle(e)||{};m=e[h+D];b=Math.max(H(m),b);p=e[h+S];g=e[h+u];d=Math.max(H(g),d);n=e[I+u];l=
Math.max(H(n),l);var a=H(e[I+D]);0<a&&(a*=parseInt(e[I+r],10)||1);c=Math.max(a,c)}});w={total:0,transitionPropertyStyle:p,transitionDurationStyle:m,transitionDelayStyle:g,transitionDelay:d,transitionDuration:b,animationDelayStyle:n,animationDelay:l,animationDuration:c};a&&(C[a]=w)}return w}function H(e){var a=0;e=s.isString(e)?e.split(/\s*,\s*/):[];k(e,function(e){a=Math.max(parseFloat(e)||0,a)});return a}function E(e){var a=e.parent(),b=a.data(W);b||(a.data(W,++V),b=V);return b+"-"+e[0].className}
function n(e,a){var b=E(e),d=b+" "+a,c={},g=C[d]?++C[d].total:0;if(0<g){var l=a+"-stagger",c=b+" "+l;(b=!C[c])&&e.addClass(l);c=p(e,c);b&&e.removeClass(l)}e.addClass(a);d=p(e,d);l=Math.max(d.transitionDuration,d.animationDuration);if(0===l)return e.removeClass(a),!1;var b=e[0],f="";0<d.transitionDuration&&(e.addClass(U),f+=N+" ",b.style[h+S]="none");k(a.split(" "),function(a,e){f+=(0<e?" ":"")+a+"-active"});e.data(v,{className:a,activeClassName:f,maxDuration:l,classes:a+" "+f,timings:d,stagger:c,
ii:g});return!0}function L(a,b,w){function f(a){a.stopPropagation();a=a.originalEvent||a;var e=a.$manualTimeStamp||a.timeStamp||Date.now();Math.max(e-t,0)>=p&&a.elapsedTime>=n&&w()}var x=a.data(v);if(a.hasClass(b)&&x){var M=a[0],l=x.timings,k=x.stagger,n=x.maxDuration,m=x.activeClassName,p=1E3*Math.max(l.transitionDelay,l.animationDelay),t=Date.now(),s=P+" "+O,r,x=x.ii,u,y="";if(0<l.transitionDuration){M.style[h+S]="";var q=l.transitionPropertyStyle;-1==q.indexOf("all")&&(u=!0,y+=c+"transition-property: "+
q+", "+(g.msie?"-ms-zoom":"clip")+"; ",y+=c+"transition-duration: "+l.transitionDurationStyle+", "+l.transitionDuration+"s; ")}0<x&&(0<k.transitionDelay&&0===k.transitionDuration&&(q=l.transitionDelayStyle,u&&(q+=", "+l.transitionDelay+"s"),y+=c+"transition-delay: "+K(q,k.transitionDelay,x)+"; "),0<k.animationDelay&&0===k.animationDuration&&(y+=c+"animation-delay: "+K(l.animationDelayStyle,k.animationDelay,x)+"; "));0<y.length&&(r=G(M,y));a.on(s,f);a.addClass(m);return function(c){a.off(s,f);a.removeClass(m);
d(a,b);null!=r&&(0<r.length?M.setAttribute("style",r):M.removeAttribute("style"))}}w()}function K(a,b,d){var c="";k(a.split(","),function(a,e){c+=(0<e?",":"")+(d*b+parseInt(a,10))+"s"});return c}function q(a,b){if(n(a,b))return function(c){c&&d(a,b)}}function J(a,b,c){if(a.data(v))return L(a,b,c);d(a,b);c()}function a(a,b,c){var d=q(a,b);if(d){var f=d;m(function(){f=J(a,b,c)});return function(a){(f||z)(a)}}c()}function d(a,b){a.removeClass(b);a.removeClass(U);a.removeData(v)}function b(a,b){var c=
"";a=s.isArray(a)?a:a.split(/\s+/);k(a,function(a,e){a&&0<a.length&&(c+=(0<e?" ":"")+a+b)});return c}var c="",h,O,I,P;A.ontransitionend===B&&A.onwebkittransitionend!==B?(c="-webkit-",h="WebkitTransition",O="webkitTransitionEnd transitionend"):(h="transition",O="transitionend");A.onanimationend===B&&A.onwebkitanimationend!==B?(c="-webkit-",I="WebkitAnimation",P="webkitAnimationEnd animationend"):(I="animation",P="animationend");var D="Duration",S="Property",u="Delay",r="IterationCount",W="$$ngAnimateKey",
v="$$ngAnimateCSS3Data",U="ng-animate-start",N="ng-animate-active",C={},V=0,Q=[],R;return{allowCancel:function(a,c,d){var f=(a.data(v)||{}).classes;if(!f||0<=["enter","leave","move"].indexOf(c))return!0;var h=a.parent(),g=s.element(a[0].cloneNode());g.attr("style","position:absolute; top:-9999px; left:-9999px");g.removeAttr("id");g.html("");k(f.split(" "),function(a){g.removeClass(a)});g.addClass(b(d,"addClass"==c?"-add":"-remove"));h.append(g);a=p(g);g.remove();return 0<Math.max(a.transitionDuration,
a.animationDuration)},enter:function(b,c){return a(b,"ng-enter",c)},leave:function(b,c){return a(b,"ng-leave",c)},move:function(b,c){return a(b,"ng-move",c)},beforeAddClass:function(a,c,d){if(a=q(a,b(c,"-add")))return m(d),a;d()},addClass:function(a,c,d){return J(a,b(c,"-add"),d)},beforeRemoveClass:function(a,c,d){if(a=q(a,b(c,"-remove")))return m(d),a;d()},removeClass:function(a,c,d){return J(a,b(c,"-remove"),d)}}}])}])})(window,window.angular);
//# sourceMappingURL=angular-animate.min.js.map

/*
 AngularJS v1.2.0
 (c) 2010-2012 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(H,h,C){'use strict';var x=h.$$minErr("$resource");h.module("ngResource",["ng"]).factory("$resource",["$http","$parse","$q",function(D,y,E){function n(h,k){this.template=h;this.defaults=k||{};this.urlParams={}}function t(e,k,f){function q(b,c){var d={};c=u({},k,c);r(c,function(a,c){s(a)&&(a=a());var m;a&&a.charAt&&"@"==a.charAt(0)?(m=a.substr(1),m=y(m)(b)):m=a;d[c]=m});return d}function d(b){return b.resource}function g(b){z(b||{},this)}var F=new n(e);f=u({},G,f);r(f,function(b,c){var A=
/^(POST|PUT|PATCH)$/i.test(b.method);g[c]=function(a,c,m,k){var p={},e,f,v;switch(arguments.length){case 4:v=k,f=m;case 3:case 2:if(s(c)){if(s(a)){f=a;v=c;break}f=c;v=m}else{p=a;e=c;f=m;break}case 1:s(a)?f=a:A?e=a:p=a;break;case 0:break;default:throw x("badargs",arguments.length);}var n=e instanceof g,l=n?e:b.isArray?[]:new g(e),w={},t=b.interceptor&&b.interceptor.response||d,y=b.interceptor&&b.interceptor.responseError||C;r(b,function(a,c){"params"!=c&&("isArray"!=c&&"interceptor"!=c)&&(w[c]=z(a))});
A&&(w.data=e);F.setUrlParams(w,u({},q(e,b.params||{}),p),b.url);p=D(w).then(function(c){var a=c.data,d=l.$promise;if(a){if(h.isArray(a)!==!!b.isArray)throw x("badcfg",b.isArray?"array":"object",h.isArray(a)?"array":"object");b.isArray?(l.length=0,r(a,function(a){l.push(new g(a))})):(z(a,l),l.$promise=d)}l.$resolved=!0;c.resource=l;return c},function(a){l.$resolved=!0;(v||B)(a);return E.reject(a)});p=p.then(function(a){var c=t(a);(f||B)(c,a.headers);return c},y);return n?p:(l.$promise=p,l.$resolved=
!1,l)};g.prototype["$"+c]=function(a,b,d){s(a)&&(d=b,b=a,a={});a=g[c](a,this,b,d);return a.$promise||a}});g.bind=function(b){return t(e,u({},k,b),f)};return g}var G={get:{method:"GET"},save:{method:"POST"},query:{method:"GET",isArray:!0},remove:{method:"DELETE"},"delete":{method:"DELETE"}},B=h.noop,r=h.forEach,u=h.extend,z=h.copy,s=h.isFunction;n.prototype={setUrlParams:function(e,k,f){var q=this,d=f||q.template,g,n,b=q.urlParams={};r(d.split(/\W/),function(c){if("hasOwnProperty"===c)throw x("badname");
!/^\d+$/.test(c)&&(c&&RegExp("(^|[^\\\\]):"+c+"(\\W|$)").test(d))&&(b[c]=!0)});d=d.replace(/\\:/g,":");k=k||{};r(q.urlParams,function(c,b){g=k.hasOwnProperty(b)?k[b]:q.defaults[b];h.isDefined(g)&&null!==g?(n=encodeURIComponent(g).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"%20").replace(/%26/gi,"&").replace(/%3D/gi,"=").replace(/%2B/gi,"+"),d=d.replace(RegExp(":"+b+"(\\W|$)","g"),n+"$1")):d=d.replace(RegExp("(/?):"+b+"(\\W|$)","g"),function(a,
c,b){return"/"==b.charAt(0)?b:c+b})});d=d.replace(/\/+$/,"");d=d.replace(/\/\.(?=\w+($|\?))/,".");e.url=d.replace(/\/\\\./,"/.");r(k,function(c,b){q.urlParams[b]||(e.params=e.params||{},e.params[b]=c)})}};return t}])})(window,window.angular);
//# sourceMappingURL=angular-resource.min.js.map

/*
 AngularJS v1.2.0
 (c) 2010-2012 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(t,c,B){'use strict';function w(s,r,g,a,h){return{restrict:"ECA",terminal:!0,priority:400,transclude:"element",compile:function(k,d,A){return function(u,k,d){function v(){l&&(l.$destroy(),l=null);m&&(h.leave(m),m=null)}function x(){var f=s.current&&s.current.locals,y=f&&f.$template;if(y){var z=u.$new();A(z,function(e){e.html(y);h.enter(e,null,m||k,function(){!c.isDefined(n)||n&&!u.$eval(n)||r()});v();var p=g(e.contents()),q=s.current;l=q.scope=z;m=e;if(q.controller){f.$scope=l;var d=a(q.controller,
f);q.controllerAs&&(l[q.controllerAs]=d);e.data("$ngControllerController",d);e.children().data("$ngControllerController",d)}p(l);l.$emit("$viewContentLoaded");l.$eval(b)})}else v()}var l,m,n=d.autoscroll,b=d.onload||"";u.$on("$routeChangeSuccess",x);x()}}}}t=c.module("ngRoute",["ng"]).provider("$route",function(){function s(a,h){return c.extend(new (c.extend(function(){},{prototype:a})),h)}function r(a,c){var k=c.caseInsensitiveMatch,d={originalPath:a,regexp:a},g=d.keys=[];a=a.replace(/([().])/g,
"\\$1").replace(/(\/)?:(\w+)([\?|\*])?/g,function(a,c,h,d){a="?"===d?d:null;d="*"===d?d:null;g.push({name:h,optional:!!a});c=c||"";return""+(a?"":c)+"(?:"+(a?c:"")+(d&&"(.+?)"||"([^/]+)")+(a||"")+")"+(a||"")}).replace(/([\/$\*])/g,"\\$1");d.regexp=RegExp("^"+a+"$",k?"i":"");return d}var g={};this.when=function(a,h){g[a]=c.extend({reloadOnSearch:!0},h,a&&r(a,h));if(a){var k="/"==a[a.length-1]?a.substr(0,a.length-1):a+"/";g[k]=c.extend({redirectTo:a},r(k,h))}return this};this.otherwise=function(a){this.when(null,
a);return this};this.$get=["$rootScope","$location","$routeParams","$q","$injector","$http","$templateCache","$sce",function(a,h,k,d,r,u,t,w){function v(){var b=x(),f=n.current;if(b&&f&&b.$$route===f.$$route&&c.equals(b.pathParams,f.pathParams)&&!b.reloadOnSearch&&!m)f.params=b.params,c.copy(f.params,k),a.$broadcast("$routeUpdate",f);else if(b||f)m=!1,a.$broadcast("$routeChangeStart",b,f),(n.current=b)&&b.redirectTo&&(c.isString(b.redirectTo)?h.path(l(b.redirectTo,b.params)).search(b.params).replace():
h.url(b.redirectTo(b.pathParams,h.path(),h.search())).replace()),d.when(b).then(function(){if(b){var a=c.extend({},b.resolve),f,e;c.forEach(a,function(b,f){a[f]=c.isString(b)?r.get(b):r.invoke(b)});c.isDefined(f=b.template)?c.isFunction(f)&&(f=f(b.params)):c.isDefined(e=b.templateUrl)&&(c.isFunction(e)&&(e=e(b.params)),e=w.getTrustedResourceUrl(e),c.isDefined(e)&&(b.loadedTemplateUrl=e,f=u.get(e,{cache:t}).then(function(b){return b.data})));c.isDefined(f)&&(a.$template=f);return d.all(a)}}).then(function(d){b==
n.current&&(b&&(b.locals=d,c.copy(b.params,k)),a.$broadcast("$routeChangeSuccess",b,f))},function(c){b==n.current&&a.$broadcast("$routeChangeError",b,f,c)})}function x(){var b,a;c.forEach(g,function(d,l){var e;if(e=!a){var p=h.path();e=d.keys;var q={};if(d.regexp)if(p=d.regexp.exec(p)){for(var g=1,k=p.length;g<k;++g){var m=e[g-1],n="string"==typeof p[g]?decodeURIComponent(p[g]):p[g];m&&n&&(q[m.name]=n)}e=q}else e=null;else e=null;e=b=e}e&&(a=s(d,{params:c.extend({},h.search(),b),pathParams:b}),a.$$route=
d)});return a||g[null]&&s(g[null],{params:{},pathParams:{}})}function l(a,d){var g=[];c.forEach((a||"").split(":"),function(a,b){if(0===b)g.push(a);else{var c=a.match(/(\w+)(.*)/),h=c[1];g.push(d[h]);g.push(c[2]||"");delete d[h]}});return g.join("")}var m=!1,n={routes:g,reload:function(){m=!0;a.$evalAsync(v)}};a.$on("$locationChangeSuccess",v);return n}]});t.provider("$routeParams",function(){this.$get=function(){return{}}});t.directive("ngView",w);w.$inject=["$route","$anchorScroll","$compile","$controller",
"$animate"]})(window,window.angular);
//# sourceMappingURL=angular-route.min.js.map

/*
 AngularJS v1.2.0
 (c) 2010-2012 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(m,g,n){'use strict';function h(a){var d={};a=a.split(",");var c;for(c=0;c<a.length;c++)d[a[c]]=!0;return d}function D(a,d){function c(a,b,c,f){b=g.lowercase(b);if(r[b])for(;e.last()&&s[e.last()];)k("",e.last());t[b]&&e.last()==b&&k("",b);(f=u[b]||!!f)||e.push(b);var l={};c.replace(E,function(a,b,d,c,e){l[b]=p(d||c||e||"")});d.start&&d.start(b,l,f)}function k(a,b){var c=0,k;if(b=g.lowercase(b))for(c=e.length-1;0<=c&&e[c]!=b;c--);if(0<=c){for(k=e.length-1;k>=c;k--)d.end&&d.end(e[k]);e.length=
c}}var b,f,e=[],l=a;for(e.last=function(){return e[e.length-1]};a;){f=!0;if(e.last()&&v[e.last()])a=a.replace(RegExp("(.*)<\\s*\\/\\s*"+e.last()+"[^>]*>","i"),function(a,b){b=b.replace(F,"$1").replace(G,"$1");d.chars&&d.chars(p(b));return""}),k("",e.last());else{if(0===a.indexOf("\x3c!--"))b=a.indexOf("--",4),0<=b&&a.lastIndexOf("--\x3e",b)===b&&(d.comment&&d.comment(a.substring(4,b)),a=a.substring(b+3),f=!1);else if(w.test(a)){if(b=a.match(w))a=a.replace(b[0],""),f=!1}else if(H.test(a)){if(b=a.match(x))a=
a.substring(b[0].length),b[0].replace(x,k),f=!1}else I.test(a)&&(b=a.match(y))&&(a=a.substring(b[0].length),b[0].replace(y,c),f=!1);f&&(b=a.indexOf("<"),f=0>b?a:a.substring(0,b),a=0>b?"":a.substring(b),d.chars&&d.chars(p(f)))}if(a==l)throw J("badparse",a);l=a}k()}function p(a){q.innerHTML=a.replace(/</g,"&lt;");return q.innerText||q.textContent||""}function z(a){return a.replace(/&/g,"&amp;").replace(K,function(a){return"&#"+a.charCodeAt(0)+";"}).replace(/</g,"&lt;").replace(/>/g,"&gt;")}function A(a){var d=
!1,c=g.bind(a,a.push);return{start:function(a,b,f){a=g.lowercase(a);!d&&v[a]&&(d=a);d||!0!==B[a]||(c("<"),c(a),g.forEach(b,function(a,b){var d=g.lowercase(b);!0!==L[d]||!0===C[d]&&!a.match(M)||(c(" "),c(b),c('="'),c(z(a)),c('"'))}),c(f?"/>":">"))},end:function(a){a=g.lowercase(a);d||!0!==B[a]||(c("</"),c(a),c(">"));a==d&&(d=!1)},chars:function(a){d||c(z(a))}}}var J=g.$$minErr("$sanitize"),y=/^<\s*([\w:-]+)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*>/,x=/^<\s*\/\s*([\w:-]+)[^>]*>/,
E=/([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,I=/^</,H=/^<\s*\//,F=/\x3c!--(.*?)--\x3e/g,w=/<!DOCTYPE([^>]*?)>/i,G=/<!\[CDATA\[(.*?)]]\x3e/g,M=/^((ftp|https?):\/\/|mailto:|tel:|#)/i,K=/([^\#-~| |!])/g,u=h("area,br,col,hr,img,wbr");m=h("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr");n=h("rp,rt");var t=g.extend({},n,m),r=g.extend({},m,h("address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul")),
s=g.extend({},n,h("a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var")),v=h("script,style"),B=g.extend({},u,r,s,t),C=h("background,cite,href,longdesc,src,usemap"),L=g.extend({},C,h("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,span,start,summary,target,title,type,valign,value,vspace,width")),
q=document.createElement("pre");g.module("ngSanitize",[]).value("$sanitize",function(a){var d=[];D(a,A(d));return d.join("")});g.module("ngSanitize").filter("linky",function(){var a=/((ftp|https?):\/\/|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>]/,d=/^mailto:/;return function(c,k){if(!c)return c;var b,f=c,e=[],l=A(e),h,m,n={};g.isDefined(k)&&(n.target=k);for(;b=f.match(a);)h=b[0],b[2]==b[3]&&(h="mailto:"+h),m=b.index,l.chars(f.substr(0,m)),n.href=h,l.start("a",n),l.chars(b[0].replace(d,"")),l.end("a"),
f=f.substring(m+b[0].length);l.chars(f);return e.join("")}})})(window,window.angular);
//# sourceMappingURL=angular-sanitize.min.js.map

angular.module('fundoo.services', []).factory('createDialog', ["$document", "$compile", "$rootScope", "$controller", "$timeout",
  function ($document, $compile, $rootScope, $controller, $timeout) {
    var defaults = {
      id: null,
      template: null,
      templateUrl: null,
      title: 'Default Title',
      backdrop: true,
      success: {label: 'OK', fn: null},
      cancel: {label: 'Close', fn: null},
      controller: null, //just like route controller declaration
      backdropClass: "modal-backdrop",
      footerTemplate: null,
      modalClass: "modal",
      css: {
        top: '100px',
        left: '30%',
        margin: '0 auto'
      }
    };
    var body = $document.find('body');

    return function Dialog(templateUrl/*optional*/, options, passedInLocals) {

      // Handle arguments if optional template isn't provided.
      if(angular.isObject(templateUrl)){
        passedInLocals = options;
        options = templateUrl;
      } else {
        options.templateUrl = templateUrl;
      }

      options = angular.extend({}, defaults, options); //options defined in constructor

      var key;
      var idAttr = options.id ? ' id="' + options.id + '" ' : '';
      var defaultFooter = '<button class="btn" ng-click="$modalCancel()">{{$modalCancelLabel}}</button>' +
        '<button class="btn btn-primary" ng-click="$modalSuccess()">{{$modalSuccessLabel}}</button>';
      var footerTemplate = '<div class="modal-footer">' +
        (options.footerTemplate || defaultFooter) +
        '</div>';
      var modalBody = (function(){
        if(options.template){
          if(angular.isString(options.template)){
            // Simple string template
            return '<div class="modal-body">' + options.template + '</div>';
          } else {
            // jQuery/JQlite wrapped object
            return '<div class="modal-body">' + options.template.html() + '</div>';
          }
        } else {
          // Template url
          return '<div class="modal-body" ng-include="\'' + options.templateUrl + '\'"></div>'
        }
      })();
      //We don't have the scope we're gonna use yet, so just get a compile function for modal
      var modalEl = angular.element(
        '<div class="' + options.modalClass + ' fade"' + idAttr + '>' +
          '  <div class="modal-header">' +
          '    <button type="button" class="close" ng-click="$modalCancel()">&times;</button>' +
          '    <h2>{{$title}}</h2>' +
          '  </div>' +
          modalBody +
          footerTemplate +
          '</div>');

      for(key in options.css) {
        modalEl.css(key, options.css[key]);
      }

      var backdropEl = angular.element('<div ng-click="$modalCancel()">');
      backdropEl.addClass(options.backdropClass);
      backdropEl.addClass('fade in');

      var handleEscPressed = function (event) {
        if (event.keyCode === 27) {
          scope.$modalCancel();
        }
      };

      var closeFn = function () {
        body.unbind('keydown', handleEscPressed);
        modalEl.remove();
        if (options.backdrop) {
          backdropEl.remove();
        }
      };

      body.bind('keydown', handleEscPressed);

      var ctrl, locals,
        scope = options.scope || $rootScope.$new();

      scope.$title = options.title;
      scope.$modalClose = closeFn;
      scope.$modalCancel = function () {
        var callFn = options.cancel.fn || closeFn;
        callFn.call(this);
        scope.$modalClose();
      };
      scope.$modalSuccess = function () {
        var callFn = options.success.fn || closeFn;
        callFn.call(this);
        scope.$modalClose();
      };
      scope.$modalSuccessLabel = options.success.label;
      scope.$modalCancelLabel = options.cancel.label;
      
      if (options.controller) {
        locals = angular.extend({$scope: scope}, passedInLocals);
        ctrl = $controller(options.controller, locals);
        // Yes, ngControllerController is not a typo
        modalEl.contents().data('$ngControllerController', ctrl);
      }

      $compile(modalEl)(scope);
      $compile(backdropEl)(scope);
      body.append(modalEl);
      if (options.backdrop) body.append(backdropEl);

      $timeout(function () {
        modalEl.addClass('in');
      }, 200);
    };
  }]);
angular.module('XSockets', []).factory("xsocket", function ($q, $rootScope) {

    var isConnected, listeners = {}, socket, queued = [];

    var Listener = (function () {
        function Listener(fn) {
            this._a = fn;
        }
        Listener.prototype.process = function (fn) {
            this._a = fn;
            return this;
        };

        Listener.prototype.invoke = function (a) {
            this._a(a);
            return this;
        };
        return Listener;
    })();

    function bind(eventName) {
        socket.on(eventName, function (a) {
            $rootScope.$apply(function () {
                listeners[eventName].invoke(a);
            });
        });
    }
    function publish(topic, data) {
        if (isConnected || typeof (socket) === "undefined") {
            socket.trigger(topic, data);
        } else {
            queued.push({ t: topic, d: data || {} });
        }
    }
    function subscribe(topic) {
        if (!listeners.hasOwnProperty(topic)) {
            listeners[topic] = new Listener();
            bind(topic, listeners[topic]);
            return listeners[topic];
        }
        return listeners[topic];
    };

    var connect = function (url) {
        var deferred = $q.defer();
        socket = new XSockets.WebSocket(url);
        socket.on(XSockets.Events.open, function (conn) {
            $rootScope.$apply(function () {
                deferred.resolve(conn);
            });
        });
        return deferred.promise;
    };


    connect("ws://take65-v2.local.netbiis.com:4502/Chat").then(function (ctx) {
        isConnected = true;
        queued.forEach(function (msg, i) {
            publish(msg.t, msg.d);
        });
        queued = [];
    });

    return {
        isConnected: isConnected,
        subscribe: subscribe,
        publish: publish
    };
});
(function (ng, _) {
  'use strict';

  var
    underscoreModule = ng.module('angular-underscore', []),
    utilsModule = ng.module('angular-underscore/utils', []),
    filtersModule = ng.module('angular-underscore/filters', []);

  // begin custom _

  function propGetterFactory(prop) {
    return function(obj) {return obj[prop];};
  }

  _._ = _;

  // Shiv "min", "max" ,"sortedIndex" to accept property predicate.
  _.each(['min', 'max', 'sortedIndex'], function(fnName) {
    _[fnName] = _.wrap(_[fnName], function(fn) {
      var args = _.toArray(arguments).slice(1);

      if(_.isString(args[2])) {
        // for "sortedIndex", transmuting str to property getter
        args[2] = propGetterFactory(args[2]);
      }
      else if(_.isString(args[1])) {
        // for "min" or "max", transmuting str to property getter
        args[1] = propGetterFactory(args[1]);
      }

      return fn.apply(_, args);
    });
  });

  // Shiv "filter", "reject" to angular's built-in,
  // and reserve underscore's feature(works on obj).
  ng.injector(['ng']).invoke(['$filter', function($filter) {
    _.filter = _.select = _.wrap($filter('filter'), function(filter, obj, exp) {
      if(!(_.isArray(obj))) {
        obj = _.toArray(obj);
      }

      return filter(obj, exp);
    });

    _.reject = function(obj, exp) {
      // use angular built-in negated predicate
      if(_.isString(exp)) {
        return _.filter(obj, '!' + exp);
      }

      var diff = _.bind(_.difference, _, obj);

      return diff(_.filter(obj, exp));
    };
  }]);

  // end custom _


  // begin register angular-underscore/utils

  _.each(_.methods(_), function(methodName) {
    function register($rootScope) {$rootScope[methodName] = _.bind(_[methodName], _);}

    _.each([
      underscoreModule,
      utilsModule,
      ng.module('angular-underscore/utils/' + methodName, [])
      ], function(module) {
        module.run(['$rootScope', register]);
    });
  });

  // end register angular-underscore/utils


  // begin register angular-underscore/filters

  var
    adapList = [
      ['map', 'collect'],
      ['reduce', 'inject', 'foldl'],
      ['reduceRight', 'foldr'],
      ['find', 'detect'],
      ['filter', 'select'],
      'where',
      'findWhere',
      'reject',
      'invoke',
      'pluck',
      'max',
      'min',
      'sortBy',
      'groupBy',
      'countBy',
      'shuffle',
      'toArray',
      'size',
      ['first', 'head', 'take'],
      'initial',
      'last',
      ['rest', 'tail', 'drop'],
      'compact',
      'flatten',
      'without',
      'union',
      'intersection',
      'difference',
      ['uniq', 'unique'],
      'zip',
      'object',
      'indexOf',
      'lastIndexOf',
      'sortedIndex',
      'keys',
      'values',
      'pairs',
      'invert',
      ['functions', 'methods'],
      'pick',
      'omit',
      'tap',
      'identity',
      'uniqueId',
      'escape',
      'result',
      'template'
    ];

  _.each(adapList, function(filterNames) {
    if(!(_.isArray(filterNames))) {
      filterNames = [filterNames];
    }

    var
      filter = _.bind(_[filterNames[0]], _),
      filterFactory = function() {return filter;};

    _.each(filterNames, function(filterName) {
      _.each([
        underscoreModule,
        filtersModule,
        ng.module('angular-underscore/filters/' + filterName, [])
        ], function(module) {
          module.filter(filterName, filterFactory);
      });
    });
  });

  // end register angular-underscore/filters

}(angular, _));

'use strict';

/* Directives */
var blurFocusDirective = function () {
    return {
        restrict: 'E',
        require: '?ngModel',
        link: function (scope, elm, attr, ctrl) {
            if (!ctrl) {
                return;
            }

            elm.on('focus', function () {
                elm.addClass('has-focus');

                scope.$apply(function () {
                    ctrl.hasFocus = true;
                });
            });

            elm.on('blur', function () {
                elm.removeClass('has-focus');
                elm.addClass('has-visited');

                scope.$apply(function () {
                    ctrl.hasFocus = false;
                    ctrl.hasVisited = true;
                });
            });

            elm.closest('form').on('submit', function () {
                elm.addClass('has-visited');

                scope.$apply(function () {
                    ctrl.hasFocus = false;
                    ctrl.hasVisited = true;
                });
            });

        }
    };
};

var LoadBehaviorCaller = [];
angular.module('App.directives', [])
    .directive('input', blurFocusDirective)
    .directive('select', blurFocusDirective)

    .directive('appVersion', ['version', function (version) {
        return function (scope, elm, attrs) {
            elm.text(version);
        };
    }])
    .directive('dashboxes', ['$timeout', function ($timeout) { // Diretiva que é executada após ser carregado cada box
        return {
            restrict: 'A',
            link: function ($scope, element, attrs) {
                $scope.$on('dataloaded', function () {
                    
                    // Verifica se já executou esta função no elemento do scope atual
                    $timeout(function () { // You might need this timeout to be sure its run after DOM render.
                        // Carrega as funções de data-fn no elemento
                        // Realinha box
                        if (LoadBehaviorCaller['dataload-' + attrs.widget] == undefined) {
                            LoadBehaviorCaller['dataload-' + attrs.widget] = setTimeout(function () {
                                //$('body').trigger('realignBoxes');
                                NB.LoadBehavior(element);
                            }, 700);
                        }
                    }, 100, false);
                });
            }
        };
    }])
    .directive('filterDash', ['filter', function (filter) {
        return {
            restrict: 'A',
            controller: function ($scope, $attrs, filter) {
                $scope.$on('handleBroadcast', function () {
                    $scope.filter.key = filter;
                });
            }
        };
    }])
    .directive('loadbehavior', ['$timeout', function ($timeout) {
        // Runs during compile
        return {
            restrict: 'A',
            link: function ($scope, element, attrs) {
                $scope.$on('dataloaded', function () {
                    // Verifica se já executou esta função no elemento do scope atual
                    $timeout(function () { // You might need this timeout to be sure its run after DOM render.
                        // Carrega as funções de data-fn no elemento
                        NB.LoadBehavior(element);
                    }, 0, false);
                });
            }
        };
    }])
    .directive('resizecolorbox', ['$timeout', function ($timeout) {
        // Runs during compile
        return {
            restrict: 'A',
            link: function ($scope, element, attrs) {
                $scope.$on('dataloaded', function () {
                    // Verifica se já executou esta função no elemento do scope atual
                    $timeout(function () { // You might need this timeout to be sure its run after DOM render.
                        // Resize no colorbox
                        if (attrs.resizecolorbox === 'false') {
                            $.colorbox.resize();
                        } else {
                            var objWidth = (element.innerWidth() > 0) ? { width: element.innerWidth() + 10 } : {};
                            $.colorbox.resize(objWidth);
                        }
                    }, 200, false);
                });
            }
        };
    }])
    .directive('ngopenpop', ['$http', '$compile', '$parse', '$rootScope', '$timeout', function ($http, $compile, $parse, $rootScope, $timeout) {
        return {
            restrict: 'A',
            link: function ($scope, element, attrs, ngModel) {
                element.off('click.ngopenpop').on('click.ngopenpop', function () {
                    if ($rootScope.widgets != undefined) {
                        $rootScope.widgets.attrsClick = attrs;
                    }
                    document.body.scrollTop = document.documentElement.scrollTop = 0;

                    $http.get(attrs.ngopenpop + '?m='+ ((new Date()).getMilliseconds()), { cache: false })
                        .success(function (data, status, headers, config) {
                            $('#modalSliderAjax').html($compile(data)($scope));
                            $scope.$watch('$compile', function () {
                                $timeout(function () {
                                    NB.LoadBehavior($('#modalSliderAjax')); 
                                    $.colorbox.resize();
                                }, 10, false);
                            });
                        })
                        .error(function (data, status, headers, config) {

                        });
                });
            }
        };
    }])
    .directive('nglogged', [function () {
        return {
            restrict: 'A',
            link: function ($scope, element, attrs) {
                $scope.$watch('reloadHome', function () {
                    if ($scope.reloadHome)
                        window.location.href = '/';
                });
            }
        };
    }])
    .directive('alignboxes', ['$timeout', function ($timeout) {
        return {
            restrict: 'A',
            link: function ($scope, element, attrs) {
                $scope.$on('dataloaded', function () {
                    // Verifica se já executou esta função no elemento do scope atual
                    $timeout(function () { // You might need this timeout to be sure its run after DOM render.
                        var $els = element.find(attrs.alignboxes);
                        var _maxHeight = 0;
                        $els.height('auto').each(function () {
                            var _thisHeight = $(this).height();

                            if (_thisHeight === 0) {
                                _thisHeight = $(this).find('label').height();
                            }

                            if (_maxHeight < _thisHeight)
                                _maxHeight = _thisHeight;
                        });

                        $els.height(_maxHeight);
                    }, 200, false);
                });
            }
        };
    }])
    .directive('checkUrl', [function () {
        return {
            restrict: 'A',
            require: '?ngModel',
            link: function ($scope, element, attrs, ngModelCtrl) {
                if (!ngModelCtrl) {
                    return;
                }

                var pattern = /((ftp|http|https):\/\/)/;
                element.on({
                    blur: function () {
                        regUrl($(this));
                    },
                    'keydown keypress': function () {
                        try{
                            if (event.which === 13) {
                                regUrl($(this));
                            }
                        } catch (e) { }
                    }
                });

                var regUrl = function (el) {
                    var val = el.val();
                    if (val !== '' && !pattern.test(val)) {
                        el.val('http://' + val);
                        $scope.$apply(function () {
                            ngModelCtrl.$setViewValue('http://' + val);
                        });
                    }
                };
            }
        };
    }])
    .directive('loading', [function () {
        return {
            restrict: 'A',
            replace: true,
            templateUrl: '/Templates/Load.html',
            link: function ($scope, element, attrs) {
                var parent = element.parent();
                var parentPosition = parent.css('position') || parent.addClass('pos-relative');

                $scope.$on('dataloaded', function () {
                    var parent = element.parent();
                    var parentPosition = parent.css('position') || 'static';

                    if (parentPosition === 'static')
                        parent.addClass('pos-relative');
                });
            }
        };
    }])
    // Direcitve for enter action in elements are not tags form
    .directive('ngEnter', [function () {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                element.find('input, textarea, select').bind("keydown keypress", function (event) {
                    if (event.which === 13) {
                        scope.$apply(function () {
                            scope.$eval(attrs.ngEnter);
                        });

                        event.preventDefault();
                    }
                });
            }
        };
    }])
    // Direcitve for close buttons of colorbox
    .directive('colorboxClose', [function () {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                element.on('click', function (e) {
                    e.preventDefault();
                    $.colorbox.close();
                    //alert('directive close colorbox');
                });
            }
        };
    }])
    // Direcitve for close colorbox action
    .directive('closeColorbox', [function () {
        return {

            restrict: 'A',
            link: function ($scope, element, attrs) {
                $scope.$on('closeColorbox', function () {
                    $.colorbox.close();
                });
            }
        };
    }])
    // Directive for decide if use target = blank or open in lightbox
    .directive('ngTarget', ['$rootScope', '$timeout', function ($rootScope, $timeout) {
        return {
            restrict: 'A',
            link: function ($scope, element, attrs) {
                element.on('click.blank', '.openIframe', function () {
                    var $window = $(window);
                    if ($rootScope.currentExternalWindows == undefined)
                        $rootScope.currentExternalWindows = [];

                    var top;
                    var myNav = navigator.userAgent.toLowerCase();
                    if ((myNav.indexOf('msie') != -1)){
                        top = window.screenY + 480; //IE
                    }else{
                        top = window.screenY + 180
                    }

                    var new_window = window.open($(this).attr('href'), '', 'menubar=yes,toolbar=yes,scrollbars=yes,width=' + window.innerWidth + ',height=' + (window.innerHeight * 0.75) + ',top=' + top + ',left=' + window.screenX, '');
                    $rootScope.currentExternalWindows.push(new_window);
                    waitUser();
                    return false;
                });
            }
        };
    }])
    // Directive for update time and display in page of minute for minute
    .directive('currentTime', ['$timeout', function ($timeout) {
        return {
            restrict: 'A',
            link: function (scope) {
                var dateTime = $timeout(function refreshDate() {
                    scope.currentTime = moment().format('dddd, MMMM D, YYYY h:mm A');
                    dateTime = $timeout(refreshDate, 30000);
                }, 0, false);
            }
        };
    }])


    .directive('pwCheck', [function () {
        return {
            require: 'ngModel',
            link: function (scope, elem, attrs, ctrl) {
                var firstPassword = '#' + attrs.pwCheck;
                elem.add(firstPassword).on('keyup', function () {
                    scope.$apply(function () {
                        ctrl.$setValidity('pwmatch', elem.val() === $(firstPassword).val());
                    });
                });
            }
        }
    }])

    .directive("passwordMatch", function () {
        return {
            require: "ngModel",
            restrict: "A",
            scope: true,
            link: function (scope, element, attrs, ctrl) {
                var checker = function () {
                    var e1 = scope.$eval(attrs.ngModel);
                    var e2 = scope.$eval(attrs.passwordMatch);
                    return e1 == e2;
                };
                scope.$watch(checker, function (n) {
                    ctrl.$setValidity("passwordMatch", n);
                });
            }
        };
    })

    .directive('ensureUniqueEmail', ['$http', function ($http) {
        return {
            strict: 'A',
            require: 'ngModel',
            scope: {
                unique: '=unique',
                requiredEmail: '='
            },
            link: function ($scope, ele, attrs, ngModel) {
                $scope.unique = {};
                ngModel.$setValidity('unique', true);
                if (ngModel.$modelValue !== '') {
                    $http.post('/REST/User/Check', { email: ngModel.$modelValue })
                        .success(function (data, status, headers, cfg) {
                            $scope.unique.status = data.status;
                            if (data.status) {
                                ngModel.$setValidity('unique', true);
                            } else {
                                ngModel.$setValidity('unique', false);
                            }
                        })
                        .error(function (data, status, headers, cfg) {
                            $scope.unique = data;
                            ngModel.$setValidity('unique', false);
                        });
                }
                ele.on({
                    blur: function () {
                        if (!ngModel || !ele.val()) return;
                        if (ngModel.$modelValue && ngModel.$pristine) {
                            $scope.unique = {
                                response: '',
                                status: true
                            }
                            ngModel.$setValidity('unique', true);
                            return;
                        }

                        if (!ngModel.$error.required && !ngModel.$error.$email) {
                            $scope.unique = {                                
                                response: 'Verifying email...',
                                status: true
                            };
                            $.colorbox.resize();
                            $scope.model = ngModel.$modelValue;
                            $http.post('/REST/User/Check', { email: ngModel.$modelValue })
                                .success(function (data, status, headers, cfg) {
                                    $scope.unique.status = data.status;

                                    if (data.status) {
                                        if (data.response == "SAME") {
                                            ngModel.$setValidity('unique', true);
                                            $scope.unique.response = '';
                                        } else {
                                            ngModel.$setValidity('unique', true);
                                            $scope.unique.response = 'Email available';
                                        }
                                    } else {
                                        ngModel.$setValidity('unique', false);
                                        $scope.unique.response = 'Email already registered';
                                    }
                                    $.colorbox.resize();
                                })
                                .error(function (data, status, headers, cfg) {
                                    $scope.unique = data;
                                    ngModel.$setValidity('unique', false);
                                });
                        } else {
                            ngModel.$setValidity('unique', false);
                        }
                    },
                    focus: function () {
                        if ($scope.unique) $scope.unique.response = '';
                    }
                });
            }
        };
    }])

    .directive('ngEqual', ['$http', function ($http) {
        return {
            require: 'ngModel',
            scope: {
                inputEqual: '=inputEqual'
            },
            link: function ($scope, ele, attrs, c) {
                c.$setValidity('equal', false);
                ele.on('blur keydown keyup', function () {
                    verifyEqual();
                });
                var verifyEqual = function () {
                    if (c.$modelValue !== $scope.inputEqual)
                        c.$setValidity('equal', false);
                    else
                        c.$setValidity('equal', true);
                };
            }
        };
    }])

    .directive('colorboxCloseReload', [function () {
        return {
            restrict: 'A',
            link: function () {
                $(document).on('cbox_closed', function () {
                    window.location.href = '/';
                });
            }
        };
    }])

    .directive('colorboxCloseClean', ['$rootScope', function ($rootScope) {
        return {
            restrict: 'A',
            link: function ($scope, ele, attrs) {
                $(document).on('cbox_closed.clean', function () {
                    $rootScope[attrs.colorboxCloseClean] = undefined;
                    $(this).off('cbox_closed.clean');
                });
            }
        };
    }])

    // Animate tab for open and close. Best pratice for animations
    .directive('animateTab', [function () {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                //console.log(attrs);

                var el = $(attrs.elAnimate),
                    action = {};

                action.open = function () {
                    el.removeClass('close');//.animate({ left: attrs.elOpen });

                    //if (el.hasClass('aside-box'))
                        //el.find('.btn-close-aside-box').html('Close X');

                };
                action.close = function () {
                    el.addClass('close');//.animate({ left: attrs.elClose });
                    //if (el.hasClass('aside-box'))
                        //el.find('.btn-close-aside-box').html('Open');
                };

                //if(el.hasClass('close'))
                //    action.close();
                //else
                //    action.open();

                element.on('click', function (e) {
                    e.preventDefault();

                    if (el.hasClass('close'))
                        action.open();
                    else
                        action.close();
                });

                //$(window).scroll(function () {
                //    action.close();
                //});

                $('.wrap, footer.main').on('click', function (e) {
                    if (e.target != undefined && e.target.attributes["class"] != undefined && e.target.attributes["class"].nodeValue == 'icon icon-remove-red')
                        e.stopPropagation();
                    else
                        action.close();
                }).on('click', '.aside-box', function (e) {
                    e.stopPropagation();
                });
            }
        };
    }])

     .directive('placeholder', function($timeout){
         if (!$.browser.msie || $.browser.version >= 10) {
             return {};
         }
         return {
             link: function(scope, elm, attrs){
                 if (attrs.type === 'password') {
                     elm.attr('placeholder', '');
                     return;
                 }
                 $timeout(function () {
                     if (elm.val() != '' && elm.val() != null) return;
                     elm.val(attrs.placeholder).focus(function(){
                         if ($(this).val() == $(this).attr('placeholder')) {
                             $(this).val('');
                         }
                     }).blur(function(){
                         if ($(this).val() == '') {
                             $(this).val($(this).attr('placeholder'));
                         }
                     });
                 });
             }
         }
     })


    .directive('ngRepeatFinished', function ($timeout) {
        return {
            restrict: 'A',
            link: function (scope, element, attr) {
                if (scope.$last === true) {
                    $timeout(function () {
                        scope.$emit('ngRepeatFinished');
                    });
                }
            }
        }
    })

    // Carousel
    .directive('ngCarousel', ['$compile', function ($compile) {
        return {
            restrict: 'A',
            link: function ($scope, element, attrs) {

                // callCarousel
                $scope.$on('callCarousel', function () {
                    $scope.$watch('$compile', function () {
                        element.bxSlider({
                            slideWidth: 280,
                            pager: false,
                            minSlides: 2,
                            maxSlides: 3,
                            moveSlides: 1,
                            slideMargin: 14,
                            infiniteLoop: false,
                            hideControlOnEnd: true//,
                            //onSliderLoad: function () {                                
                            //$('.bx-prev').addClass('icon-arrow-left-blue');
                            //$('.bx-next').addClass('icon-arrow-right-blue');
                            //}                            
                        });
                        // ie nao addclass no onSliderLoad
                        $('.bx-prev').addClass('icon-arrow-left-blue');
                        $('.bx-next').addClass('icon-arrow-right-blue');
                    });
                });


                // callCarouselFbPhoto
                $scope.$on('callCarouselFbPhoto', function () {
                    $scope.$watch('$compile', function () {
                        //element.lemmonSlider({
                        //    infinite: true
                        //});
                        element.cycle();
                    });
                });

                // callCarouselFbPhotoDetail
                $scope.$on('callCarouselFbPhotoDetail', function () {
                    $scope.$watch('$compile', function () {
                        element.bxSlider({
                            //slideWidth: 140,
                            pager: false,
                            //minSlides: 4,
                            //maxSlides: 7,
                            //moveSlides: 3,
                            infiniteLoop: false,
                            hideControlOnEnd: true//,
                            //onSliderLoad: function () {                                
                            //$('.bx-prev').addClass('icon-arrow-left-blue');
                            //$('.bx-next').addClass('icon-arrow-right-blue');
                            //}                            
                        });
                        // ie nao addclass no onSliderLoad
                        $('.bx-prev').addClass('icon-arrow-left-blue'); 
                        $('.bx-next').addClass('icon-arrow-right-blue');
                    });
                });

            }
        };
    }])
;
var replaceString = function (str, args) {
    return str.replace(/\{{(\w+)\}}/g, function (s, key) {
        return args[key] || s;
    });
};

// Calcula tamanho do box com padding e margens
var calcRealBox = function($el) {
    var elSize = {
        height: $el.outerHeight() + parseInt($el.css('margin-top'), 10) + parseInt($el.css('margin-bottom'), 10) + parseInt($el.css('border-top-width'), 10) + parseInt($el.css('border-bottom-width'), 10),
        widht: $el.outerWidth() + parseInt($el.css('margin-left'), 10) + parseInt($el.css('margin-right'), 10) + parseInt($el.css('border-left-width'), 10) + parseInt($el.css('border-right-width'), 10)
    };

    if ($el.css('display') !== 'none')
        return elSize;
    else
        return { height: 0, width: 0 };
};

// Scrolla o box para a esquerda
var scrollToLeft = function ($box, offsetLeft) {
    $box.stop(true, false).animate({
        scrollLeft: offsetLeft
    }, 500);
};

// Retorna a diferenca entre duas datas conforme o tipo solicitado (month/day/year hh:mm:ss)
var datediff = function (fromDate, toDate, interval) {
    var second = 1000, minute = second * 60, hour = minute * 60, day = hour * 24, week = day * 7;
    fromDate = new Date(fromDate);
    toDate = new Date(toDate);
    var timediff = toDate - fromDate;
    if (isNaN(timediff)) return NaN;
    switch (interval) {
        case "years": return toDate.getFullYear() - fromDate.getFullYear();
        case "months": return (
                        (toDate.getFullYear() * 12 + toDate.getMonth()) -
                        (fromDate.getFullYear() * 12 + fromDate.getMonth())
                    );
        case "weeks": return Math.floor(timediff / week);
        case "days": return Math.floor(timediff / day);
        case "hours": return Math.floor(timediff / hour);
        case "minutes": return Math.floor(timediff / minute);
        case "seconds": return Math.floor(timediff / second);
        default: return undefined;
    }
};


//Transforma o segundos em formato de horario 
var convertTime = function(sec) {
    var sec_numb = parseInt(sec, 10);
    var hours = Math.floor(sec_numb / 3600);
    var minutes = Math.round((sec_numb - (hours * 3600)) / 60);
    var seconds = sec_numb - (hours * 3600) - (minutes * 60);
    
    if (hours < 10) { hours = "0" + hours; }
    if (minutes < 10) { minutes = "0" + minutes; }
    if (seconds < 10) { seconds = "0" + seconds; }
    
    var time;
    time = (hours != "00")? hours + 'h ': '';
    time += (minutes != "00")? minutes + 'min': '';
    return time;
};

//Transforma hora em segundos ex(05:20:15)
var converHourToSec = function (hour) {
    var time = hour.split(':');
    var sec = (+time[0]) * 60 * 60 + (+time[1]) * 60 + (+time[2]);

    return sec;
};

//Transforma segundo em data completa
var converToDate = function (secs) {
    var t = new Date();
    t.setTime(secs*1000);
    return t;
};

// Função está sendo usada no backend
var triggerClick = function (elem) {
    $(function () {
        $(elem).trigger('click');
    });
};

/****/
/** Funcao para placeholder em browser antigos **/
/****/
var add = function() {
    if ($(this).val() === '') {
        $(this).val($(this).attr('placeholder')).addClass('placeholder');
    }
};

var remove = function() {
    if ($(this).val() === $(this).attr('placeholder')) {
        $(this).val('').removeClass('placeholder');
    }
};
var placeHolder = function () {
    // Create a dummy element for feature detection
    if (!('placeholder' in $('<input>')[0])) {

        // Select the elements that have a placeholder attribute
        $('input[placeholder], textarea[placeholder]').not('input[type=password]').blur(add).focus(remove).each(add);

        // Remove the placeholder text before the form is submitted
        $('form').submit(function () {
            $(this).find('input[placeholder], textarea[placeholder]').not('input[type=password]').each(remove);
        });
    }
    //Função que retorna os valores default dos campos input do formulário
    $('form').find('input[type=password][placeholder]').each(function (i) {
        var $this = $(this),
			valPlaceholder = $this.attr('placeholder'),
			idPlaceholder = "placeholder" + i,
			$label = $("<label class='placeholder show' id='" + idPlaceholder + "'>" + valPlaceholder + "</label>");
        if (valPlaceholder !== '') {
            $this.before($label).addClass(idPlaceholder).css({ position: 'relative', zIndex: 1 }).on({
                'focus setVal': function () {
                    $label.hide().removeClass('show');
                },
                'blur removeVal': function (e) {
                    if (!$label.hasClass('show') && $this.val() === '') {
                        $label.show().addClass('show');
                    }
                }
            });

            if ($label.height() < 1)
                $label.height(17);
            $label.css({
                color: $this.css('color'),
                marginTop: parseInt($this.height() - $label.height(), 10) / 2,
                marginLeft: $this.css('padding-left'),
                fontSize: $this.css('font-size'),
                height: $label.height(),
                left: 0,
                position: 'absolute',
                overflow: 'hidden',
                cursor: 'text',
                zIndex: 3
            }).data({
                width: $label.width()
            }).on('click', function () {
                $this.focus();
            });

            if ($this.val() !== '')
                $label.css({ width: 0 }).removeClass('show');

        }
    });
};
/****/
/** FIM - Funcao para placeholder em browser antigos **/
/****/

// Trigger click caso haja hash na página
var clickHash = function () {
    var hash = window.location.hash;

    if (typeof hash !== 'undefined') {
        var elem = $(hash);

        if (elem.length > 0)
            elem.trigger('click');
    }
};

var waitUser = function () {
    if ($(".take-me-home").hasClass("hide")) {
        $(".take-me-home").removeClass("hide");
        $(".take-me-home-background").removeClass("hide");
    }
}

$(function () {
    if (!Modernizr.placeholder)
        placeHolder();


    document.onreadystatechange = function () {
        if (document.readyState == "complete") {
            clickHash();
        }
    };

    


    //$('form')[0].reset();
});

var NB = window.NB || {};
NB.Behaviors = {};
NB.Lang = {};
NB.Breakpoints = {
    //small: 450,
    //large: 758
    small: 767,
    large: 768
};
NB.searchGoogle = false;

var instantFn = function (el) {
    var that = $(el);
    var behaviors = that.attr('data-fn');

    $.each(behaviors.split(" "), function (index, behaviorName) {
        try {
            var BehaviorsClass = NB.Behaviors[behaviorName];
            var initializedBehavior = new BehaviorsClass(that);
            that.data('inst' + behaviorName, initializedBehavior);
        }
        catch (e) {
            console.log(el);
            console.log('Erro', e);
            // Nenhuma operação
        }
    });
}

NB.LoadBehavior = function (context) {

    if (context === undefined)
        context = $(document);

    if (typeof context.data('fn') !== 'undefined')
        instantFn(context);

    context.find('*[data-fn]').each(function (i) {
        instantFn(this);
    });
};

NB.instant = function (that, behaviorName) {
    try {
        var BehaviorsClass = NB.Behaviors[behaviorName];
        var initializedBehavior = new BehaviorsClass(that);
        that.data('inst' + behaviorName, initializedBehavior);
    }
    catch (e) {
        console.log(this);
        console.log('Erro', e);
        // Nenhuma operação
    }
};

NB.onReady = function () {
    //NB.Lang = lang;
    //if (Modernizr.borderradius)
    //    NB.loadCss('/Css/Border.css');

    NB.LoadBehavior();

    if ($.browser.msie)
        $('html').addClass('ie' + $.browser.version);

    if (!Modernizr.placeholder)
        $('input, textarea').placeholder();

    //$('form').on('submit', function (e) {
    //    e.preventDefault();
    //});

};

var ie = false;
$(document).ready(function () {
    NB.onReady();
});
NB.Behaviors.colorbox = function (that) {

    //console.log(that);

    var param = that.data('param') || {};
    var methods = this;
    param.loadingIco = param.loadingIco || 'white';
    param.type = param.type || 'inline';
    param.onComplete = param.onComplete || function () { };

    this.init = function () {
        this.colorbox();
    };

    this.colorbox = function () {
        $.colorbox.settings.close = NB.Lang.Close;
        param.close = param.close || NB.Lang.Close;
        param.closeButton = (typeof param.closeButton !== undefined) ? param.closeButton : true;
        param.allowClose = (typeof param.allowClose !== undefined) ? param.allowClose : true;
        
        param.width = param.width || 'auto';
        param.height = param.height || 'auto';
        param.className = param.className || 'box-white';
        param.action = param.action || false;
        param.resizeBoxLightbox = param.resizeBoxLightbox || false;

        that.on('click', function () {
            if (param.action === 'close') {
                $.colorbox.close();
            }
        });

        methods[param.type]();
    };
    
    this.simple = function () {
        var html = '<h2>' + param.title + '</h2>' + param.content;
        that.colorbox({
            html: html,
            //open: true,
            width: param.width,
            height: param.height,
            className: param.className,
            loadingIco: param.loadingIco,
            close: param.close,
            opacity: 0.8,
            onComplete: function () {
                //if (param.height == 'auto' || param.width == 'auto')
                $.colorbox.resize();
                NB.LoadBehavior($('#colorbox'));
                param.onComplete();
            }
        });
    };

    this.inline = function () {

        that.off('click.colorbox').on('click.colorbox', function (e) {
            e.preventDefault();
            //alert(param.width);
            //alert(param.onComplete);
            $.colorbox({
                inline: true,
                className: param.className,
                href: param.href || that.attr('href'),
                closeButton: param.closeButton,
                escKey: param.allowClose,
                overlayClose: param.allowClose,
                height: param.height,
                width: param.width,
                close: param.close,
                opacity: 0.8,
                scrolling: false,
                scrollTop: true,
                onComplete: function () {
                    param.onComplete();
                }
            });
        });
    };

    this.iframe = function () {
        that.off('click.colorbox').on('click.colorbox', function(e) {
            e.preventDefault();
            if (!that.hasClass('openIframe')) {
                document.body.scrollTop = document.documentElement.scrollTop = 0;
                $.colorbox({
                    iframe: true,
                    className: param.className,
                    height: param.height,
                    width: param.width,
                    href: param.href || $(this).attr('href'),
                    close: param.close,
                    closeButton: param.closeButton,
                    opacity: 0.8,
                    onComplete: function () {
                        if (param.height == 'auto' || param.width == 'auto')
                            $.colorbox.resize();
                        NB.LoadBehavior($('#colorbox'));
                        param.onComplete();
                    }
                });
            }
        });
    };

    this.ajax = function () {
        that.colorbox({
            className: param.className,
            height: param.height,
            width: param.width,
            close: param.close,
            closeButton: param.closeButton,
            opacity: 0.8,
            onComplete: function () {
                //$.colorbox.resize();
                NB.LoadBehavior($('#colorbox'));
                param.onComplete();
                if (param.resizeBoxLightbox) {
                    $.colorbox.resize({
                        width: $('#colorbox').find('.box-lightbox').outerWidth() + 10
                    });
                }
            }
        });
    };
    this.param = param;
    methods.init();
};
NB.Behaviors.colorbox.param = 'title, content';
NB.Behaviors.formValidation = function (that) {
    var param = this.param = that.data('param') || {};
    var methods = this;

    this.init = function () {
        that.data('formvalid', false).find('[data-valid="submit"]').on('click', function (e) {
            //e.preventDefault();
            var valid = true;
            var amsg = [];
            var $this = $(this);

            that.find('[data-valid][data-valid!="submit"]').each(function () {
                var $this = $(this);
                var fnValid;

                var validform = $this.validform({
                    //border: '1px solid red',
                    parent: true,
                    errorClass: 'error'
                }).data('plugin_validform');

                if ($this.data('valid') === 'equal')
                    fnValid = validform[$this.data('valid')](that.find('[data-group="' + $this.data('group') + '"]').not($this));
                else if ($this.data('valid') === 'checked')
                    fnValid = validform[$this.data('valid')](that.find('[data-group="' + $this.data('group') + '"]'));
                else
                    fnValid = validform[$this.data('valid')]();

                if (!fnValid) {
                    valid = false;
                    var sClass = $this.data('elem') || '';

                    validform.invalid(sClass);

                    // Reune em amsg o nome dos campos inválidos
                    if (typeof $this.data('name') !== 'undefined' && $.inArray($this.data('name'), amsg) === -1)
                        amsg.push($this.data('name'));
                }
            });



            // Cria mensagem de feedback
            if (typeof param.error !== 'undefined' && !valid) {
                var msg = '',
                    error = '';
                
                if (typeof param.msgtype !== 'undefined' && param.msgtype == 'summary') {
                    msg = '<ul>';

                    for (error in amsg)
                        msg += '<li>' + amsg[error] + '</li>';

                    msg += '</ul>';
                    that.find(param.error).html(msg).fadeIn(400);
                } else {
                    msg = 'Please fill out the required fields: ';
                    for (error in amsg)
                        msg += amsg[error] + ', ';

                    msg = msg.substring(0, msg.length - 2) + '.';

                    that.find(param.error).text(msg).fadeIn(400);
                }

            }
            that.data('formvalid', valid);
            if (valid && $this.data('trigger'))
                $this.trigger($this.data('trigger'));

            if (param.colorbox)
                $.colorbox.resize();

            return valid;
        });
    };

    methods.init();
};

NB.Behaviors.formValidation.version = '0.1';

NB.Behaviors.menu = function (that) {
    var param = that.data('param') || {};
    var methods = this;
    this.miniMenu = $('#miniMenu');

    this.init = function () {
        /* Open e close menu */
        that.find('#openMenu').on('click', function (e) {
            e.preventDefault();
            methods.openMenu();
        });
        $('#closeMenu').on('click', function (e) {
            e.preventDefault();
            methods.closeMenu();
        });
        /* End Open e close menu */
        $('#searchOpen').on('click', function (e) {
            e.preventDefault();
            $('section.search').slideToggle(500, function () {
                $(window).trigger('resize');
            });
        });

        $('body').on('openpop', function () {
            methods.closeMenu();
        });
    }
    this.openMenu = function () {
        var $mainLinks = $('.main-links');
        methods.miniMenu.css('top', $mainLinks.offset().top + $mainLinks.outerHeight()).fadeIn(800).animate({
            right: 0
        }, { queue: false, duration: 500 });
    };
    this.closeMenu = function () {
        methods.miniMenu.fadeOut(500).animate({
            right: '-100%'
        }, { queue: false, duration: 800 });
    };

    methods.init();
}
NB.Behaviors.menu.param = '';
NB.Behaviors.openPop = function (that) {
    //console.log(that.data('param'));
    //console.log(this);
    var param = that.data('param') || {};
    var methods = this;
    this.init = function () {
        if ($(window).width() <= NB.Breakpoints.small) {
            // Breakpoint de tablet para mobile
            this.callSlider();
        } else if ($(window).width() <= NB.Breakpoints.large) {
            // Breakpoint de desk para tablet
            this.callSlider();
        } else {
            // Breakpoint de desk
            this.callColorbox();
        }
    };
    this.callColorbox = function () {
        if (typeof that.data('callColorbox') === 'undefined' || !that.data('callColorbox')) {
            $('#cboxOverlay').height($('.wrap').height());
            that.data('callSlider', false).data('callColorbox', true).off('click', methods.openSlider);
            $('body').trigger('removeSlider');
            NB.instant(that, 'colorbox');
            $(document).off('cbox_closed.openpop').on('cbox_closed.openpop', function () {
                $('#modalSliderAjax').empty();
            });
        }
    };
    this.callSlider = function () {
        that.colorbox.close();
        that.colorbox.remove();
        that.off('click.colorbox');
        if (typeof that.data('callSlider') === 'undefined' || !that.data('callSlider')) {
            that.removeData('instcolorbox').data('callColorbox', false);
            that.data('callSlider', true).on('click', methods.openSlider);
        }
    };

    this.openSlider = function (e) {
        e.preventDefault();
        if (!$(that).hasClass('openIframe')) {
            NB.instant(that, 'openSlider');
            $('body').trigger('openpop');
        }
    };
    
    $(window).on('resize', function () {
        methods.init();
    });
    methods.init();
};
NB.Behaviors.openPop.param = '';
$('html, body').css({
    overflow: 'auto',
    height: 'auto',
    width: 'auto'
});
NB.Behaviors.openSlider = function (that) {
    var param = that.data('param') || {};
    var methods = this;
    var $modalSlider = $('#modalSlider');
    var $modalSliderAjax = $modalSlider.find('#modalSliderAjax');
    var $htmlBody = $('html, body');

    this.init = function () {
        //this.getAjax();
        methods.openSlider();
        $htmlBody.on({
            removeSlider: function () {
                methods.closeSlider();
            },
            resizeModalBox: function () {
                methods.resizeModal();
            }
        });

        $modalSlider.find('#closeModal').on('click', function (e) {
            e.preventDefault();
            methods.closeSlider();
        });

        $(window).on('resize.openSlider', function () {
            methods.resizeModal();
        });
    };
    this.getAjax = function () {
        //methods.openSlider();
        if (param.type === 'iframe') // {
            $modalSliderAjax.html('<iframe frameborder="0" src="' + that.attr('href') + '" class="cboxIframe" allowfullscreen="true" webkitallowfullscreen="true" mozallowfullscreen="true"></iframe>');
    };
    this.openSlider = function () {
        methods.removeScrollPage();
        setTimeout(function () {
            try { window.scrollTo(0); } catch (e) { };
            document.body.scrollTop = document.documentElement.scrollTop = 0;
            $htmlBody.css({
                display: 'none'
            });
            $modalSlider.show();
            //$modalSliderAjax.height($modalSlider.height() - $modalSlider.find('#closeModal').height());
            $modalSliderAjax.height('100%');
            methods.getAjax();
            $htmlBody.css({
                display: 'block'
            });
        }, 100);

        
        
        
        //$("body,html,document").scrollTop($("#map_canvas").offset().top);
        /*
        alert(window.pageYOffset);
        alert(top.window.pageYOffset);
        alert(document.getElementById('miniMenu'));
        alert(document.getElementById('miniMenu').pageYOffset);
        alert(document.getElementById('miniMenu').scrollTop);
        alert($("#miniMenu").offset().top);
        alert(document.body.scrollTop);
        
        */

        //document.body.scrollTop = document.documentElement.scrollTop = 0;
        
        //methods.removeScrollPage();

/*
        $modalSlider.show();
        $modalSliderAjax.height($modalSlider.height() - $modalSlider.find('#closeModal').height());
        methods.getAjax();*/

        /*
        $modalSlider.stop(true, true).css({
            top: NB.window.sizes.height,
            height: NB.window.sizes.height
        }).show().animate({
            top: 0,
            opacity: 1
        }, 700, function () {
            $modalSliderAjax.height($modalSlider.height() - $modalSlider.find('#closeModal').height());
            methods.getAjax();
        });*/
    };
    this.closeSlider = function () {
        $modalSlider.hide().removeAttr('style');
        $modalSliderAjax.html('').removeAttr('style');
        methods.returnScrollPage();
        $(window).off('resize.openSlider');
        $htmlBody.off('removeSlider resizeModalBox');

        /*
        $modalSlider.stop(true, false).animate({
            top: NB.window.sizes.height,
            opacity: 0
        }, 1000, function () {
            $modalSlider.hide().removeAttr('style');
            $modalSliderAjax.html('').removeAttr('style');
            methods.returnScrollPage();
            $(window).off('resize.openSlider');
            $htmlBody.off('removeSlider resizeModalBox');
        });*/
    };

    this.resizeModal = function () {
        $modalSlider.stop(true, true).css('height', NB.window.sizes.height);
        $modalSliderAjax.height($modalSlider.height() - $modalSlider.find('#closeModal').height());
    };

    this.removeScrollPage = function () {
        $htmlBody.css({
            overflow: 'hidden',
            height: '100%',
            width: '100%'
        });
    };

    this.returnScrollPage = function () {
        $htmlBody.css({
            overflow: 'auto',
            height: 'auto',
            width: 'auto'
        });
    };

    methods.init();
};
NB.Behaviors.openSlider.param = '';
NB.Behaviors.placeholder = function (that) {
    var param = that.data('param') || {};
    var methods = this;

    this.init = function () {
        if (!Modernizr.placeholder)
            $('input, textarea').placeholder();
    };

    methods.init();
};
NB.Behaviors.placeholder.param = '';
//NB.Behaviors.resize = function (that) {
//    var param = that.data('param') || {};
//    var methods = this;

//    // Função para usar no resize de acordo com cada breakpoint
//    //this.resize = function () {
//    //    if ($(window).width() <= NB.Breakpoints.small) {
//    //        // Breakpoint de tablet para mobile
//    //        //this.alignBoxes(false);
//    //        //this.searchSize(false);
//    //        return false;
//    //    } else if ($(window).width() <= NB.Breakpoints.large + 16) {
//    //        // Breakpoint de desk para tablet
//    //        //this.alignBoxes(2);
//    //        //this.searchSize(false);
//    //    } else {
//    //        // Breakpoint de desk
//    //        //this.alignBoxes(3);
//    //        //this.searchSize(true);
//    //    }
//    //};

//    /* Calcula se qual elemento deve conter espaçamento 
//        e qual não deve conter de acordo com o tamanhos dos boxes 
//        passado por space e da resolução;
//        Alinha os boxes horizontalmente
//        */
//    //this.alignBoxes = function (maxCont) {
//    //    var cont = 0,
//    //        maxHeight = 0,
//    //        line = 0,
//    //        lineHeight = [];
//    //        $boxColumns = $('.content-main').find('.box-column');

//    //    if(!maxCont) {
//    //        $boxColumns.height('auto').find('.content').height('auto');
//    //        return false;
//    //    }
//    //    // Percorre nos boxes dizendo cada linha que pertencem e tira o espaço do primeiro elemento
//    //    $boxColumns.removeClass('no-gutter').each(function() {
//    //        var $this = $(this);
//    //        // Zera a altura deste box
//    //        $this.height('auto').find('.content').height('auto');

//    //        // Verifica se é o primeiro box
//    //        if (cont === 0) {
//    //            $this.addClass('no-gutter'); // retira margin-left
//    //            if ($this.attr('data-type') != '3' && $this.attr('data-type') != '6') {
//    //                maxHeight = $this.height(); // define maxHeight com valor da altura do primeiro box
//    //            }
//    //            line++; // line recebe o número da nova linha
//    //        }

            
//    //        cont += parseInt($this.attr('data-space'), 10); // Conta os elementos da linha
//    //        maxHeight = (maxHeight < $this.height() && ($this.attr('data-type') != '3' && $this.attr('data-type') != '6')) ? $this.height() : maxHeight; // verifica se este box é maior do que a altura dos anteriores
            
//    //        $this.attr('data-line', line); // diz a qual linha pertence esse box

//    //        if(cont >= maxCont || $this.next().length < 1 ||(parseInt($this.next().attr('data-space')) + cont > maxCont)) { // verifica se está no ultimo box da linha ou se o próximo box cabe na linha deste mesmo
//    //            lineHeight[line] = maxHeight; // insere no array lineHeight, na posição da linha, o tamanho do maior box pertencente a linha
//    //            cont = 0; // zera cont
//    //            maxHeight = 0; // zera maxHeight
//    //        }
//    //    })
//    //        .each(function() {
//    //            var $this = $(this),
//    //                newHeight = lineHeight[$this.attr('data-line')];
//    //            newHeight = (newHeight <= 0) ? 200 : newHeight; //min value 200, never zero

//    //            $this.height(newHeight) // percorre em todos os boxes mudando a altura de todos de acordo com o maior desta linha armazenado no array
//    //                .find('.content').height(newHeight - calcRealBox($this.find('header.nv-1')).height - calcRealBox($this.find('footer.nv-1')).height - 1);
//    //        });
//    //};

//    // Calcula o tamanho que deve ser o box de busca
//    //this.searchSize = function(wide) {
//    //    var filled = 0;
//    //    var $search = that.find('.search');
//    //    var $input = $search.find('input[type=text]');

//    //    if(wide) {
//    //        $search.find('.btn-search').each(function() {
//    //            var $this = $(this);
//    //            filled += $this.outerWidth() + parseInt($this.css('margin-left'), 10) + parseInt($this.css('margin-right'), 10);
//    //        });
//    //        $input.outerWidth($search.width() - filled - 5);
//    //    } else {
//    //        $input.width($search.width() - parseInt($input.css('padding-left'), 10) * 2 - parseInt($input.css('border-left-width'), 10) * 2);
//    //    }
//    //};

//    this.init = function () {
//        var $window = $(window);
//        NB.window = NB.window || {};

//        $window.on('load resize', function () {
//            clearTimeout(window.resizeEvt);
//            window.resizeEvt = setTimeout(function()
//            {
//                //methods.resize();
//                NB.window.sizes = {
//                    width: $window.width(),
//                    height: $window.height()
//                };
//            }, 250);
//        });
//        $('body').on('realignBoxes', function () {
//            //methods.resize();
//            NB.window.sizes = {
//                width: $window.width(),
//                height: $window.height()
//            };
//        });

//        //setTimeout(function () {
//            //methods.resize();
//        //}, 1000);
//    };

//    methods.init();
//};
//NB.Behaviors.resize.param = '';
NB.Behaviors.resizeLetter = function (that) {
    var param = that.data('param') || {};
    var methods = this;
    param.coeff = param.coeff || 1;

    this.init = function () {
        if (typeof that.data('sizes') !== 'undefined')
            return false;

        that.data({
            sizes: {
                min: that.css('font-size'),
                max: 2,
                actual: 0
            }
        }).find(param.plus).on('click', function (e) {
            e.preventDefault();
            if (that.data('sizes').actual === that.data('sizes').max)
                return false;

            that.data('sizes').actual++;
            that.css('font-size', '+=' + param.coeff);
            $('body').trigger('realignBoxes');
        }).end()
            .find(param.minus).on('click', function (e) {
                e.preventDefault();
                if (parseInt(that.data('sizes').min) < parseInt(that.css('font-size'))) {
                    that.css('font-size', '-=' + param.coeff);
                    that.data('sizes').actual--;
                } else {
                    that.css('font-size', that.data('sizes').min);
                    that.data('sizes').actual = 0; 
                }
                $('body').trigger('realignBoxes');
            });
    };

    methods.init();
};
NB.Behaviors.resizeLetter.param = '';
NB.Behaviors.styleForms = function (that) {
    var param = that.data('param') || {};

    if ($.browser.msie && $.browser.version < 8) {
        this.reinitForm = function () { };
    } else {
        this.reinitForm = function () {
            styleForm.reformSelect(that);
            //styleForm.reloadSelect(that);
        }

        if(window['styleForm'] !== 'undefined')
            styleForm.init(that);
    }
}

NB.Behaviors.styleForms.version = '0.1';
'use strict';

/* Services */

// Demonstrate how to register services
// In this case it is a simple value service.
angular.module('App.services', [])
    .value('version', '0.1')
    .factory('filterDash', function ($rootScope) {
        var filter = {};

        filter.key = '';

        filter.prepForBroadcast = function (val) {
            this.key = val;
            this.broadcastItem();
        };

        filter.broadcastItem = function () {
            $rootScope.$broadcast('handleBroadcast');
        };

        return filter;
    });

    /**
    * CollectionManager.js
    * - manage a collection of items
    * - rearrange items if buffered or cycle
    * - the service is just a wrapper around a non-angular collection manager
    **/

    /*.service('CollectionManager', [function () {

        function CollectionManager(options) {
            var initial = {
                bufferSize: 0,
                bufferStart: 0,
                buffered: false,
                cycle: false,
                cycleOffset: 0,            // offset
                index: 0,                  // index relative to the original collection
                position: 0,               // position relative to the current elements
                items: [],                 // total collection
                cards: [],                 // bufered DOM collection
                updated: null,             // triggers DOM change
                debug: false
            };

            var i;
            if (options) for (i in options) initial[i] = options[i];
            for (i in initial) this[i] = initial[i];

            angular.extend(this, initial, options);

            this.init();

        }

        CollectionManager.prototype.log = function () {
            if (this.debug) {
                console.log.apply(console, arguments);
                // console.log('CollectionManager:', this);
            }
        };
        CollectionManager.prototype.getPositionFromIndex = function (index) {
            return (index + this.cycleOffset) % this.length();
        };

        CollectionManager.prototype.goToIndex = function (index, delayedUpdate) {
            // cap index
            index = Math.max(0, Math.min(index, this.getLastIndex()));
            if (this.updated && index === this.index) {
                this.log('skip position change(same)');
                return false;
            }
            var position = this.getPositionFromIndex(index);
            return this.goTo(position, delayedUpdate);
        };

        CollectionManager.prototype.goTo = function (position, delayedUpdate) {
            this.log('goto start', position, delayedUpdate);

            if (this.length() === 0) {
                this.log('empty, skip gotoIndex');
                return;
            }
            // cap position
            position = Math.max(0, Math.min(position, this.getLastIndex()));
            var cycled = false;
            if (this.cycle) {
                if (position === 0) {
                    // unshift
                    this.log('cycleAtBeginning', position);
                    this.cycleAtBeginning();
                    position = 1;
                    this.cycleOffset++;
                    cycled = true;
                } else if (position === this.getLastIndex()) {
                    // push
                    this.log('cycleAtEnd', position);
                    this.cycleAtEnd();
                    position--;
                    this.cycleOffset--;
                    cycled = true;
                }
                this.cycleOffset %= this.length();
            }

            this.position = Math.max(0, Math.min(position, this.getLastIndex()));

            var realIndex = (this.position - this.cycleOffset + this.length()) % this.length();
            this.index = Math.max(0, Math.min(realIndex, this.getLastIndex()));

            if (!delayedUpdate) {
                this.adjustBuffer();
            }
            if (!cycled) this.updated = new Date();

        };

        CollectionManager.prototype.next = function () {
            // go to next item
            if (this.cycle) {
                this.goTo((this.position + 1) % this.length());
            } else {
                this.goTo(Math.min(this.position + 1, this.getLastIndex()));
            }
        };
        CollectionManager.prototype.prev = function () {
            // go to prev item
            if (this.cycle) {
                this.goTo((this.position - 1 + this.length()) % this.length());
            } else {
                var prevIndex = (this.length() > 0) ? (Math.max(0, (this.position - 1) % this.length())) : 0;
                this.goTo(prevIndex);
            }
        };
        CollectionManager.prototype.setBufferSize = function (length) {
            this.log('setBufferSize', length);
            this.bufferSize = length;
            this.adjustBuffer();
        };
        CollectionManager.prototype.isBuffered = function () {
            return this.buffered;
        };
        CollectionManager.prototype.getRelativeIndex = function () {
            var relativeIndex = Math.max(0, Math.min(this.getLastIndex(), this.position - this.bufferStart));
            return relativeIndex;
        };
        CollectionManager.prototype.adjustBuffer = function () {
            // adjust buffer start position
            var maxBufferStart = (this.getLastIndex() + 1 - this.bufferSize) % this.length();
            this.log('maxBufferStart', maxBufferStart);
            this.bufferStart = Math.max(0, Math.min(maxBufferStart, this.position - 1));
            this.cards = this.items.slice(this.bufferStart, this.bufferStart + this.bufferSize);
            this.log('adjustBuffer from', this.bufferStart, 'to', this.bufferStart + this.bufferSize);
        };
        CollectionManager.prototype.length = function () {
            return this.items.length;
        };
        CollectionManager.prototype.getLastIndex = function () {
            var lastIndex = Math.max(0, this.length() - 1);
            return lastIndex;
        };
        CollectionManager.prototype.init = function () {
            //this.log('init', this);
            this.setBufferSize(this.isBuffered() ? this.bufferSize : this.length());
            if (this.length() > 0) this.goToIndex(this.index);
        };
        CollectionManager.prototype.setItems = function (items, reset) {
            this.log('setItems', items, reset);
            if (reset) {
                this.index = 0;
                this.position = 0;
            }
            this.items = items || [];  // prevent internal errors when items is undefined
            this.init();
        };
        CollectionManager.prototype.cycleAtEnd = function () {
            // extract first item and put it at end
            this.push(this.items.shift());
        };
        CollectionManager.prototype.push = function (slide, updateIndex) {
            // insert item(s) at end
            this.log('push item(s)', slide, updateIndex);
            // if (this.items.indexOf(slide)>-1) {
            //     this.log('item already present, skip it');
            //     return;
            // }
            this.items.push(slide);
            if (updateIndex) {
                // no need to change index when appending items
                this.adjustBuffer();
                this.updated = new Date();
            }
            if (!this.buffered) {
                this.bufferSize++;
            }
        };
        CollectionManager.prototype.unshift = function (slide, updateIndex) {
            // insert item(s) at beginning
            this.log('unshift item(s)', slide, updateIndex);
            // if (this.items.indexOf(slide)>-1) {
            //     this.log('item already present, skip it');
            //     return;
            // }
            this.items.unshift(slide);
            if (!this.buffered) {
                this.bufferSize++;
            }
            if (updateIndex) {
                this.position++;
                this.adjustBuffer();
                this.updated = new Date();
            }
        };
        CollectionManager.prototype.cycleAtBeginning = function () {
            // extract last item and put it at beginning
            this.unshift(this.items.pop());
        };
        return {
            create: function (options) {
                return new CollectionManager(options);
            }
        };
    }]);*/
var hello = function (e) {
    return hello.use(e)
};
hello.utils = {
    extend: function (e) {
        for (var t = Array.prototype.slice.call(arguments, 1), n = 0; n < t.length; n++) {
            var o = t[n];
            if (e instanceof Object && o instanceof Object && e !== o)
                for (var i in o) e[i] = hello.utils.extend(e[i], o[i]);
            else e = o
        }
        return e
    }
}, hello.utils.extend(hello, {
    settings: {
        redirect_uri: window.location.href.split("#")[0] + "redirect.html",//window.location.href.split("#")[0],
        response_type: "token",
        display: "popup",
        state: "",
        oauth_proxy: "https://auth-server.herokuapp.com/proxy",
        timeout: 2e4,
        default_service: null,
        force: !0
    },
    service: function (e) {
        return "undefined" != typeof e ? this.utils.store("sync_service", e) : this.utils.store("sync_service")
    },
    services: {},
    use: function (e) {
        var t = this.utils.objectCreate(this);
        return t.settings = this.utils.objectCreate(this.settings), e && (t.settings.default_service = e), t.utils.Event.call(t), t
    },
    init: function (e, t) {
        var n = this.utils;
        if (!e) return this.services;
        for (var o in e) e.hasOwnProperty(o) && "object" != typeof e[o] && (e[o] = {
            id: e[o]
        });
        n.extend(this.services, e);
        for (o in this.services) this.services.hasOwnProperty(o) && (this.services[o].scope = this.services[o].scope || {});
        return t && (n.extend(this.settings, t), "redirect_uri" in t && (this.settings.redirect_uri = n.url(t.redirect_uri).href)), this
    },
    login: function () {
        var e = this.use(),
            t = e.utils,
            n = t.args({
                network: "s",
                options: "o",
                callback: "f"
            }, arguments);
        e.args = n;
        var o, i = n.options = t.merge(e.settings, n.options || {});
        if (n.network = e.settings.default_service = n.network || e.settings.default_service, e.on("complete", n.callback), "string" != typeof n.network || !(n.network in e.services)) return e.emitAfter("error complete", {
            error: {
                code: "invalid_network",
                message: "The provided network was not recognized"
            }
        }), e;
        var a = e.services[n.network],
            r = !1,
            s = t.globalEvent(function (n) {
                var o;
                n ? (o = JSON.parse(n), hello.utils.store(o.network, o)) : o = {
                    error: {
                        code: "cancelled",
                        message: "The authentication was not completed"
                    }
                }, r = !0, o.error ? e.emit("complete error failed auth.failed", {
                    error: o.error
                }) : (t.store(o.network, o), e.emit("complete success login auth.login auth", {
                    network: o.network,
                    authResponse: o
                }))
            }),
            l = t.url(i.redirect_uri).href;
        n.qs = {
            client_id: a.id,
            response_type: a.oauth.response_type || i.response_type,
            redirect_uri: l,
            display: i.display,
            scope: "basic",
            state: {
                client_id: a.id,
                network: n.network,
                display: i.display,
                callback: s,
                state: i.state,
                redirect_uri: l,
                oauth_proxy: i.oauth_proxy
            }
        };
        var c = t.store(n.network),
            u = (i.scope || "").toString();
        if (u = (u ? u + "," : "") + n.qs.scope, c && "scope" in c && c.scope instanceof String && (u += "," + c.scope), n.qs.state.scope = hello.utils.unique(u.split(/[,\s]+/)).join(","), n.qs.scope = u.replace(/[^,\s]+/gi, function (t) {
            if (t in a.scope) return a.scope[t];
            for (var n in e.services) {
                var o = e.services[n].scope;
                if (o && t in o) return ""
        }
            return t
        }).replace(/[,\s]+/gi, ","), n.qs.scope = t.unique(n.qs.scope.split(/,+/)).join(a.scope_delim || ","), i.force === !1 && c && "access_token" in c && c.access_token && "expires" in c && c.expires > (new Date).getTime() / 1e3) {
            var f = t.diff(c.scope || [], n.qs.state.scope || []);
            if (0 === f.length) return e.emit("notice", "User already has a valid access_token"), e.emitAfter("complete success login", {
                network: n.network,
                authResponse: c
            }), e
        }
        if (n.qs.state.oauth = a.oauth, n.qs.state = JSON.stringify(n.qs.state), "login" in a && "function" == typeof a.login && a.login(n), 1 === parseInt(a.oauth.version, 10) ? o = t.qs(i.oauth_proxy, n.qs) : "none" === i.display && a.oauth.grant && c && c.refresh_token ? (n.qs.refresh_token = c.refresh_token, o = t.qs(i.oauth_proxy, n.qs)) : o = t.qs(a.oauth.auth, n.qs), e.emit("notice", "Authorization URL " + o), "none" === i.display) t.iframe(o);
        else if ("popup" === i.display) var d = hello.utils.popup(o, l, i.window_width || 800, i.window_height || 900),
        p = setInterval(function () {
            if ((!d || d.closed) && (clearInterval(p), !r)) {
                var t = {
                    code: "cancelled",
                    message: "Login has been cancelled"
                };
                d || (t = {
                    code: "blocked",
                    message: "Popup was blocked"
                }), e.emit("complete failed error", {
                    error: t,
                    network: n.network
                })
            }
        }, 100);
        else window.location = o;
        return e
    },
    logout: function () {
        var e = this.use(),
            t = e.utils,
            n = t.args({
                name: "s",
                options: "o",
                callback: "f"
            }, arguments);
        if (n.options = n.options || {}, e.on("complete", n.callback), n.name = n.name || e.settings.default_service, !n.name || n.name in e.services)
            if (n.name && t.store(n.name)) {
                var o = function (t) {
                    e.utils.store(n.name, ""), e.emitAfter("complete logout success auth.logout auth", hello.utils.merge({
                        network: n.name
                    }, t || {}))
                }, i = {};
                if (n.options.force) {
                    var a = e.services[n.name].logout;
                    if (a)
                        if ("function" == typeof a && (a = a(o)), "string" == typeof a) t.iframe(a), i.force = null, i.message = "Logout success on providers site was indeterminate";
                        else if (void 0 === a) return e
                }
                o(i)
            } else if (n.name) e.emitAfter("complete error", {
                error: {
                    code: "invalid_session",
                    message: "There was no session to remove"
                }
            });
            else {
                for (var r in e.services) e.services.hasOwnProperty(r) && e.logout(r);
                e.service(!1)
            } else e.emitAfter("complete error", {
                error: {
                    code: "invalid_network",
                    message: "The network was unrecognized"
                }
            });
        return e
    },
    getAuthResponse: function (e) {
        return e = e || this.settings.default_service, e && e in this.services ? this.utils.store(e) || null : (this.emit("complete error", {
            error: {
                code: "invalid_network",
                message: "The network was unrecognized"
            }
        }), null)
    },
    events: {}
}), hello.utils.extend(hello.utils, {
    qs: function (e, t) {
        if (t) {
            var n;
            for (var o in t)
                if (e.indexOf(o) > -1) {
                    var i = "[\\?\\&]" + o + "=[^\\&]*";
                    n = new RegExp(i), e = e.replace(n, "")
                }
        }
        return e + (this.isEmpty(t) ? "" : (e.indexOf("?") > -1 ? "&" : "?") + this.param(t))
    },
    param: function (e) {
        var t, n, o = {};
        if ("string" == typeof e) {
            if (n = e.replace(/^[\#\?]/, "").match(/([^=\/\&]+)=([^\&]+)/g))
                for (var i = 0; i < n.length; i++) t = n[i].match(/([^=]+)=(.*)/), o[t[1]] = decodeURIComponent(t[2]);
            return o
        }
        var a = e;
        o = [];
        for (var r in a) a.hasOwnProperty(r) && a.hasOwnProperty(r) && o.push([r, "?" === a[r] ? "?" : encodeURIComponent(a[r])].join("="));
        return o.join("&")
    },
    store: function (e) {
        var t = [e, window.sessionStorage],
            n = 0;
        for (e = t[n++]; e;) try {
            e.setItem(n, n), e.removeItem(n);
            break
        } catch (o) {
            e = t[n++]
        }
        return e || (e = {
            getItem: function (e) {
                e += "=";
                for (var t = document.cookie.split(";"), n = 0; n < t.length; n++) {
                    var o = t[n].replace(/(^\s+|\s+$)/, "");
                    if (o && 0 === o.indexOf(e)) return o.substr(e.length)
                }
                return null
            },
            setItem: function (e, t) {
                document.cookie = e + "=" + t
            }
        }),
        function (t, n) {
            var o = JSON.parse(e.getItem("hello")) || {};
            if (t && void 0 === n) return o[t] || null;
            if (t && null === n) try {
                delete o[t]
            } catch (i) {
                o[t] = null
            } else {
                if (!t) return o;
                o[t] = n
            }
            return e.setItem("hello", JSON.stringify(o)), o || null
        }
    }(window.localStorage),
    append: function (e, t, n) {
        var o = "string" == typeof e ? document.createElement(e) : e;
        if ("object" == typeof t)
            if ("tagName" in t) n = t;
            else
                for (var i in t)
                    if (t.hasOwnProperty(i))
                        if ("object" == typeof t[i])
                            for (var a in t[i]) t[i].hasOwnProperty(a) && (o[i][a] = t[i][a]);
                        else "html" === i ? o.innerHTML = t[i] : /^on/.test(i) ? o[i] = t[i] : o.setAttribute(i, t[i]);
        return "body" === n ? ! function r() {
            document.body ? document.body.appendChild(o) : setTimeout(r, 16)
        }() : "object" == typeof n ? n.appendChild(o) : "string" == typeof n && document.getElementsByTagName(n)[0].appendChild(o), o
    },
    iframe: function (e) {
        this.append("iframe", {
            src: e,
            style: {
                position: "absolute",
                left: "-1000px",
                bottom: 0,
                height: "1px",
                width: "1px"
            }
        }, "body")
    },
    merge: function () {
        var e = Array.prototype.slice.call(arguments);
        return e.unshift({}), this.extend.apply(null, e)
    },
    args: function (e, t) {
        var n = {}, o = 0,
            i = null,
            a = null;
        for (a in e)
            if (e.hasOwnProperty(a)) break;
        if (1 === t.length && "object" == typeof t[0] && "o!" != e[a])
            for (a in t[0])
                if (e.hasOwnProperty(a) && a in e) return t[0];
        for (a in e)
            if (e.hasOwnProperty(a))
                if (i = typeof t[o], "function" == typeof e[a] && e[a].test(t[o]) || "string" == typeof e[a] && (e[a].indexOf("s") > -1 && "string" === i || e[a].indexOf("o") > -1 && "object" === i || e[a].indexOf("i") > -1 && "number" === i || e[a].indexOf("a") > -1 && "object" === i || e[a].indexOf("f") > -1 && "function" === i)) n[a] = t[o++];
                else if ("string" == typeof e[a] && e[a].indexOf("!") > -1) return !1;
        return n
    },
    url: function (e) {
        if (e) {
            if (window.URL && URL instanceof Function && 0 !== URL.length) return new URL(e, window.location);
            var t = document.createElement("a");
            return t.href = e, t
        }
        return window.location
    },
    diff: function (e, t) {
        for (var n = [], o = 0; o < t.length; o++) -1 === this.indexOf(e, t[o]) && n.push(t[o]);
        return n
    },
    indexOf: function (e, t) {
        if (e.indexOf) return e.indexOf(t);
        for (var n = 0; n < e.length; n++)
            if (e[n] === t) return n;
        return -1
    },
    unique: function (e) {
        if ("object" != typeof e) return [];
        for (var t = [], n = 0; n < e.length; n++) e[n] && 0 !== e[n].length && -1 === this.indexOf(t, e[n]) && t.push(e[n]);
        return t
    },
    isEmpty: function (e) {
        if (!e) return !0;
        if (e && e.length > 0) return !1;
        if (e && 0 === e.length) return !0;
        for (var t in e)
            if (e.hasOwnProperty(t)) return !1;
        return !0
    },
    objectCreate: function () {
        function e() { }
        return Object.create ? Object.create : function (t) {
            if (1 != arguments.length) throw new Error("Object.create implementation only accepts one parameter.");
            return e.prototype = t, new e
        }
    }(),
    Event: function () {
        var e = /[\s\,]+/;
        return this.parent = {
            events: this.events,
            findEvents: this.findEvents,
            parent: this.parent,
            utils: this.utils
        }, this.events = {}, this.on = function (t, n) {
            if (n && "function" == typeof n)
                for (var o = t.split(e), i = 0; i < o.length; i++) this.events[o[i]] = [n].concat(this.events[o[i]] || []);
            return this
        }, this.off = function (e, t) {
            return this.findEvents(e, function (e, n) {
                t && this.events[e][n] !== t || (this.events[e][n] = null)
            }), this
        }, this.emit = function (e) {
            var t = Array.prototype.slice.call(arguments, 1);
            t.push(e);
            for (var n = function (n, o) {
                t[t.length - 1] = "*" === n ? e : n, this.events[n][o].apply(this, t)
            }, o = this; o && o.findEvents;) o.findEvents(e + ",*", n), o = o.parent;
            return this
        }, this.emitAfter = function () {
            var e = this,
                t = arguments;
            return setTimeout(function () {
                e.emit.apply(e, t)
            }, 0), this
        }, this.findEvents = function (t, n) {
            var o = t.split(e);
            for (var i in this.events)
                if (this.events.hasOwnProperty(i) && hello.utils.indexOf(o, i) > -1)
                    for (var a = 0; a < this.events[i].length; a++) this.events[i][a] && n.call(this, i, a)
        }, this
    },
    globalEvent: function (e, t) {
        return t = t || "_hellojs_" + parseInt(1e12 * Math.random(), 10).toString(36), window[t] = function () {
            try {
                bool = e.apply(this, arguments)
            } catch (n) {
                console.error(n)
            }
            if (bool) try {
                delete window[t]
            } catch (n) { }
        }, t
    },
    popup: function (e, t, n, o) {
        var i = document.documentElement,
            a = void 0 !== window.screenLeft ? window.screenLeft : screen.left,
            r = void 0 !== window.screenTop ? window.screenTop : screen.top,
            s = window.innerWidth || i.clientWidth || screen.width,
            l = window.innerHeight || i.clientHeight || screen.height,
            c = (s - n) / 2 + a,
            u = (l - o) / 2 + r,
            f = function (e) {
                var i = window.open(e, "_blank", "resizeable=true,height=" + o + ",width=" + n + ",left=" + c + ",top=" + u);
                if (i && i.addEventListener) {
                    var a = hello.utils.url(t),
                        r = a.origin || a.protocol + "//" + a.hostname;
                    i.addEventListener("loadstart", function (e) {
                        var t = e.url;
                        if (0 === t.indexOf(r)) {
                            var n = hello.utils.url(t),
                                o = {
                                    location: {
                                        assign: function (e) {
                                            i.addEventListener("exit", function () {
                                                setTimeout(function () {
                                                    f(e)
                                                }, 1e3)
                                            })
                                        },
                                        search: n.search,
                                        hash: n.hash,
                                        href: n.href
                                    },
                                    close: function () {
                                        i.close && i.close()
                                    }
                                };
                            hello.utils.responseHandler(o, window), o.close()
                        }
                    })
                }
                return i && i.focus && i.focus(), i
            };
        return -1 !== navigator.userAgent.indexOf("Safari") && -1 === navigator.userAgent.indexOf("Chrome") && (e = t + "#oauth_redirect=" + encodeURIComponent(encodeURIComponent(e))), f(e)
    },
    responseHandler: function (e, t) {
        function n(e, t, n) {
            if (a.store(e.network, e), !("display" in e && "page" === e.display)) {
                if (n) {
                    var i = e.callback;
                    try {
                        delete e.callback
                    } catch (r) { }
                    if (a.store(e.network, e), i in n) {
                        var s = JSON.stringify(e);
                        try {
                            n[i](s)
                        } catch (r) { }
                    }
                }
                o()
            }
        }

        function o() {
            try {
                e.close()
            } catch (t) { }
            e.addEventListener && e.addEventListener("load", function () {
                e.close()
            })
        }
        var i, a = this,
            r = e.location,
            s = function (t) {
                r.assign ? r.assign(t) : e.location = t
            };
        if (i = a.param(r.search), i && (i.code && i.state || i.oauth_token && i.proxy_url)) {
            var l = JSON.parse(i.state);
            i.redirect_uri = l.redirect_uri || r.href.replace(/[\?\#].*$/, "");
            var c = (l.oauth_proxy || i.proxy_url) + "?" + a.param(i);
            return void s(c)
        }
        if (i = a.merge(a.param(r.search || ""), a.param(r.hash || "")), i && "state" in i) {
            try {
                var u = JSON.parse(i.state);
                a.extend(i, u)
            } catch (f) {
                console.error("Could not decode state parameter")
            }
            if ("access_token" in i && i.access_token && i.network) i.expires_in && 0 !== parseInt(i.expires_in, 10) || (i.expires_in = 0), i.expires_in = parseInt(i.expires_in, 10), i.expires = (new Date).getTime() / 1e3 + (i.expires_in || 31536e3), n(i, e, t);
            else if ("error" in i && i.error && i.network) i.error = {
                code: i.error,
                message: i.error_message || i.error_description
            }, n(i, e, t);
            else if (i.callback && i.callback in t) {
                var d = "result" in i && i.result ? JSON.parse(i.result) : !1;
                t[i.callback](d), o()
            }
        } else if ("oauth_redirect" in i) return void s(decodeURIComponent(i.oauth_redirect))
    }
}), hello.utils.Event.call(hello), hello.subscribe = hello.on, hello.trigger = hello.emit, hello.unsubscribe = hello.off, hello.utils.responseHandler(window, window.opener || window.parent),
function (e) {
    var t = {}, n = {};
    e.on("auth.login, auth.logout", function (n) {
        n && "object" == typeof n && n.network && (t[n.network] = e.utils.store(n.network) || {})
    }),
    function o() {
        var i = (new Date).getTime() / 1e3,
            a = function (t) {
                e.emit("auth." + t, {
                    network: r,
                    authResponse: s
                })
            };
        for (var r in e.services)
            if (e.services.hasOwnProperty(r)) {
                if (!e.services[r].id) continue;
                var s = e.utils.store(r) || {}, l = e.services[r],
                    c = t[r] || {};
                if (s && "callback" in s) {
                    var u = s.callback;
                    try {
                        delete s.callback
                    } catch (f) { }
                    e.utils.store(r, s);
                    try {
                        window[u](s)
                    } catch (f) { }
                }
                if (s && "expires" in s && s.expires < i) {
                    var d = l.refresh || s.refresh_token;
                    !d || r in n && !(n[r] < i) ? d || r in n || (a("expired"), n[r] = !0) : (e.emit("notice", r + " has expired trying to resignin"), e.login(r, {
                        display: "none",
                        force: !1
                    }), n[r] = i + 600);
                    continue
                }
                if (c.access_token === s.access_token && c.expires === s.expires) continue;
                !s.access_token && c.access_token ? a("logout") : s.access_token && !c.access_token ? a("login") : s.expires !== c.expires && a("update"), t[r] = s, r in n && delete n[r]
            }
        setTimeout(o, 1e3)
    }()
}(hello), hello.api = function () {
    function e(e) {
        if (n.data = i.clone(a), "get" === n.method) {
            for (var r, s = /[\?\&]([^=&]+)(=([^&]+))?/gi; r = s.exec(e) ;) n.data[r[1]] = r[3];
            e = e.replace(/\?.*/, "")
        }
        var f = l[{
            "delete": "del"
        }[n.method] || n.method] || {}, d = f[e] || f["default"] || e,
            p = function (e) {
                e = e.replace(/\@\{([a-z\_\-]+)(\|.+?)?\}/gi, function (e, t, i) {
                    var a = i ? i.replace(/^\|/, "") : "";
                    return t in n.data ? (a = n.data[t], delete n.data[t]) : "undefined" == typeof i && o.emitAfter("error", {
                        error: {
                            code: "missing_attribute_" + t,
                            message: "The attribute " + t + " is missing from the request"
                        }
                    }), a
                }), e.match(/^https?:\/\//) || (e = l.base + e);
                var a = {}, r = function (r, s) {
                    r && ("function" == typeof r ? r(a) : i.extend(a, r));
                    var c = i.qs(e, a || {});
                    o.emit("notice", "Request " + c), t(n.network, c, n.method, n.data, l.querystring, s)
                };
                if (!i.isEmpty(n.data) && !("FileList" in window) && i.hasBinary(n.data)) return i.post(r, n.data, "form" in l ? l.form(n) : null, c), o;
                if ("delete" === n.method) {
                    var s = c;
                    c = function (e, t) {
                        s(!e || i.isEmpty(e) ? {
                            success: !0
                        } : e, t)
                    }
                }
                if ("withCredentials" in new XMLHttpRequest && (!("xhr" in l) || l.xhr && l.xhr(n, a))) {
                    var f = i.xhr(n.method, r, n.headers, n.data, c);
                    f.onprogress = function (e) {
                        o.emit("progress", e)
                    }, f.upload && (f.upload.onprogress = function (e) {
                        o.emit("uploadprogress", e)
                    })
                } else {
                    if (n.callbackID = i.globalEvent(), "jsonp" in l && l.jsonp(n, a), "api" in l && l.api(e, n, u && u.access_token ? {
                        access_token: u.access_token
                    } : {}, c)) return;
                    "post" === n.method ? (a.redirect_uri = o.settings.redirect_uri, a.state = JSON.stringify({
                        callback: n.callbackID
                    }), i.post(r, n.data, "form" in l ? l.form(n) : null, c, n.callbackID, o.settings.timeout)) : (i.extend(a, n.data), a.callback = n.callbackID, i.jsonp(r, c, n.callbackID, o.settings.timeout))
                }
            };
        "function" == typeof d ? d(n, p) : p(d)
    }

    function t(e, t, n, a, r, s) {
        var l = o.services[e],
            c = u ? u.access_token : null,
            f = l.oauth && 1 === parseInt(l.oauth.version, 10) ? o.settings.oauth_proxy : null;
        if (f) return void s(i.qs(f, {
            path: t,
            access_token: c || "",
            then: "get" === n.toLowerCase() ? "redirect" : "proxy",
            method: n,
            suppress_response_codes: !0
        }));
        var d = {
            access_token: c || ""
        };
        r && r(d), s(i.qs(t, d))
    }
    var n = this.utils.args({
        path: "s!",
        method: "s",
        data: "o",
        timeout: "i",
        callback: "f"
    }, arguments),
        o = this.use(),
        i = o.utils;
    o.args = n, n.method = (n.method || "get").toLowerCase();
    var a = n.data = n.data || {};
    o.on("complete", n.callback), n.path = n.path.replace(/^\/+/, "");
    var r = (n.path.split(/[\/\:]/, 2) || [])[0].toLowerCase();
    if (r in o.services) {
        n.network = r;
        var s = new RegExp("^" + r + ":?/?");
        n.path = n.path.replace(s, "")
    }
    n.network = o.settings.default_service = n.network || o.settings.default_service;
    var l = o.services[n.network];
    if (!l) return o.emitAfter("complete error", {
        error: {
            code: "invalid_network",
            message: "Could not match the service requested: " + n.network
        }
    }), o;
    n.timeout && (o.settings.timeout = n.timeout), o.emit("notice", "API request " + n.method.toUpperCase() + " '" + n.path + "' (request)", n);
    var c = function (t, i) {
        if (l.wrap && (n.path in l.wrap || "default" in l.wrap)) {
            var a = n.path in l.wrap ? n.path : "default",
                r = (new Date).getTime(),
                s = l.wrap[a](t, i, n);
            s && (t = s), o.emit("notice", "Processing took" + ((new Date).getTime() - r))
        }
        o.emit("notice", "API: " + n.method.toUpperCase() + " '" + n.path + "' (response)", t);
        var c = null;
        t && "paging" in t && t.paging.next && (c = function () {
            e((t.paging.next.match(/^\?/) ? n.path : "") + t.paging.next)
        }), o.emit("complete " + (!t || "error" in t ? "error" : "success"), t, c)
    };
    if (n.method in l && n.path in l[n.method] && l[n.method][n.path] === !1) return o.emitAfter("complete error", {
        error: {
            code: "invalid_path",
            message: "The provided path is not available on the selected network"
        }
    });
    var u = o.getAuthResponse(n.network);
    return e(n.path), o
}, hello.utils.extend(hello.utils, {
    isArray: function (e) {
        return "[object Array]" === Object.prototype.toString.call(e)
    },
    domInstance: function (e, t) {
        var n = "HTML" + (e || "").replace(/^[a-z]/, function (e) {
            return e.toUpperCase()
        }) + "Element";
        return t ? window[n] ? t instanceof window[n] : window.Element ? t instanceof window.Element && (!e || t.tagName && t.tagName.toLowerCase() === e) : !(t instanceof Object || t instanceof Array || t instanceof String || t instanceof Number) && t.tagName && t.tagName.toLowerCase() === e : !1
    },
    clone: function (e) {
        if ("nodeName" in e || this.isBinary(e)) return e;
        var t, n = {};
        for (t in e) n[t] = "object" == typeof e[t] ? this.clone(e[t]) : e[t];
        return n
    },
    xhr: function (e, t, n, o, i) {
        function a(e) {
            for (var t, n = {}, o = /([a-z\-]+):\s?(.*);?/gi; t = o.exec(e) ;) n[t[1]] = t[2];
            return n
        }
        var r = this;
        if ("function" != typeof t) {
            var s = t;
            t = function (e, t) {
                t(r.qs(s, e))
            }
        }
        var l = new XMLHttpRequest,
            c = !1;
        "blob" === e && (c = e, e = "GET"), e = e.toUpperCase(), l.onload = function () {
            var t = l.response;
            try {
                t = JSON.parse(l.responseText)
            } catch (n) {
                401 === l.status && (t = {
                    error: {
                        code: "access_denied",
                        message: l.statusText
                    }
                })
            }
            var o = a(l.getAllResponseHeaders());
            o.statusCode = l.status, i(t || ("DELETE" !== e ? {
                error: {
                    message: "Could not get resource"
                }
            } : {}), o)
        }, l.onerror = function () {
            var e = l.responseText;
            try {
                e = JSON.parse(l.responseText)
            } catch (t) { }
            i(e || {
                error: {
                    code: "access_denied",
                    message: "Could not get resource"
                }
            })
        };
        var u, f = {};
        if ("GET" === e || "DELETE" === e) r.isEmpty(o) || r.extend(f, o), o = null;
        else if (!(!o || "string" == typeof o || o instanceof FormData || o instanceof File || o instanceof Blob)) {
            var d = new FormData;
            for (u in o) o.hasOwnProperty(u) && (o[u] instanceof HTMLInputElement ? "files" in o[u] && o[u].files.length > 0 && d.append(u, o[u].files[0]) : o[u] instanceof Blob ? d.append(u, o[u], o.name) : d.append(u, o[u]));
            o = d
        }
        return t(f, function (t) {
            if (l.open(e, t, !0), c && ("responseType" in l ? l.responseType = c : l.overrideMimeType("text/plain; charset=x-user-defined")), n)
                for (var i in n) l.setRequestHeader(i, n[i]);
            l.send(o)
        }), l
    },
    jsonp: function (e, t, n, o) {
        var i, a, r = this,
            s = 0,
            l = document.getElementsByTagName("head")[0],
            c = {
                error: {
                    message: "server_error",
                    code: "server_error"
                }
            }, u = function () {
                s++ || window.setTimeout(function () {
                    t(c), l.removeChild(a)
                }, 0)
            }, f = r.globalEvent(function (e) {
                return c = e, !0
            }, n);
        if ("function" != typeof e) {
            var d = e;
            d = d.replace(new RegExp("=\\?(&|$)"), "=" + f + "$1"), e = function (e, t) {
                t(r.qs(d, e))
            }
        }
        e(function (e) {
            for (var t in e) e.hasOwnProperty(t) && "?" === e[t] && (e[t] = f)
        }, function (e) {
            a = r.append("script", {
                id: f,
                name: f,
                src: e,
                async: !0,
                onload: u,
                onerror: u,
                onreadystatechange: function () {
                    /loaded|complete/i.test(this.readyState) && u()
                }
            }), window.navigator.userAgent.toLowerCase().indexOf("opera") > -1 && (i = r.append("script", {
                text: "document.getElementById('" + f + "').onerror();"
            }), a.async = !1), o && window.setTimeout(function () {
                c = {
                    error: {
                        message: "timeout",
                        code: "timeout"
                    }
                }, u()
            }, o), l.appendChild(a), i && l.appendChild(i)
        })
    },
    post: function (e, t, n, o, i, a) {
        var r = this,
            s = document;
        if ("function" != typeof e) {
            var l = e;
            e = function (e, t) {
                t(r.qs(l, e))
            }
        }
        var c, u = null,
            f = [],
            d = 0,
            p = null,
            m = 0,
            h = function (e) {
                m++ || o(e)
            };
        r.globalEvent(h, i);
        var g;
        try {
            g = s.createElement('<iframe name="' + i + '">')
        } catch (v) {
            g = s.createElement("iframe")
        }
        if (g.name = i, g.id = i, g.style.display = "none", n && n.callbackonload && (g.onload = function () {
            h({
            response: "posted",
            message: "Content was posted"
        })
        }), a && setTimeout(function () {
            h({
            error: {
            code: "timeout",
            message: "The post operation timed out"
        }
        })
        }, a), s.body.appendChild(g), r.domInstance("form", t)) {
            for (u = t.form, d = 0; d < u.elements.length; d++) u.elements[d] !== t && u.elements[d].setAttribute("disabled", !0);
            t = u
        }
        if (r.domInstance("form", t))
            for (u = t, d = 0; d < u.elements.length; d++) u.elements[d].disabled || "file" !== u.elements[d].type || (u.encoding = u.enctype = "multipart/form-data", u.elements[d].setAttribute("name", "file"));
        else {
            for (p in t) t.hasOwnProperty(p) && r.domInstance("input", t[p]) && "file" === t[p].type && (u = t[p].form, u.encoding = u.enctype = "multipart/form-data");
            u || (u = s.createElement("form"), s.body.appendChild(u), c = u);
            var w;
            for (p in t)
                if (t.hasOwnProperty(p)) {
                    var y = r.domInstance("input", t[p]) || r.domInstance("textArea", t[p]) || r.domInstance("select", t[p]);
                    if (y && t[p].form === u) y && t[p].name !== p && (t[p].setAttribute("name", p), t[p].name = p);
                    else {
                        var b = u.elements[p];
                        if (w)
                            for (b instanceof NodeList || (b = [b]), d = 0; d < b.length; d++) b[d].parentNode.removeChild(b[d]);
                        w = s.createElement("input"), w.setAttribute("type", "hidden"), w.setAttribute("name", p), w.value = y ? t[p].value : r.domInstance(null, t[p]) ? t[p].innerHTML || t[p].innerText : t[p], u.appendChild(w)
                    }
                }
            for (d = 0; d < u.elements.length; d++) w = u.elements[d], w.name in t || w.getAttribute("disabled") === !0 || (w.setAttribute("disabled", !0), f.push(w))
        }
        u.setAttribute("method", "POST"), u.setAttribute("target", i), u.target = i, e({}, function (e) {
            u.setAttribute("action", e), setTimeout(function () {
                u.submit(), setTimeout(function () {
                    try {
                        c && c.parentNode.removeChild(c)
                    } catch (e) {
                        try {
                            console.error("HelloJS: could not remove iframe")
                        } catch (t) { }
                    }
                    for (var n = 0; n < f.length; n++) f[n] && (f[n].setAttribute("disabled", !1), f[n].disabled = !1)
                }, 0)
            }, 100)
        })
    },
    hasBinary: function (e) {
        for (var t in e)
            if (e.hasOwnProperty(t) && this.isBinary(e[t])) return !0;
        return !1
    },
    isBinary: function (e) {
        return e instanceof Object && (this.domInstance("input", e) && "file" === e.type || "FileList" in window && e instanceof window.FileList || "File" in window && e instanceof window.File || "Blob" in window && e instanceof window.Blob)
    },
    toBlob: function (e) {
        var t = /^data\:([^;,]+(\;charset=[^;,]+)?)(\;base64)?,/i,
            n = e.match(t);
        if (!n) return e;
        for (var o = atob(e.replace(t, "")), i = [], a = 0; a < o.length; a++) i.push(o.charCodeAt(a));
        return new Blob([new Uint8Array(i)], {
            type: n[1]
        })
    }
}),
function (e) {
    var t = e.api,
        n = e.utils;
    n.extend(n, {
        dataToJSON: function (e) {
            var t = this,
                n = window,
                o = e.data;
            if (t.domInstance("form", o) ? o = t.nodeListToJSON(o.elements) : "NodeList" in n && o instanceof NodeList ? o = t.nodeListToJSON(o) : t.domInstance("input", o) && (o = t.nodeListToJSON([o])), ("File" in n && o instanceof n.File || "Blob" in n && o instanceof n.Blob || "FileList" in n && o instanceof n.FileList) && (o = {
                file: o
            }), !("FormData" in n && o instanceof n.FormData))
                for (var i in o)
                    if (o.hasOwnProperty(i))
                        if ("FileList" in n && o[i] instanceof n.FileList) 1 === o[i].length && (o[i] = o[i][0]);
                        else {
                            if (t.domInstance("input", o[i]) && "file" === o[i].type) continue;
                            t.domInstance("input", o[i]) || t.domInstance("select", o[i]) || t.domInstance("textArea", o[i]) ? o[i] = o[i].value : t.domInstance(null, o[i]) && (o[i] = o[i].innerHTML || o[i].innerText)
                        }
            return e.data = o, o
        },
        nodeListToJSON: function (e) {
            for (var t = {}, n = 0; n < e.length; n++) {
                var o = e[n];
                !o.disabled && o.name && (t[o.name] = "file" === o.type ? o : o.value || o.innerHTML)
            }
            return t
        }
    }), e.api = function () {
        var e = n.args({
            path: "s!",
            method: "s",
            data: "o",
            timeout: "i",
            callback: "f"
        }, arguments);
        return e.data && n.dataToJSON(e), t.call(this, e)
    }
}(hello),
function () {
    function e(e) {
        return function () {
            var n = e.apply(this, arguments),
                o = t(function (e, t) {
                    n.on("success", e).on("error", t).on("*", function () {
                        var e = Array.prototype.slice.call(arguments);
                        e.unshift(e.pop()), i.emit.apply(i, e)
                    })
                }),
                i = hello.utils.Event.call(o.proxy);
            return i
        }
    }
    Function.prototype.bind || (Function.prototype.bind = function (e) {
        function t() { }
        if ("function" != typeof this) throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
        var n = [].slice,
            o = n.call(arguments, 1),
            i = this,
            a = function () {
                return i.apply(this instanceof t ? this : e || window, o.concat(n.call(arguments)))
            };
        return t.prototype = this.prototype, a.prototype = new t, a
    });
    var t = function () {
        var e = 0,
            t = 1,
            n = 2,
            o = function (t) {
                return this instanceof o ? (this.id = "Thenable/1.0.6", this.state = e, this.fulfillValue = void 0, this.rejectReason = void 0, this.onFulfilled = [], this.onRejected = [], this.proxy = {
                    then: this.then.bind(this)
                }, void ("function" == typeof t && t.call(this, this.fulfill.bind(this), this.reject.bind(this)))) : new o(t)
            };
        o.prototype = {
            fulfill: function (e) {
                return i(this, t, "fulfillValue", e)
            },
            reject: function (e) {
                return i(this, n, "rejectReason", e)
            },
            then: function (e, t) {
                var n = this,
                    i = new o;
                return n.onFulfilled.push(s(e, i, "fulfill")), n.onRejected.push(s(t, i, "reject")), a(n), i.proxy
            }
        };
        var i = function (t, n, o, i) {
            return t.state === e && (t.state = n, t[o] = i, a(t)), t
        }, a = function (e) {
            e.state === t ? r(e, "onFulfilled", e.fulfillValue) : e.state === n && r(e, "onRejected", e.rejectReason)
        }, r = function (e, t, n) {
            if (0 !== e[t].length) {
                var o = e[t];
                e[t] = [];
                var i = function () {
                    for (var e = 0; e < o.length; e++) o[e](n)
                };
                "object" == typeof process && "function" == typeof process.nextTick ? process.nextTick(i) : "function" == typeof setImmediate ? setImmediate(i) : setTimeout(i, 0)
            }
        }, s = function (e, t, n) {
            return function (o) {
                if ("function" != typeof e) t[n].call(t, o);
                else {
                    var i;
                    try {
                        i = e(o)
                    } catch (a) {
                        return void t.reject(a)
                    }
                    l(t, i)
                }
            }
        }, l = function (e, t) {
            if (e === t || e.proxy === t) return void e.reject(new TypeError("cannot resolve promise with itself"));
            var n;
            if ("object" == typeof t && null !== t || "function" == typeof t) try {
                n = t.then
            } catch (o) {
                return void e.reject(o)
            }
            if ("function" != typeof n) e.fulfill(t);
            else {
                var i = !1;
                try {
                    n.call(t, function (n) {
                        i || (i = !0, n === t ? e.reject(new TypeError("circular thenable chain")) : l(e, n))
                    }, function (t) {
                        i || (i = !0, e.reject(t))
                    })
                } catch (o) {
                    i || e.reject(o)
                }
            }
        };
        return o
    }();
    hello.login = e(hello.login), hello.api = e(hello.api), hello.logout = e(hello.logout)
}(hello),
function (e) {
    function t(e) {
        e && "error" in e && (e.error = {
            code: "server_error",
            message: e.error.message || e.error
        })
    }

    function n(t) {
        if (!("object" != typeof t || "Blob" in window && t instanceof Blob || "ArrayBuffer" in window && t instanceof ArrayBuffer || "error" in t)) {
            var n = t.root + t.path.replace(/\&/g, "%26");
            t.thumb_exists && (t.thumbnail = e.settings.oauth_proxy + "?path=" + encodeURIComponent("https://api-content.dropbox.com/1/thumbnails/" + n + "?format=jpeg&size=m") + "&access_token=" + e.getAuthResponse("dropbox").access_token), t.type = t.is_dir ? "folder" : t.mime_type, t.name = t.path.replace(/.*\//g, ""), t.is_dir ? t.files = "metadata/" + n : (t.downloadLink = e.settings.oauth_proxy + "?path=" + encodeURIComponent("https://api-content.dropbox.com/1/files/" + n) + "&access_token=" + e.getAuthResponse("dropbox").access_token, t.file = "https://api-content.dropbox.com/1/files/" + n), t.id || (t.id = t.path.replace(/^\//, ""))
        }
    }

    function o(e) {
        return function (t, n) {
            delete t.data.limit, n(e)
        }
    }
    e.init({
        dropbox: {
            login: function (e) {
                e.options.window_width = 1e3, e.options.window_height = 1e3
            },
            oauth: {
                version: "1.0",
                auth: "https://www.dropbox.com/1/oauth/authorize",
                request: "https://api.dropbox.com/1/oauth/request_token",
                token: "https://api.dropbox.com/1/oauth/access_token"
            },
            base: "https://api.dropbox.com/1/",
            root: "sandbox",
            get: {
                me: "account/info",
                "me/files": o("metadata/@{root|sandbox}/@{parent}"),
                "me/folder": o("metadata/@{root|sandbox}/@{id}"),
                "me/folders": o("metadata/@{root|sandbox}/"),
                "default": function (e, t) {
                    e.path.match("https://api-content.dropbox.com/1/files/") && (e.method = "blob"), t(e.path)
                }
            },
            post: {
                "me/files": function (t, n) {
                    var o = t.data.parent,
                        i = t.data.name;
                    t.data = {
                        file: t.data.file
                    }, "string" == typeof t.data.file && (t.data.file = e.utils.toBlob(t.data.file)), n("https://api-content.dropbox.com/1/files_put/@{root|sandbox}/" + o + "/" + i)
                },
                "me/folders": function (t, n) {
                    var o = t.data.name;
                    t.data = {}, n("fileops/create_folder?root=@{root|sandbox}&" + e.utils.param({
                        path: o
                    }))
                }
            },
            del: {
                "me/files": "fileops/delete?root=@{root|sandbox}&path=@{id}",
                "me/folder": "fileops/delete?root=@{root|sandbox}&path=@{id}"
            },
            wrap: {
                me: function (e) {
                    return t(e), e.uid ? (e.name = e.display_name, e.first_name = e.name.split(" ")[0], e.last_name = e.name.split(" ")[1], e.id = e.uid, delete e.uid, delete e.display_name, e) : e
                },
                "default": function (e) {
                    if (t(e), e.is_dir && e.contents) {
                        e.data = e.contents, delete e.contents;
                        for (var o = 0; o < e.data.length; o++) e.data[o].root = e.root, n(e.data[o])
                    }
                    return n(e), e.is_deleted && (e.success = !0), e
                }
            },
            xhr: function (e) {
                if (e.data && e.data.file) {
                    var t = e.data.file;
                    t && (e.data = t.files ? t.files[0] : t)
                }
                return "delete" === e.method && (e.method = "post"), !0
            }
        }
    })
}(hello),
function (e) {
    function t(e) {
        return e.id && (e.thumbnail = e.picture = "http://graph.facebook.com/" + e.id + "/picture"), e
    }

    function n(e) {
        if ("data" in e)
            for (var n = 0; n < e.data.length; n++) t(e.data[n]);
        return e
    }

    function o(t) {
        if ("data" in t)
            for (var n = e.getAuthResponse("facebook").access_token, o = 0; o < t.data.length; o++) {
                var a = t.data[o];
                a.picture && (a.thumbnail = a.picture), a.cover_photo && (a.thumbnail = i + a.cover_photo + "/picture?access_token=" + n), "album" === a.type && (a.files = a.photos = i + a.id + "/photos"), a.can_upload && (a.upload_location = i + a.id + "/photos")
            }
        return t
    }
    var i = "https://graph.facebook.com/";
    e.init({
        facebook: {
            name: "Facebook",
            login: function (e) {
                e.options.window_width = 580, e.options.window_height = 400
            },
            oauth: {
                version: 2,
                auth: "https://www.facebook.com/dialog/oauth/"
            },
            refresh: !0,
            logout: function (t) {
                var n = e.utils.globalEvent(t),
                    o = encodeURIComponent(e.settings.redirect_uri + "?" + e.utils.param({
                        callback: n,
                        result: JSON.stringify({
                            force: !0
                        }),
                        state: "{}"
                    })),
                    i = (e.utils.store("facebook") || {}).access_token;
                return e.utils.iframe("https://www.facebook.com/logout.php?next=" + o + "&access_token=" + i), i ? void 0 : !1
            },
            scope: {
                basic: "public_profile",
                email: "email",
                birthday: "user_birthday",
                events: "user_events",
                photos: "user_photos,user_videos",
                videos: "user_photos,user_videos",
                friends: "user_friends",
                files: "user_photos,user_videos",
                publish_files: "user_photos,user_videos,publish_actions",
                publish: "publish_actions",
                offline_access: "offline_access"
            },
            base: "https://graph.facebook.com/",
            get: {
                me: "me",
                "me/friends": "me/friends",
                "me/following": "me/friends",
                "me/followers": "me/friends",
                "me/share": "me/feed",
                "me/files": "me/albums",
                "me/albums": "me/albums",
                "me/album": "@{id}/photos",
                "me/photos": "me/photos",
                "me/photo": "@{id}"
            },
            post: {
                "me/share": "me/feed",
                "me/albums": "me/albums",
                "me/album": "@{id}/photos"
            },
            del: {
                "me/photo": "@{id}"
            },
            wrap: {
                me: t,
                "me/friends": n,
                "me/following": n,
                "me/followers": n,
                "me/albums": o,
                "me/files": o,
                "default": o
            },
            xhr: function (t, n) {
                return ("get" === t.method || "post" === t.method) && (n.suppress_response_codes = !0), "post" === t.method && t.data && "string" == typeof t.data.file && (t.data.file = e.utils.toBlob(t.data.file)), !0
            },
            jsonp: function (t, n) {
                var o = t.method.toLowerCase();
                "get" === o || e.utils.hasBinary(t.data) ? "delete" === t.method && (n.method = "delete", t.method = "post") : (t.data.method = o, t.method = "get")
            },
            form: function () {
                return {
                    callbackonload: !0
                }
            }
        }
    })
}(hello),
function (e) {
    function t(t, n, o) {
        var i = (o ? "" : "flickr:") + "?method=" + t + "&api_key=" + e.init().flickr.id + "&format=json";
        for (var a in n) n.hasOwnProperty(a) && (i += "&" + a + "=" + n[a]);
        return i
    }

    function n(n) {
        var o = e.getAuthResponse("flickr");
        o && o.user_nsid ? n(o.user_nsid) : e.api(t("flickr.test.login"), function (e) {
            n(l(e, "user").id)
        })
    }

    function o(e, o) {
        return o || (o = {}),
        function (i, a) {
            n(function (n) {
                o.user_id = n, a(t(e, o, !0))
            })
        }
    }

    function i(e, t) {
        var n = "https://www.flickr.com/images/buddyicon.gif";
        return e.nsid && e.iconserver && e.iconfarm && (n = "https://farm" + e.iconfarm + ".staticflickr.com/" + e.iconserver + "/buddyicons/" + e.nsid + (t ? "_" + t : "") + ".jpg"), n
    }

    function a(e, t, n, o, i) {
        return i = i ? "_" + i : "", "https://farm" + t + ".staticflickr.com/" + n + "/" + e + "_" + o + i + ".jpg"
    }

    function r(e) {
        e && e.stat && "ok" != e.stat.toLowerCase() && (e.error = {
            code: "invalid_request",
            message: e.message
        })
    }

    function s(e) {
        if (e.photoset || e.photos) {
            var t = "photoset" in e ? "photoset" : "photos";
            e = l(e, t), u(e), e.data = e.photo, delete e.photo;
            for (var n = 0; n < e.data.length; n++) {
                var o = e.data[n];
                o.name = o.title, o.picture = a(o.id, o.farm, o.server, o.secret, ""), o.source = a(o.id, o.farm, o.server, o.secret, "b"), o.thumbnail = a(o.id, o.farm, o.server, o.secret, "m")
            }
        }
        return e
    }

    function l(e, t) {
        return t in e ? e = e[t] : "error" in e || (e.error = {
            code: "invalid_request",
            message: e.message || "Failed to get data from Flickr"
        }), e
    }

    function c(e) {
        if (r(e), e.contacts) {
            e = l(e, "contacts"), u(e), e.data = e.contact, delete e.contact;
            for (var t = 0; t < e.data.length; t++) {
                var n = e.data[t];
                n.id = n.nsid, n.name = n.realname || n.username, n.thumbnail = i(n, "m")
            }
        }
        return e
    }

    function u(e) {
        e.page && e.pages && e.page !== e.pages && (e.paging = {
            next: "?page=" + ++e.page
        })
    }
    e.init({
        flickr: {
            name: "Flickr",
            oauth: {
                version: "1.0a",
                auth: "https://www.flickr.com/services/oauth/authorize?perms=read",
                request: "https://www.flickr.com/services/oauth/request_token",
                token: "https://www.flickr.com/services/oauth/access_token"
            },
            base: "https://api.flickr.com/services/rest",
            get: {
                me: o("flickr.people.getInfo"),
                "me/friends": o("flickr.contacts.getList", {
                    per_page: "@{limit|50}"
                }),
                "me/following": o("flickr.contacts.getList", {
                    per_page: "@{limit|50}"
                }),
                "me/followers": o("flickr.contacts.getList", {
                    per_page: "@{limit|50}"
                }),
                "me/albums": o("flickr.photosets.getList", {
                    per_page: "@{limit|50}"
                }),
                "me/photos": o("flickr.people.getPhotos", {
                    per_page: "@{limit|50}"
                })
            },
            wrap: {
                me: function (e) {
                    if (r(e), e = l(e, "person"), e.id) {
                        if (e.realname) {
                            e.name = e.realname._content;
                            var t = e.name.split(" ");
                            e.first_name = t[0], e.last_name = t[1]
                        }
                        e.thumbnail = i(e, "l"), e.picture = i(e, "l")
                    }
                    return e
                },
                "me/friends": c,
                "me/followers": c,
                "me/following": c,
                "me/albums": function (e) {
                    if (r(e), e = l(e, "photosets"), u(e), e.photoset) {
                        e.data = e.photoset, delete e.photoset;
                        for (var n = 0; n < e.data.length; n++) {
                            var o = e.data[n];
                            o.name = o.title._content, o.photos = "https://api.flickr.com/services/rest" + t("flickr.photosets.getPhotos", {
                                photoset_id: o.id
                            }, !0)
                        }
                    }
                    return e
                },
                "me/photos": function (e) {
                    return r(e), s(e)
                },
                "default": function (e) {
                    return r(e), s(e)
                }
            },
            xhr: !1,
            jsonp: function (e, t) {
                "get" == e.method.toLowerCase() && (delete t.callback, t.jsoncallback = e.callbackID)
            }
        }
    })
}(hello),
function (e) {
    function t(e) {
        e.meta && 400 === e.meta.code && (e.error = {
            code: "access_denied",
            message: e.meta.errorDetail
        })
    }

    function n(e) {
        e && e.id && (e.thumbnail = e.photo.prefix + "100x100" + e.photo.suffix, e.name = e.firstName + " " + e.lastName, e.first_name = e.firstName, e.last_name = e.lastName, e.contact && e.contact.email && (e.email = e.contact.email))
    }
    e.init({
        foursquare: {
            name: "FourSquare",
            oauth: {
                version: 2,
                auth: "https://foursquare.com/oauth2/authenticate"
            },
            refresh: !0,
            querystring: function (e) {
                var t = e.access_token;
                delete e.access_token, e.oauth_token = t, e.v = 20121125
            },
            base: "https://api.foursquare.com/v2/",
            get: {
                me: "users/self",
                "me/friends": "users/self/friends",
                "me/followers": "users/self/friends",
                "me/following": "users/self/friends"
            },
            wrap: {
                me: function (e) {
                    return t(e), e && e.response && (e = e.response.user, n(e)), e
                },
                "default": function (e) {
                    if (t(e), e && "response" in e && "friends" in e.response && "items" in e.response.friends) {
                        e.data = e.response.friends.items, delete e.response;
                        for (var o = 0; o < e.data.length; o++) n(e.data[o])
                    }
                    return e
                }
            }
        }
    })
}(hello),
function (e) {
    function t(e, t) {
        var n = t ? t.statusCode : e && "meta" in e && "status" in e.meta && e.meta.status;
        (401 === n || 403 === n) && (e.error = {
            code: "access_denied",
            message: e.message || (e.data ? e.data.message : "Could not get response")
        }, delete e.message)
    }

    function n(e) {
        e.id && (e.thumbnail = e.picture = e.avatar_url, e.name = e.login)
    }

    function o(e, t) {
        if (e.data && e.data.length && t && t.Link) {
            var n = t.Link.match(/&page=([0-9]+)/);
            n && (e.paging = {
                next: "?page=" + n[1]
            })
        }
    }
    e.init({
        github: {
            name: "GitHub",
            oauth: {
                version: 2,
                auth: "https://github.com/login/oauth/authorize",
                grant: "https://github.com/login/oauth/access_token",
                response_type: "code"
            },
            scope: {
                basic: "",
                email: "user:email"
            },
            base: "https://api.github.com/",
            get: {
                me: "user",
                "me/friends": "user/following?per_page=@{limit|100}",
                "me/following": "user/following?per_page=@{limit|100}",
                "me/followers": "user/followers?per_page=@{limit|100}"
            },
            wrap: {
                me: function (e, o) {
                    return t(e, o), n(e), e
                },
                "default": function (e, i, a) {
                    if (t(e, i), "[object Array]" === Object.prototype.toString.call(e)) {
                        e = {
                            data: e
                        }, o(e, i, a);
                        for (var r = 0; r < e.data.length; r++) n(e.data[r])
                    }
                    return e
                }
            }
        }
    })
}(hello),
function (e, t) {
    "use strict";

    function n(e) {
        return parseInt(e, 10)
    }

    function o(e) {
        e.error || (e.name || (e.name = e.title || e.message), e.picture || (e.picture = e.thumbnailLink), e.thumbnail || (e.thumbnail = e.thumbnailLink), "application/vnd.google-apps.folder" === e.mimeType && (e.type = "folder", e.files = "https://www.googleapis.com/drive/v2/files?q=%22" + e.id + "%22+in+parents"))
    }

    function i(e) {
        s(e);
        var t = function (e) {
            var t, n = e.media$group.media$content.length ? e.media$group.media$content[0] : {}, o = 0,
                i = {
                    id: e.id.$t,
                    name: e.title.$t,
                    description: e.summary.$t,
                    updated_time: e.updated.$t,
                    created_time: e.published.$t,
                    picture: n ? n.url : null,
                    thumbnail: n ? n.url : null,
                    width: n.width,
                    height: n.height
                };
            if ("link" in e)
                for (o = 0; o < e.link.length; o++) {
                    var a = e.link[o];
                    if (a.rel.match(/\#feed$/)) {
                        i.upload_location = i.files = i.photos = a.href;
                        break
                    }
                }
            if ("category" in e && e.category.length)
                for (t = e.category, o = 0; o < t.length; o++) t[o].scheme && t[o].scheme.match(/\#kind$/) && (i.type = t[o].term.replace(/^.*?\#/, ""));
            if ("media$thumbnail" in e.media$group && e.media$group.media$thumbnail.length) {
                for (t = e.media$group.media$thumbnail, i.thumbnail = e.media$group.media$thumbnail[0].url, i.images = [], o = 0; o < t.length; o++) i.images.push({
                    source: t[o].url,
                    width: t[o].width,
                    height: t[o].height
                });
                t = e.media$group.media$content.length ? e.media$group.media$content[0] : null, t && i.images.push({
                    source: t.url,
                    width: t.width,
                    height: t.height
                })
            }
            return i
        }, n = [];
        if ("feed" in e && "entry" in e.feed) {
            for (i = 0; i < e.feed.entry.length; i++) n.push(t(e.feed.entry[i]));
            e.data = n, delete e.feed
        } else {
            if ("entry" in e) return t(e.entry);
            if ("items" in e) {
                for (var i = 0; i < e.items.length; i++) o(e.items[i]);
                e.data = e.items, delete e.items
            } else o(e)
        }
        return e
    }

    function a(e) {
        e.name = e.displayName || e.name, e.picture = e.picture || (e.image ? e.image.url : null), e.thumbnail = e.picture
    }

    function r(t) {
        s(t);
        var n = [];
        if ("feed" in t && "entry" in t.feed) {
            for (var o = e.getAuthResponse("google").access_token, i = 0; i < t.feed.entry.length; i++) {
                var a = t.feed.entry[i],
                    r = a.link && a.link.length > 0 ? a.link[0].href + "?access_token=" + o : null;
                n.push({
                    id: a.id.$t,
                    name: a.title.$t,
                    email: a.gd$email && a.gd$email.length > 0 ? a.gd$email[0].address : null,
                    updated_time: a.updated.$t,
                    picture: r,
                    thumbnail: r
                })
            }
            t.data = n, delete t.feed
        }
        return t
    }

    function s(e) {
        if ("feed" in e && e.feed.openSearch$itemsPerPage) {
            var t = n(e.feed.openSearch$itemsPerPage.$t),
                o = n(e.feed.openSearch$startIndex.$t),
                i = n(e.feed.openSearch$totalResults.$t);
            i > o + t && (e.paging = {
                next: "?start=" + (o + t)
            })
        } else "nextPageToken" in e && (e.paging = {
            next: "?pageToken=" + e.nextPageToken
        })
    }

    function l() {
        function e(e) {
            var t = new FileReader;
            t.onload = function (t) {
                n(btoa(t.target.result), e.type + r + "Content-Transfer-Encoding: base64")
            }, t.readAsBinaryString(e)
        }

        function n(e, t) {
            o.push(r + "Content-Type: " + t + r + r + e), a--, l()
        }
        var o = [],
            i = (1e10 * Math.random()).toString(32),
            a = 0,
            r = "\r\n",
            s = r + "--" + i,
            l = function () { }, c = /^data\:([^;,]+(\;charset=[^;,]+)?)(\;base64)?,/i;
        this.append = function (o, i) {
            "string" != typeof o && "length" in Object(o) || (o = [o]);
            for (var s = 0; s < o.length; s++) {
                a++;
                var l = o[s];
                if (l instanceof t.File || l instanceof t.Blob) e(l);
                else if ("string" == typeof l && l.match(c)) {
                    var u = l.match(c);
                    n(l.replace(c, ""), u[1] + r + "Content-Transfer-Encoding: base64")
                } else n(l, i)
            }
        }, this.onready = function (e) {
            (l = function () {
                0 === a && (o.unshift(""), o.push("--"), e(o.join(s), i), o = [])
            })()
        }
    }

    function c(e, n, o, i, a) {
        var r = "https://content.googleapis.com";
        m || (g = String(parseInt(1e8 * Math.random(), 10)), m = p.append("iframe", {
            src: r + "/static/proxy.html?jsh=m%3B%2F_%2Fscs%2Fapps-static%2F_%2Fjs%2Fk%3Doz.gapi.en.mMZgig4ibk0.O%2Fm%3D__features__%2Fam%3DEQ%2Frt%3Dj%2Fd%3D1%2Frs%3DAItRSTNZBJcXGialq7mfSUkqsE3kvYwkpQ#parent=" + t.location.origin + "&rpctoken=" + g,
            style: {
                position: "absolute",
                left: "-1000px",
                bottom: 0,
                height: "1px",
                width: "1px"
            }
        }, "body"), f(t, "message", function (e) {
            if (e.origin === r) {
                var t;
                try {
                    t = JSON.parse(e.data)
                } catch (n) {
                    return
                }
                if (t && t.s && t.s === "ready:" + g) {
                    h = !0, v = 0;
                    for (var o = 0; o < w.length; o++) w[o]()
                }
            }
        }));
        var s = function () {
            var s = t.navigator,
                l = ++v,
                c = p.param(n.match(/\?.+/)[0]),
                u = c.access_token;
            delete c.access_token;
            var h = JSON.stringify({
                s: "makeHttpRequests",
                f: "..",
                c: l,
                a: [
                    [{
                        key: "gapiRequest",
                        params: {
                            url: n.replace(/(^https?\:\/\/[^\/]+|\?.+$)/, ""),
                            httpMethod: e.toUpperCase(),
                            body: i,
                            headers: {
                                Authorization: ":Bearer " + u,
                                "Content-Type": o["content-type"],
                                "X-Origin": t.location.origin,
                                "X-ClientDetails": "appVersion=" + s.appVersion + "&platform=" + s.platform + "&userAgent=" + s.userAgent
                            },
                            urlParams: c,
                            clientName: "google-api-javascript-client",
                            clientVersion: "1.1.0-beta"
                        }
                    }]
                ],
                t: g,
                l: !1,
                g: !0,
                r: ".."
            });
            f(t, "message", function w(e) {
                if (e.origin === r) try {
                    var n = JSON.parse(e.data);
                    n.t === g && n.a[0] === l && (d(t, "message", w), a(JSON.parse(JSON.parse(n.a[1]).gapiRequest.data.body)))
                } catch (o) {
                    a({
                        error: {
                            code: "request_error",
                            message: "Failed to post to Google"
                        }
                    })
                }
            }), m.contentWindow.postMessage(h, "*")
        };
        h ? s() : w.push(s)
    }

    function u(e, n) {
        var o = {};
        e.data && e.data instanceof t.HTMLInputElement && (e.data = {
            file: e.data
        }), !e.data.name && Object(Object(e.data.file).files).length && "post" === e.method && (e.data.name = e.data.file.files[0].name), "post" === e.method ? e.data = {
            title: e.data.name,
            parents: [{
                id: e.data.parent || "root"
            }],
            file: e.data.file
        } : (o = e.data, e.data = {}, o.parent && (e.data.parents = [{
            id: e.data.parent || "root"
        }]), o.file && (e.data.file = o.file), o.name && (e.data.title = o.name)), n("upload/drive/v2/files" + (o.id ? "/" + o.id : "") + "?uploadType=multipart")
    }
    var f, d, p = e.utils;
    document.removeEventListener ? (f = function (e, t, n) {
        e.addEventListener(t, n)
    }, d = function (e, t, n) {
        e.removeEventListener(t, n)
    }) : document.detachEvent && (d = function (e, t, n) {
        e.detachEvent("on" + t, n)
    }, f = function (e, t, n) {
        e.attachEvent("on" + t, n)
    });
    var m, h, g, v, w = [],
        y = "https://www.google.com/m8/feeds/contacts/default/full?alt=json&max-results=@{limit|1000}&start-index=@{start|1}";
    e.init({
        google: {
            name: "Google Plus",
            login: function (e) {
                "none" === e.qs.display && (e.qs.display = ""), "code" === e.qs.response_type && (e.qs.access_type = "offline")
            },
            oauth: {
                version: 2,
                auth: "https://accounts.google.com/o/oauth2/auth",
                grant: "https://accounts.google.com/o/oauth2/token"
            },
            scope: {
                basic: "https://www.googleapis.com/auth/plus.me profile",
                email: "email",
                birthday: "",
                events: "",
                photos: "https://picasaweb.google.com/data/",
                videos: "http://gdata.youtube.com",
                friends: "https://www.google.com/m8/feeds, https://www.googleapis.com/auth/plus.login",
                files: "https://www.googleapis.com/auth/drive.readonly",
                publish: "",
                publish_files: "https://www.googleapis.com/auth/drive",
                create_event: "",
                offline_access: ""
            },
            scope_delim: " ",
            base: "https://www.googleapis.com/",
            get: {
                me: "plus/v1/people/me",
                "me/friends": "plus/v1/people/me/people/visible?maxResults=@{limit|100}",
                "me/following": y,
                "me/followers": y,
                "me/contacts": y,
                "me/share": "plus/v1/people/me/activities/public?maxResults=@{limit|100}",
                "me/feed": "plus/v1/people/me/activities/public?maxResults=@{limit|100}",
                "me/albums": "https://picasaweb.google.com/data/feed/api/user/default?alt=json&max-results=@{limit|100}&start-index=@{start|1}",
                "me/album": function (e, t) {
                    var n = e.data.id;
                    delete e.data.id, t(n.replace("/entry/", "/feed/"))
                },
                "me/photos": "https://picasaweb.google.com/data/feed/api/user/default?alt=json&kind=photo&max-results=@{limit|100}&start-index=@{start|1}",
                "me/files": "drive/v2/files?q=%22@{parent|root}%22+in+parents+and+trashed=false&maxResults=@{limit|100}",
                "me/folders": "drive/v2/files?q=%22@{id|root}%22+in+parents+and+mimeType+=+%22application/vnd.google-apps.folder%22+and+trashed=false&maxResults=@{limit|100}",
                "me/folder": "drive/v2/files?q=%22@{id|root}%22+in+parents+and+trashed=false&maxResults=@{limit|100}"
            },
            post: {
                "me/files": u,
                "me/folders": function (e, t) {
                    e.data = {
                        title: e.data.name,
                        parents: [{
                            id: e.data.parent || "root"
                        }],
                        mimeType: "application/vnd.google-apps.folder"
                    }, t("drive/v2/files")
                }
            },
            put: {
                "me/files": u
            },
            del: {
                "me/files": "drive/v2/files/@{id}",
                "me/folder": "drive/v2/files/@{id}"
            },
            wrap: {
                me: function (e) {
                    return e.id && (e.last_name = e.family_name || (e.name ? e.name.familyName : null), e.first_name = e.given_name || (e.name ? e.name.givenName : null), e.emails && e.emails.length && (e.email = e.emails[0].value), a(e)), e
                },
                "me/friends": function (e) {
                    if (e.items) {
                        s(e), e.data = e.items, delete e.items;
                        for (var t = 0; t < e.data.length; t++) a(e.data[t])
                    }
                    return e
                },
                "me/contacts": r,
                "me/followers": r,
                "me/following": r,
                "me/share": function (e) {
                    return s(e), e.data = e.items, delete e.items, e
                },
                "me/feed": function (e) {
                    return s(e), e.data = e.items, delete e.items, e
                },
                "me/albums": i,
                "me/photos": i,
                "default": i
            },
            xhr: function (e) {
                if ("post" === e.method || "put" === e.method) {
                    if (e.data && p.hasBinary(e.data) || e.data.file) return e.cors_support = e.cors_support || !0, !1;
                    e.data = JSON.stringify(e.data), e.headers = {
                        "content-type": "application/json"
                    }
                }
                return !0
            },
            api: function (e, t, n, o) {
                if ("get" !== t.method) {
                    "file" in t.data && p.domInstance("input", t.data.file) && !("files" in t.data.file) && o({
                        error: {
                            code: "request_invalid",
                            message: "Sorry, can't upload your files to Google Drive in this browser"
                        }
                    });
                    var i;
                    if ("file" in t.data && (i = t.data.file, delete t.data.file, "object" == typeof i && "files" in i && (i = i.files), !i || !i.length)) return void o({
                        error: {
                            code: "request_invalid",
                            message: "There were no files attached with this request to upload"
                        }
                    });
                    var a = new l;
                    return a.append(JSON.stringify(t.data), "application/json"), i && a.append(i), a.onready(function (i, a) {
                        t.cors_support ? p.xhr(t.method, p.qs(e, n), {
                            "content-type": 'multipart/related; boundary="' + a + '"'
                        }, i, o) : c(t.method, p.qs(e, n), {
                            "content-type": 'multipart/related; boundary="' + a + '"'
                        }, i, o)
                    }), !0
                }
            }
        }
    })
}(hello, window),
function (e) {
    function t(e) {
        e && "meta" in e && "error_type" in e.meta && (e.error = {
            code: e.meta.error_type,
            message: e.meta.error_message
        })
    }

    function n(e) {
        if (i(e), e && "data" in e)
            for (var t = 0; t < e.data.length; t++) o(e.data[t]);
        return e
    }

    function o(e) {
        e.id && (e.thumbnail = e.profile_picture, e.name = e.full_name || e.username)
    }

    function i(e) {
        "pagination" in e && (e.paging = {
            next: e.pagination.next_url
        }, delete e.pagination)
    }
    e.init({
        instagram: {
            name: "Instagram",
            login: function (e) {
                e.qs.display = ""
            },
            oauth: {
                version: 2,
                auth: "https://instagram.com/oauth/authorize/"
            },
            refresh: !0,
            scope: {
                basic: "basic",
                friends: "relationships",
                photos: ""
            },
            scope_delim: " ",
            base: "https://api.instagram.com/v1/",
            get: {
                me: "users/self",
                "me/feed": "users/self/feed?count=@{limit|100}",
                "me/photos": "users/self/media/recent?min_id=0&count=@{limit|100}",
                "me/friends": "users/self/follows?count=@{limit|100}",
                "me/following": "users/self/follows?count=@{limit|100}",
                "me/followers": "users/self/followed-by?count=@{limit|100}"
            },
            wrap: {
                me: function (e) {
                    return t(e), "data" in e && (e.id = e.data.id, e.thumbnail = e.data.profile_picture, e.name = e.data.full_name || e.data.username), e
                },
                "me/friends": n,
                "me/following": n,
                "me/followers": n,
                "me/photos": function (e) {
                    if (t(e), i(e), "data" in e)
                        for (var n = 0; n < e.data.length; n++) {
                            var o = e.data[n];
                            "image" === o.type ? (o.thumbnail = o.images.thumbnail.url, o.picture = o.images.standard_resolution.url, o.name = o.caption ? o.caption.text : null) : (e.data.splice(n, 1), n--)
                        }
                    return e
                },
                "default": function (e) {
                    return i(e), e
                }
            },
            xhr: !1
        }
    })
}(hello),
function (e) {
    function t(e) {
        e && "errorCode" in e && (e.error = {
            code: e.status,
            message: e.message
        })
    }

    function n(e) {
        e.error || (e.first_name = e.firstName, e.last_name = e.lastName, e.name = e.formattedName || e.first_name + " " + e.last_name, e.thumbnail = e.pictureUrl)
    }

    function o(e) {
        if (t(e), i(e), e.values) {
            e.data = e.values;
            for (var o = 0; o < e.data.length; o++) n(e.data[o]);
            delete e.values
        }
        return e
    }

    function i(e) {
        "_count" in e && "_start" in e && e._count + e._start < e._total && (e.paging = {
            next: "?start=" + (e._start + e._count) + "&count=" + e._count
        })
    }
    e.init({
        linkedin: {
            oauth: {
                version: 2,
                response_type: "code",
                auth: "https://www.linkedin.com/uas/oauth2/authorization",
                grant: "https://www.linkedin.com/uas/oauth2/accessToken"
            },
            refresh: !0,
            scope: {
                basic: "r_fullprofile",
                email: "r_emailaddress",
                friends: "r_network",
                publish: "rw_nus"
            },
            scope_delim: " ",
            querystring: function (e) {
                e.oauth2_access_token = e.access_token, delete e.access_token
            },
            base: "https://api.linkedin.com/v1/",
            get: {
                me: "people/~:(picture-url,first-name,last-name,id,formatted-name)",
                "me/friends": "people/~/connections?count=@{limit|500}",
                "me/followers": "people/~/connections?count=@{limit|500}",
                "me/following": "people/~/connections?count=@{limit|500}",
                "me/share": "people/~/network/updates?count=@{limit|250}"
            },
            post: {},
            wrap: {
                me: function (e) {
                    return t(e), n(e), e
                },
                "me/friends": o,
                "me/following": o,
                "me/followers": o,
                "me/share": function (e) {
                    if (t(e), i(e), e.values) {
                        e.data = e.values, delete e.values;
                        for (var o = 0; o < e.data.length; o++) {
                            var a = e.data[o];
                            n(a), a.message = a.headline
                        }
                    }
                    return e
                },
                "default": function (e) {
                    t(e), i(e)
                }
            },
            jsonp: function (e, t) {
                t.format = "jsonp", "get" === e.method && (t["error-callback"] = "?")
            },
            xhr: !1
        }
    })
}(hello),
function (e) {
    function t(e) {
        e.id && (e.picture = e.avatar_url, e.thumbnail = e.avatar_url, e.name = e.username || e.full_name)
    }

    function n(e) {
        "next_href" in e && (e.paging = {
            next: e.next_href
        })
    }
    e.init({
        soundcloud: {
            name: "SoundCloud",
            oauth: {
                version: 2,
                auth: "https://soundcloud.com/connect"
            },
            querystring: function (e) {
                var t = e.access_token;
                delete e.access_token, e.oauth_token = t, e["_status_code_map[302]"] = 200
            },
            base: "https://api.soundcloud.com/",
            get: {
                me: "me.json",
                "me/friends": "me/followings.json",
                "me/followers": "me/followers.json",
                "me/following": "me/followings.json",
                "default": function (e, t) {
                    t(e.path + ".json")
                }
            },
            wrap: {
                me: function (e) {
                    return t(e), e
                },
                "default": function (e) {
                    if (e instanceof Array) {
                        e = {
                            data: e
                        };
                        for (var o = 0; o < e.data.length; o++) t(e.data[o])
                    }
                    return n(e), e
                }
            }
        }
    })
}(hello),
function (e) {
    function t(e) {
        if (e.id) {
            if (e.name) {
                var t = e.name.split(" ");
                e.first_name = t[0], e.last_name = t[1]
            }
            e.thumbnail = e.profile_image_url
        }
    }

    function n(e) {
        if (o(e), i(e), e.users) {
            e.data = e.users;
            for (var n = 0; n < e.data.length; n++) t(e.data[n]);
            delete e.users
        }
        return e
    }

    function o(e) {
        if (e.errors) {
            var t = e.errors[0];
            e.error = {
                code: "request_failed",
                message: t.message
            }
        }
    }

    function i(e) {
        "next_cursor_str" in e && (e.paging = {
            next: "?cursor=" + e.next_cursor_str
        })
    }
    e.init({
        twitter: {
            oauth: {
                version: "1.0a",
                auth: "https://twitter.com/oauth/authorize",
                request: "https://twitter.com/oauth/request_token",
                token: "https://twitter.com/oauth/access_token"
            },
            base: "https://api.twitter.com/1.1/",
            get: {
                me: "account/verify_credentials.json",
                "me/friends": "friends/list.json?count=@{limit|200}",
                "me/following": "friends/list.json?count=@{limit|200}",
                "me/followers": "followers/list.json?count=@{limit|200}",
                "me/share": "statuses/user_timeline.json?count=@{limit|200}"
            },
            post: {
                "me/share": function (e, t) {
                    var n = e.data;
                    e.data = null, t("statuses/update.json?include_entities=1&status=" + n.message)
                }
            },
            wrap: {
                me: function (e) {
                    return o(e), t(e), e
                },
                "me/friends": n,
                "me/followers": n,
                "me/following": n,
                "me/share": function (e) {
                    return o(e), i(e), !e.error && "length" in e ? {
                        data: e
                    } : e
                },
                "default": function (e) {
                    return i(e), e
                }
            },
            xhr: function (e) {
                return "get" !== e.method
            }
        }
    })
}(hello),
function (e) {
    function t(t) {
        if (t.id) {
            var n = e.getAuthResponse("windows").access_token;
            if (t.emails && (t.email = t.emails.preferred), t.is_friend !== !1) {
                var o = t.user_id || t.id;
                t.thumbnail = t.picture = "https://apis.live.net/v5.0/" + o + "/picture?access_token=" + n
            }
        }
    }

    function n(e) {
        if ("data" in e)
            for (var n = 0; n < e.data.length; n++) t(e.data[n]);
        return e
    }
    e.init({
        windows: {
            name: "windows",
            oauth: {
                version: 2,
                auth: "https://login.live.com/oauth20_authorize.srf"
            },
            refresh: !0,
            logout: function () {
                return "http://login.live.com/oauth20_logout.srf?ts=" + (new Date).getTime()
            },
            id: _authConfig.live.client_id,
            scope: {
                basic: "wl.signin,wl.basic",
                email: "wl.emails",
                birthday: "wl.birthday",
                events: "wl.calendars",
                photos: "wl.photos",
                videos: "wl.photos",
                friends: "wl.contacts_emails",
                files: "wl.skydrive",
                publish: "wl.share",
                publish_files: "wl.skydrive_update",
                create_event: "wl.calendars_update,wl.events_create",
                offline_access: "wl.offline_access"
            },
            base: "https://apis.live.net/v5.0/",
            get: {
                me: "me",
                "me/friends": "me/friends",
                "me/following": "me/contacts",
                "me/followers": "me/friends",
                "me/contacts": "me/contacts",
                "me/albums": "me/albums",
                "me/album": "@{id}/files",
                "me/photo": "@{id}",
                "me/files": "@{parent|me/skydrive}/files",
                "me/folders": "@{id|me/skydrive}/files",
                "me/folder": "@{id|me/skydrive}/files"
            },
            post: {
                "me/albums": "me/albums",
                "me/album": "@{id}/files/",
                "me/folders": "@{id|me/skydrive/}",
                "me/files": "@{parent|me/skydrive/}/files"
            },
            del: {
                "me/album": "@{id}",
                "me/photo": "@{id}",
                "me/folder": "@{id}",
                "me/files": "@{id}"
            },
            wrap: {
                me: function (e) {
                    return t(e), e
                },
                "me/friends": n,
                "me/contacts": n,
                "me/followers": n,
                "me/following": n,
                "me/albums": function (e) {
                    if ("data" in e)
                        for (var t = 0; t < e.data.length; t++) {
                            var n = e.data[t];
                            n.photos = n.files = "https://apis.live.net/v5.0/" + n.id + "/photos"
                        }
                    return e
                },
                "default": function (e) {
                    if ("data" in e)
                        for (var t = 0; t < e.data.length; t++) {
                            var n = e.data[t];
                            n.picture && (n.thumbnail = n.picture)
                        }
                    return e
                }
            },
            xhr: function (t) {
                return "get" === t.method || "delete" === t.method || e.utils.hasBinary(t.data) || ("string" == typeof t.data.file ? t.data.file = e.utils.toBlob(t.data.file) : (t.data = JSON.stringify(t.data), t.headers = {
                    "Content-Type": "application/json"
                })), !0
            },
            jsonp: function (t) {
                "get" === t.method.toLowerCase() || e.utils.hasBinary(t.data) || (t.data.method = t.method.toLowerCase(), t.method = "get")
            }
        }
    })
}(hello),
function (e) {
    function t(e) {
        e && "meta" in e && "error_type" in e.meta && (e.error = {
            code: e.meta.error_type,
            message: e.meta.error_message
        })
    }

    function n(e) {
        t(e), o(e);
        var n, i;
        if (e.query && e.query.results && e.query.results.contact) {
            e.data = e.query.results.contact, delete e.query, e.data instanceof Array || (e.data = [e.data]);
            for (var a = 0; a < e.data.length; a++) {
                n = e.data[a], n.id = null;
                for (var r = 0; r < n.fields.length; r++) i = n.fields[r], "email" === i.type && (n.email = i.value), "name" === i.type && (n.first_name = i.value.givenName, n.last_name = i.value.familyName, n.name = i.value.givenName + " " + i.value.familyName), "yahooid" === i.type && (n.id = i.value)
            }
        }
        return e
    }

    function o(e) {
        e.query && e.query.count && (e.paging = {
            next: "?start=" + e.query.count
        })
    }
    var i = function (e) {
        return "https://query.yahooapis.com/v1/yql?q=" + (e + " limit @{limit|100} offset @{start|0}").replace(/\s/g, "%20") + "&format=json"
    };
    e.init({
        yahoo: {
            oauth: {
                version: "1.0a",
                auth: "https://api.login.yahoo.com/oauth/v2/request_auth",
                request: "https://api.login.yahoo.com/oauth/v2/get_request_token",
                token: "https://api.login.yahoo.com/oauth/v2/get_token"
            },
            redirect_uri: 'redirect.html',
            login: function (e) {
                e.options.window_width = 560
            },
            id: _authConfig.yahoo.consumer_key,//'dj0yJmk9ZXpFRTdiZ3lzakl5JmQ9WVdrOVZrUnNVRE5KTkdVbWNHbzlNQS0tJnM9Y29uc3VtZXJzZWNyZXQmeD1kYQ--',
            base: "https://social.yahooapis.com/v1/",
            get: {
                me: i("select * from social.profile(0) where guid=me"),
                "me/friends": i("select * from social.contacts(0) where guid=me"),
                "me/following": i("select * from social.contacts(0) where guid=me")
            },
            wrap: {
                me: function (e) {
                    if (t(e), e.query && e.query.results && e.query.results.profile) {
                        e = e.query.results.profile, e.id = e.guid, e.last_name = e.familyName, e.first_name = e.givenName || e.nickname;
                        var n = [];
                        e.first_name && n.push(e.first_name), e.last_name && n.push(e.last_name), e.name = n.join(" "), e.email = e.emails ? e.emails.handle : null, e.thumbnail = e.image ? e.image.imageUrl : null
                    }
                    return e
                },
                "me/friends": n,
                "me/following": n,
                "default": function (e) {
                    return o(e), e
                }
            },
            xhr: !1
        }
    })
}(hello), "function" == typeof define && define.amd && define(function () {
    return hello
});

'use strict';

/* Controllers */
/*
    Controllers:        
        DashCtrl
        DeleteWidgetCtrl
        FeedCtrl
        HeaderCtrl
        WeatherCtrl
        FacebookCtrl
        LoginCtrl
        MoreFeedCtrl
        MoreWebsiteCtrl
        MyProfileCtrl
        RegisterCtrl
        EmailCtrl
        EmailAccountCtrl
        MyWebsiteCtrl
        AddNewWidgetCtrl
        AddNewWidgetCtrl.FeedCtrl
        AddNewWidgetCtrl.MyWebsiteCtrl
        FacebookPhotosCtrl
        FacebookPhotoDetailCtrl
        FacebookPhotosManageFriendsCtrl
        InviteFriends
        CustomizeHomepageCtrl
        SuggestionCtrl
        ChatCtrl
        SupportCtrl
        FAQsCtrl
        AddAsHomePageCtrl
*/
//debugger;

//hello.init({
//    //windows: CLIENT_IDS_ALL.windows,
//    //google: CLIENT_IDS_ALL.google,
//    //facebook: CLIENT_IDS_ALL.facebook,
//    yahoo: 'dj0yJmk9YTg0TXhJMjJKTXM3JmQ9WVdrOWFHRTNPRzFaTm1zbWNHbzlNQS0tJnM9Y29uc3VtZXJzZWNyZXQmeD0wNw--'
//}
//	, {
//	    redirect_uri: '',
//	    oauth_proxy: 'https://auth-server.herokuapp.com',
//	    scope: "friends"
//	}
//);

//var CLIENT_IDS = {
//    google: '656984324806-sr0q9vq78tlna4hvhlmcgp2bs2ut8uj8.apps.googleusercontent.com',
//    windows: {
//        'adodson.com': '00000000400D8578',
//        'local.knarly.com': '000000004405FD31',
//        'auth-server.herokuapp.com': '000000004C0DFA39'
//    }[window.location.hostname],
//    facebook: {
//        'adodson.com': '160981280706879',
//        'local.knarly.com': '285836944766385',
//        'auth-server.herokuapp.com': '115601335281241'
//    }[window.location.hostname],
//    yahoo: {
//        'local.knarly.com': 'dj0yJmk9cjVDdHlDaGtrbldJJmQ9WVdrOVYyZFhSWE4yTm04bWNHbzlNQS0tJnM9Y29uc3VtZXJzZWNyZXQmeD1jOA--',
//        'adodson.com': 'dj0yJmk9TWtNN0ppYTBGSW1vJmQ9WVdrOVIxSnhUVVJsTlRJbWNHbzlOamMxT1RVM01UWXkmcz1jb25zdW1lcnNlY3JldCZ4PWNk',
//        'auth-server.herokuapp.com': 'dj0yJmk9M1JuUWFaRHl5U01nJmQ9WVdrOWMzZHBVRFJsTXpJbWNHbzlNVEExTURVeE5qYzJNZy0tJnM9Y29uc3VtZXJzZWNyZXQmeD0wNg--'
//    }[window.location.hostname]
//};

var REDIRECT_URI = {
    'local.knarly.com': '/hello.js/redirect.html'
}[window.location.host] || './redirect.html';


function AppCtrl($scope) {
    angular.element(document).ready(function () {
        //document.getElementById('msg').innerHTML = 'anirudh';
        alert("hello");
    });
}

$(document).ready(function () {
    if (typeof (Storage) !== "undefined") {
        if (localStorage != undefined || localStorage != "undefined") {
            if (localStorage.FirstUser == undefined) {
                localStorage.FirstUser = "trues";
                $('#joinSite').click();
            }
        }
    }
    $('#joinSite').click();
    //alert("hello");
});

angular.module('App.controllers', [])
.constant('gcfg', {
    clientId: _googleAuthConfig.clientId,
    state: _googleAuthConfig.appState,
    scopes: {
        email: _googleAuthConfig.scopes.email,
        profile: _googleAuthConfig.scopes.profile,
        plus: _googleAuthConfig.scopes.plus,
        me: _googleAuthConfig.scopes.me
    }
})

    .constant('authcfg', {
        live: {
            clientId: _authConfig.live.client_id,
            clientSecret: _authConfig.live.client_secret,
            redirectUrl: _authConfig.live.redirect_url
        },
        yahoo: {
            consumerKey: _authConfig.yahoo.consumer_key,
            consumerSecret: _authConfig.yahoo.consumer_secret,
            redirectUrl: _authConfig.yahoo.redirect_url
        }
    })
    // Main Controller
    .controller('AppCtrl', ['$scope', '$rootScope', '$location', function ($scope, $rootScope, $location) {
        $scope.overlayClose = false;
        $scope.dash = $rootScope.dash = {};
        $rootScope.facebookToken = '';
        $rootScope.firstAccess = false;
        if ($location.$$absUrl.indexOf('?InviteYourFriends') != -1) {
            $rootScope.firstAccess = true;
            $location.$$absUrl = $location.$$absUrl.replace('?InviteYourFriends', '');
            setTimeout(function () {
                $("#lnkMenuInvite").trigger("click");
            }, 1000);
        }
      
        $scope.returningUser = function () {
            $rootScope.returningUser();
        };

    }])

    // Controller for DashCtrl in /Default.aspx
    .controller('DashCtrl', ['$timeout', '$scope', '$http', '$rootScope', '$injector', 'filterDash', function ($timeout, $scope, $http, $rootScope, $injector, filterDash) {
        $scope.userFriendsSearch = $rootScope.userFriendsSearch = [];
        $scope.facebookPhoto = { friendName: '', viewDetail: false };
        $scope.userEmailFeed = $rootScope.userEmailFeed = [];
        $scope.userHasEmailAccount = $rootScope.userHasEmailAccount = false;
        $rootScope.$gridster = null;

        $rootScope.loadDragWidgets = function (id) {
            //$(function () {
            var iOS = /(iPad|iPhone|iPod)/g.test(navigator.userAgent);
            if (iOS || homepage == 'True') {
                $(function () {
                    $rootScope.$gridster = $('.gridster .list-gridster').gridster({
                        widget_margins: [5, 5],
                        widget_base_dimensions: [310, 340],
                    }).data('gridster').disable();
                });
            }
                //else if ($(window).width() >= 1024) {
            else {
                if ($rootScope.$gridster == null) {
                    $(function () {
                        console.log('remake grid');
                        $rootScope.$gridster = $('.gridster .list-gridster').gridster({
                            widget_margins: [5, 5],
                            widget_base_dimensions: [310, 340],
                            shift_larger_widgets_down: false,
                            //draggable: {
                            //handle: '.list-gridster header.nv-1'
                            //},
                            serialize_params: function ($w, wgd) {
                                return {
                                    id: $w.attr('data-widget'),
                                    col: wgd.col,
                                    row: wgd.row,
                                    size_x: wgd.size_x,
                                    size_y: wgd.size_y
                                }
                            },
                            draggable: {
                                stop: function () {
                                    var gridsterItens = $rootScope.$gridster.serialize();
                                    $scope.updatePosition(gridsterItens);
                                    //console.log(gridsterItens);
                                }
                            }
                        }).data('gridster');
                    });
                } else {
                    $timeout(function () {
                        $('.list-gridster .box-column').each(function (i, e) {
                            if (!$(e).hasClass('gs_w')) {
                                $rootScope.$gridster.add_widget(e, $(e).attr('data-sizex'), 1, $(e).attr('data-col'), $(e).attr('data-row'));
                            }

                        });

                        $rootScope.$gridster = null;
                        $rootScope.loadDragWidgets();
                    }, 200);
                }
            }
            //});
        };


        $rootScope.loadDragWidgets();

        var _widgets;
        $scope.$inject = ['$scope', 'filterDash'];


        $scope.$on('handleBroadcast', function () {
            $scope.category = filterDash.key;
        });
        /*
        $http.get('/REST/UserWidget?m=' + (new Date()).getMilliseconds(), { cache: false })
            .success(function (data, status, headers, config) {

                $scope.widgets = $rootScope.widgets = _widgets = data;
                $scope.$parent.dash.nWidgets = $scope.widgets.length;

                if (NB.searchGoogle && $scope.$parent.dash.nWidgets < 1)
                    $scope.$parent.dash.nWidgets = 1;
            })
            .error(function (data, status, headers, config) {

            });
            */

        $scope.widgets = $rootScope.widgets = _widgets = _page.widgets;
        $scope.$parent.dash.nWidgets = $scope.widgets.length;

        if (NB.searchGoogle && $scope.$parent.dash.nWidgets < 1)
            $scope.$parent.dash.nWidgets = 1;


        $scope.delSelected = function (id, index) {
            $rootScope.deleteItem = { id: id, i: index };
        };

        /* Used for Facebook Photos */
        $scope.findFriend = function () {
            if ($scope.facebookPhoto.friendName != '') {
                $scope.userFriendsSearch = $rootScope.userFriends.slice(0);
                $scope.userFriendsSearch = _.filter($scope.userFriends, function (v) {
                    return (v.name.toLowerCase().slice(0, $scope.facebookPhoto.friendName.length) == $scope.facebookPhoto.friendName.toLowerCase());
                });
            } else {
                $scope.userFriendsSearch = [];
            }
        };

        /* Used for Facebook Photos */

        $rootScope.returningUser = $scope.returningUser = function (obj) {
            if ($rootScope.currentExternalWindows != undefined) {
                for (var i in $rootScope.currentExternalWindows) {
                    if ($rootScope.currentExternalWindows[i] != null) {
                        $rootScope.currentExternalWindows[i].close();
                    }
                }
            }

            if (!$(".take-me-home").hasClass("hide")) {
                $(".take-me-home").addClass("hide");
                $(".take-me-home-background").addClass("hide");
            }
        };

        window.focus = $rootScope.returningUser;


        $rootScope.removeWidget = $scope.removeWidget = function (obj) {
            LoadBehaviorCaller = [];
            $scope.widgets.splice(obj.i, 1);
            $scope.$parent.dash.nWidgets--;
            $scope.$broadcast('dataloaded');
        };


        $rootScope.addWidgetFirst = $scope.addWidgetFirst = function (obj) {
            $scope.widgets.unshift($.parseJSON(obj));
            $scope.$parent.dash.nWidgets++;
            $scope.$broadcast('dataloaded');
            $rootScope.loadDragWidgets();
        };

        $rootScope.addWidgetLast = $scope.addWidgetLast = function (obj) {
            //$scope.widgets.push($.parseJSON(obj));
            var fixedItems = 3;
            var widget = $.parseJSON(obj);
            $scope.widgets.splice($scope.widgets.length - fixedItems, 0, $.parseJSON(obj));
            $scope.$parent.dash.nWidgets++;
            $scope.$broadcast('dataloaded');
            $rootScope.loadDragWidgets();
            /*
            console.log(widget);
            $('ul.list-gridster li.box-column').each(function(i, e){
                console.log($(e).attr("data-widget"));
                if ($(e).attr("data-widget") == widget.id){
                    console.log($(e).html());
                    $rootScope.$gridster.add_widget($(e).html());
                }
            });*/
        };

        $rootScope.repositionWidgets = $scope.repositionWidgets = function () {

            var noOfPos = 1;
            if ($rootScope.$gridster != null) {
                var cell = $rootScope.$gridster.get_highest_occupied_cell();
                var max_row = cell.row;

                var move_to_col = 0;
                var move_to_row = 0;

                for (var r = 1; r <= max_row; r++) {
                    for (var c = 1; c <= 3; c++) {
                        if ($rootScope.$gridster.is_empty(c, r)) {
                            var nextCol = c + 1;
                            var nextRow = r;
                            if (nextCol == 4) {
                                nextCol = 1;
                                nextRow = r + 1;
                            }

                            var nextEmpty = $rootScope.$gridster.is_empty(nextCol, nextRow);

                            move_to_col = move_to_col == 0 ? c : move_to_col;
                            move_to_row = move_to_row == 0 ? r : move_to_row;


                            if (nextEmpty)
                                noOfPos++;
                            else {
                                for (var n = 1; n <= noOfPos; n++) {
                                    var nextWdgt = $rootScope.$gridster.is_widget(nextCol, nextRow);
                                    if (nextWdgt) {
                                        var colSize = nextWdgt.context.attributes["data-sizex"].value;

                                        if (colSize == 3 && move_to_col > 1) {
                                            var isFound = false;
                                            for (var nr = nextRow + 1; nr <= max_row; nr++) {
                                                for (var nc = 1; nc <= 3; nc++) {
                                                    nextWdgt = $rootScope.$gridster.is_widget(nc, nr);
                                                    if (nextWdgt) {
                                                        colSize = nextWdgt.context.attributes["data-sizex"].value;
                                                        if (colSize == 1) {
                                                            isFound = true;
                                                            break;
                                                        }
                                                    }
                                                }
                                                if (isFound)
                                                    break;
                                            }
                                        }

                                        if (colSize == 1 || (colSize == 3 && move_to_col == 1)) {
                                            $rootScope.$gridster.new_move_widget_to(nextWdgt, move_to_col, move_to_row);
                                            move_to_col++;
                                            if (move_to_col > 3) {
                                                move_to_col = 1;
                                                move_to_row++;
                                            }
                                        }
                                    }
                                    nextCol++;
                                    if (nextCol > 3) {
                                        nextCol = 1;
                                        nextRow++;
                                    }
                                    move_to_col = (n == noOfPos) ? 0 : move_to_col;
                                    move_to_row = (n == noOfPos) ? 0 : move_to_row;
                                    noOfPos = (n == noOfPos) ? 1 : noOfPos;
                                }
                            }
                        }
                    }
                }
            }
        };

        //$rootScope.repositionWidgets = $scope.repositionWidgets = function () {

        //    var isMoved = true;
        //    var noOfPos = 1;

        //    var cell = $rootScope.$gridster.get_highest_occupied_cell();
        //    var max_col = cell.col;
        //    var max_row = cell.row;

        //    var move_to_col = 0;
        //    var move_to_row = 0;

        //    for (var r = 1; r <= max_row; r++) {
        //        for(var c = 1; c <= 3; c++ )
        //        {
        //            if ($rootScope.$gridster.is_empty(c,r))
        //            {                        
        //                var nextCol = c + 1;
        //                var nextRow = r;
        //                if (nextCol == 4)
        //                {
        //                    nextCol = 1;
        //                    nextRow = r + 1;
        //                }

        //                var nextWdgt = $rootScope.$gridster.is_widget(nextCol, nextRow);

        //                if (isMoved) {
        //                    move_to_col = c;
        //                    move_to_row = r;
        //                    noOfPos = 1;
        //                }
        //                else
        //                    noOfPos++;

        //                if (nextWdgt)
        //                {
        //                    isMoved = false;
        //                    for(var  n = 1; n <= noOfPos; n++)
        //                    {
        //                        var colSize = nextWdgt.context.attributes["data-sizex"].value;
        //                        if (colSize == 1 || (colSize == 3 && move_to_col == 1)) {
        //                            $rootScope.$gridster.new_move_widget_to(nextWdgt, move_to_col, move_to_row);
        //                            isMoved = true;
        //                            move_to_col++;
        //                            if (move_to_col > 3) {
        //                                move_to_col = 1;
        //                                move_to_row++;
        //                            }
        //                        }                                
        //                    }
        //                }
        //                else
        //                    isMoved = false;                            
        //            }
        //        }
        //    }
        //};

        $rootScope.addWidgetForIndex = $scope.addWidgetForIndex = function (i, obj) {
            /*
            for (var w = 0; w < $scope.widgets.length; w++) {
                if ($scope.widgets[w].id == $.parseJSON(obj).id) {
                    $scope.widgets[w].title = $.parseJSON(obj).title;
                }
            }*/
            //$scope.widgets = (JSON.parse(JSON.stringify($scope.widgets)));
            //quando reset (splice) ele chama o UserWidgetBookmark de novo


            //$scope.widgets.splice(i, 1, (JSON.parse(JSON.stringify($scope.widgets[i]))));
            //$scope.$parent.dash.nWidgets++;
            $scope.widgets.splice(i, 1, $.parseJSON(obj));
            $scope.$parent.dash.nWidgets++;
            setTimeout(function () {
                $scope.$broadcast('dataloaded');
            }, 300);
        };


        $scope.viewUserPhotos = function (user) {
            $scope.userFriendsSearch = false;
            $rootScope.viewUserPhotos(user);
        };

        $scope.updateFacebookFriendsList = function () {
            $scope.facebookPhoto.viewDetail = false;
            $scope.facebookPhoto.friendName = '';
            $rootScope.showFriendsList();
        };

        $rootScope.attWidget = $scope.attWidget = function (id, obj) {
            var objSelected = {},
                objIndex = 0;
            for (var i in $scope.widgets) {
                if ($scope.widgets[i].id === id) {
                    objSelected = $scope.widgets[i];
                    objSelected.i = objIndex = i;
                }
            }
            $scope.addWidgetForIndex(objIndex, obj);
        };

        $scope.showEditTitle = function (i) {
            var widget = $scope.widgets[i];
            widget.editTitle = true;
            widget.newTitle = widget.title;
        };


        $rootScope.updatePosition = $scope.updatePosition = function (widgets) {
            var widget = widgets,
                url = '/REST/UserWidget/SetPosition';


            $http.post(url, widgets)
                .success(function (data, status, headers, config) {
                    if (data.status)
                        console.log(data);
                    else
                        console.log(data);
                })
                .error(function (data, status, headers, config) {
                    console.log(data);
                });

        };

        $scope.submitTitle = function (i) {
            var widget = $scope.widgets[i],
                url = '/REST/UserWidget/UpdateTitle',
                title = '';
            widget.editTitle = false;
            title = widget.title;
            widget.title = 'Saving title...';

            $http.post(url, { id: widget.id, title: widget.newTitle })
                .success(function (data, status, headers, config) {
                    if (data.status)
                        widget.title = widget.newTitle;
                    else
                        widget.title = title;
                })
                .error(function (data, status, headers, config) {
                    widget.title = title;
                });
        };

        $scope.edit = function (widget) {
            $rootScope.edit = {
                id: widget.id,
                title: widget.title
            };
        };

        $scope.loadedWidget = 0;
        $rootScope.loadWidget = $scope.loadWidget = function () {
            $scope.loadedWidget++;
            if ($scope.widgets.length <= $scope.loadedWidget) {
                $scope.wasLoaded = true;
            }
        };
    }])


    // Controller for GoogleSearchCtrl in /GoogleSearch.aspx
    .controller('GoogleSearchCtrl', ['$scope', '$rootScope', '$http', '$sce', '$location', function ($scope, $rootScope, $http, $sce, $location) {

        $rootScope.forceNoWidgetsHide = true;
        $scope.searchResult = [];

        var qsSearch = 'q';
        var urlSegs = $location.$$absUrl.toString();

        qsSearch = qsSearch.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
        var regex = new RegExp("[\\?&]" + qsSearch + "=([^&#]*)"),
            results = regex.exec(urlSegs);

        results == null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));


        $http.get('/REST/GoogleSearch/' + results[1] + '?m=' + (new Date()).getMilliseconds(), { cache: false })
            .success(function (data, status, headers, config) {

                var searchResult = $.parseJSON(data.response);
                for (var ic = 0; ic < searchResult.responseData.results.length; ic++) {
                    searchResult.responseData.results[ic].content = $sce.trustAsHtml(searchResult.responseData.results[ic].content);
                }

                $scope.searchResult = searchResult.responseData.results;
            })
            .error(function (data, status, headers, config) {

            });
    }])

    .controller('DeleteWidgetCtrl', ['$scope', '$rootScope', '$http', function ($scope, $rootScope, $http) {
        $scope.feedbackDelete = {};
        $scope.deleteConfirm = function () {
            $scope.feedbackDelete.msg = 'Deleting frame...';
            $scope.feedbackDelete.status = true;
            $('ul.list-gridster li.box-column').each(function (i, e) {
                if ($(e).attr("data-widget") == $rootScope.deleteItem.id) {
                    if ($rootScope.$gridster != null) {
                        $rootScope.$gridster.remove_widget(e);
                        $rootScope.repositionWidgets();
                        var gridsterItems = $rootScope.$gridster.serialize();
                        $rootScope.updatePosition(gridsterItems);
                    }
                }
            });

            $http.post('/REST/UserWidget/Delete/' + $rootScope.deleteItem.id)
                .success(function (data, status, headers, config) {
                    if (data.status) {
                        $scope.feedbackDelete.msg = 'Frame deleted. Updating page...';
                        $scope.feedbackDelete.status = true;
                        $rootScope.removeWidget($rootScope.deleteItem);
                        $scope.$broadcast('closeColorbox');
                        $('#closeModal').trigger('click');
                    } else {
                        $scope.feedbackDelete.msg = data.response;
                        $scope.feedbackDelete.status = false;
                    }
                })
                .error(function (data, status, headers, config) {
                    $scope.feedbackDelete.msg = data.response;
                    $scope.feedbackDelete.status = false;
                });
        };
    }])

    // Controller for HeaderCtrl in /Default.aspx
    .controller('HeaderCtrl', ['$window', '$scope', '$http', '$rootScope', '$injector', 'filterDash', function ($window, $scope, $http, $rootScope, $injector, filterDash) {
        $scope.$inject = ['$scope', 'filterDash'];
        $scope.filterCategory = 0;

        $scope.logout = function () {
            $http.get('/REST/User/Logout?m=' + (new Date()).getMilliseconds(), { cache: false }).
                success(function (data, status, headers, config) {
                    if (data.status)
                        window.location.href = '/';
                })
                .error(function () {

                });
        };


        $scope.getTrusteds = function () {
            /*
            $http.get('/REST/UserWidgetCategory?m=' + (new Date()).getMilliseconds(), { cache: false })
                .success(function (data, status, headers, config) {
                    $scope.trustedSource = data;
                })
                .error(function (data, status, headers, config) {

                });
                */
            $scope.trustedSource = _page.trustedSource;

        };

        $scope.getTrusteds();

        $scope.changeCategory = function (val) {
            $scope.filterCategory = val;
            filterDash.prepForBroadcast(val);
        };

        $scope.googleSearch = function () {
            $("#btnGoogleSearch").trigger("click");
        };

        $scope.addBookmark = function (e) {
            // Mozilla Firefox Bookmark
            if ('sidebar' in $window && 'addPanel' in $window.sidebar) {
                $window.sidebar.addPanel(location.href, document.title, "");
            } else if ( /*@cc_on!@*/false) { // IE Favorite
                $window.external.AddFavorite(location.href, document.title);
            } else { // webkit - safari/chrome
                alert('Press ' + (navigator.userAgent.toLowerCase().indexOf('mac') != -1 ? 'Command/Cmd' : 'CTRL') + ' + D to bookmark this page.');
            }
        };
    }])

    // Controller for WeatherCtrl in /Templates/Weather.html
    .controller('WeatherCtrl', ['$scope', '$http', '$sce', '$rootScope', function ($scope, $http, $sce, $rootScope) {
        $scope.weather = { address: ($scope.$parent.widget.zipCode != null) ? $scope.$parent.widget.zipCode : '10001', lastUpdate: new Date(), location: '', currentTemp: 0, forecast: [], firstLoad: true };

        $scope.loadWeather = function () {

            $http.get('/REST/UserWidgetWeather/CurrentWeather/' + $scope.weather.address + '?WidgetId=' + $scope.$parent.widget.id + '&m=' + (new Date()).getMilliseconds())
                .success(function (data, status, headers, config) {
                    if (data.status) {
                        var geoweather = $.parseJSON(data.response);
                        $scope.weather.forecast = geoweather.weather;
                        $scope.weather.location = geoweather.location;
                        $scope.weather.currentTemp = $scope.weather.forecast[0].currentTemp;
                        $scope.weather.lastUpdate = $scope.weather.forecast[0].dateWeatherLabel;


                        if ($scope.weather.firstLoad) {
                            $scope.weather.firstLoad = false;
                            $rootScope.loadWidget();
                        }
                    } else {
                        alert(data.response);
                    }
                })
                .error(function (data, status, headers, config) {
                    //alert('weather error');
                });
        }

        if ($scope.weather.firstLoad) {
            $scope.loadWeather();
        }


    }])

    // Controller for FacebookCtrl in /Templates/Facebook.html
    .controller('FacebookCtrl', ['$scope', '$http', '$sce', '$rootScope', function ($scope, $http, $sce, $rootScope) {
        $scope.facebookUserLogged = false;
        $scope.facebookFeed = [];

        (function (d) {
            var js, id = 'facebook-jssdk', ref = d.getElementsByTagName('script')[0];
            if (d.getElementById(id)) { return; }
            js = d.createElement('script'); js.id = id; js.async = true;
            js.src = "//connect.facebook.net/en_US/all.js";
            ref.parentNode.insertBefore(js, ref);
        }(document));

        window.fbAsyncInit = function () {
            $scope.$apply(function () {
                FB.init({
                    appId: _facebookAppId, // App ID
                    status: true, // check login status
                    cookie: true, // enable cookies to allow the server to access the session
                    xfbml: true  // parse XFBML
                });
                $scope.loadFacebookNewsFeed();
            });

        };

        $scope.facebookLogin = function () {
            FB.login(function (response) {

                if (response.authResponse) {
                    $scope.loadFacebookNewsFeed();
                } else {
                    alert('Not Authorized');
                }

            }, { scope: 'read_stream' });
        }


        $scope.processItemFeed = function (data) {
            var oResponse = data;
            var ltItems = [];
            for (var i = 0; i < oResponse.length; i++) {
                var item = { nameFrom: '', url: '#', photo: '', message: '', id: 0 };


                if (oResponse[i].message != undefined) {
                    if (oResponse[i].id != 0) {
                        item.id = oResponse[i].id;
                        if (oResponse[i].type == "link") {
                            item.url = "https://www.facebook.com/" + oResponse[i].id;
                        } else if (oResponse[i].type == "status") {
                            item.url = "https://www.facebook.com/" + oResponse[i].id;
                        } else if (oResponse[i].type == "photo") {
                            item.url = oResponse[i].link;
                        } else {
                            item.url = "https://www.facebook.com/" + oResponse[i].id;
                        }
                        item.photo = "https://graph.facebook.com/" + oResponse[i].from.id + "/picture";
                    } else {
                        item.photo = oResponse[i].from.photo;
                    }
                    item.nameFrom = oResponse[i].from.name;
                    item.message = oResponse[i].message;
                    ltItems.push(item);
                }
            }
            return ltItems;
        };

        $scope.loadFacebookNewsFeed = function () {

            if ($scope.widget.isDefault) {
                if ($scope.widget.token != '') {
                    $scope.wasLoaded = false;
                    $scope.facebookUserLogged = true;

                    var data = [];
                    data.push({ message: 'Check your local weather in real time, just type your zip code or address into the Weather Frame.', id: 0, from: { id: 0, name: 'Take 65', photo: '/Img/Default/take65-icon-34x34.png' } });
                    data.push({ message: 'Take 65 is your trusted source for security and simplicity on the web.', id: 0, from: { id: 0, name: 'Take 65', photo: '/Img/Default/take65-icon-34x34.png' } });
                    data.push({ message: 'With the Social Media Photo feature you can access your family & friends\' photos directly from your Take 65 dashboard.', id: 0, from: { id: 0, name: 'Take 65', photo: '/Img/Default/take65-icon-34x34.png' } });
                    data.push({ message: 'Join Take 65 right now clicking on the top menu \'Join TAKE 65\'', id: 0, from: { id: 0, name: 'Take 65', photo: '/Img/Default/take65-icon-34x34.png' } });

                    $scope.facebookFeed = $scope.processItemFeed(data);

                    $scope.wasLoaded = true;
                    $rootScope.$broadcast('dataloaded');


                }
            } else {

                FB.getLoginStatus(function (response) {
                    if (response.status === 'connected') {
                        $scope.wasLoaded = false;
                        $scope.facebookUserLogged = true;

                        FB.api('/me/home', 'get', function (response) {
                            $scope.$apply(function () {
                                if (!response || response.error) {
                                    $scope.facebookUserLogged = false;
                                    $scope.$broadcast('dataloaded');
                                } else {
                                    $scope.facebookFeed = $scope.processItemFeed(response.data);
                                    $scope.wasLoaded = true;
                                    $rootScope.$broadcast('dataloaded');

                                }
                            });
                        });

                    } else if (response.status === 'not_authorized') {
                        alert('Not Authorized');
                        // not_authorized
                    } else {
                        //alert('Not logged');
                        // not_logged_in
                    }


                });

            }
        };

        $rootScope.loadWidget();
    }])

    // Controller for FeedCtrl in /Templates/Feed.html
    .controller('FeedCtrl', ['$scope', '$http', '$sce', '$rootScope', function ($scope, $http, $sce, $rootScope) {
        $scope.wasLoaded = false;
        if (_page.userWidgetFeed[('items_' + $scope.widget.id)] == undefined) {
            $http.get('/REST/UserWidgetFeedContent/' + $scope.widget.id + '/?m=' + (new Date()).getMilliseconds(), { cache: false }).
                success(function (data, status, headers, config) {
                    if (data.length > 0) {
                        $scope.highlight = data.shift();
                        $scope.highlight.description = $sce.trustAsHtml($scope.highlight.description);

                        $scope.feeds = data;

                        //$rootScope.$broadcast('dataloaded');
                        //$scope.$broadcast('callCarousel');
                        $rootScope.loadWidget();
                    }
                    $scope.wasLoaded = true;
                })
                .error(function (data, status, headers, config) {

                });
        } else {

            $scope.highlight = _page.userWidgetFeed[('items_' + $scope.widget.id)].shift();
            $scope.highlight.description = $sce.trustAsHtml($scope.highlight.description);
            $scope.feeds = _page.userWidgetFeed[('items_' + $scope.widget.id)];
            $rootScope.loadWidget();

            $scope.wasLoaded = true;
        }

        $scope.$on('ngRepeatFinished', function (ngRepeatFinishedEvent) {
            $rootScope.$broadcast('dataloaded');
            $scope.$broadcast('callCarousel');
        });

    }])

    // Controller for MoreFeedCtrl in /Templates/MoreFeed.html
    .controller('MoreFeedCtrl', ['$scope', '$http', '$sce', '$rootScope', function ($scope, $http, $sce, $rootScope) {
        $scope.widget = {}; // cria o objeto widget
        $scope.widget.id = $rootScope.widgets.attrsClick.id; // id do widget
        $scope.widget.count = 10; // de quantos em quantos itens deve ser feito o carregamento
        $scope.widget.skip = 0; // Quantos itens deve pular para trazer no ajax
        $scope.loading = false; // status se está carregando conteúdo ou não
        $scope.hasMore = false; // Se tem ou não botão de view more
        $scope.statusLoad = true; // True adiciona classe 'success' na mensagem de load e false adiciona classe 'error'
        $scope.msgfeedback = ''; // Mensagem de feedback enquanto carrega
        $scope.txtBtnMoreNews = 'More News'; // texto do botão de carregar mais
        $scope.category = 0;
        $scope.qFilter = '';

        $http.get('/REST/UserWidgetFeed/' + $scope.widget.id + '?m=' + (new Date()).getMilliseconds(), { cache: false })
            .success(function (data, status, headers, config) {
                $scope.widget.title = data.userWidget.title; // Recebe o titulo do widget
                if (data.trustedSource.length > 0) {
                    delete $scope.trustedSource;
                    $scope.trustedSource = data.trustedSource;
                }
                $scope.widget.wasLoaded = true;

                $rootScope.$broadcast('dataloaded');
            })
            .error(function (data, status, headers, config) {
            });

        $scope.getFeeds = function (more) {
            $scope.loading = true;
            $scope.txtBtnMoreNews = 'Loading...';
            $scope.widget.wasLoaded = false;

            $http.get('/REST/UserWidgetFeedContent/' + $scope.widget.id + '/' + $scope.widget.count + '/' + $scope.widget.skip + '/' + $scope.category + '/' + (($scope.qFilter !== '') ? $scope.qFilter : '') + '?m=' + (new Date()).getMilliseconds(), { cache: false })
                .success(function (data, status, headers, config) {

                    $scope.hasMore = (data.length < $scope.widget.count) ? false : true;
                    $scope.feeds = (more) ? $scope.feeds.concat(data) : $scope.feeds = data;


                    $rootScope.$broadcast('dataloaded');
                    $scope.loading = false;
                    $scope.txtBtnMoreNews = 'More News';
                    $scope.widget.wasLoaded = true;
                })
                .error(function (data, status, headers, config) {
                    $scope.loading = false;
                    $scope.msgfeedback = 'Error, try again.';
                });
        };

        // Carrega mais itens
        $scope.loadMore = function () {
            if (!$scope.loading) {
                $scope.widget.skip += $scope.widget.count;
                $scope.getFeeds(true);
            }
        };

        $scope.setTrusted = function (filter) {
            $scope.widget.skip = 0;
            $scope.category = filter;
            $scope.getFeeds();
        };

        $scope.searchNews = function () {
            $scope.getFeeds();
        };

        $scope.getFeeds(false);
    }])

    // Controller for MyWebsiteCtrl in /Templates/MyWebsite.html

    .controller('MyWebsiteCtrl', ['$scope', '$http', '$sce', '$rootScope', function ($scope, $http, $sce, $rootScope) {
        if (_page.userWidgetBookmark[('items_' + $scope.widget.id)] == undefined) {
            $http.get('/REST/UserWidgetBookmark/' + $scope.widget.id + '/?m=' + (new Date()).getMilliseconds(), { cache: false }).
                success(function (data, status, headers, config) {
                    $scope.source = []
                        .concat(_.map(data.trustedSource, function (item) {
                            item.trusted = true;
                            return item;
                        }))
                        .concat(_.map(data.source, function (item) {
                            item.trusted = false;
                            return item;
                        }))
                        .slice(0, 8);

                    $rootScope.$broadcast('dataloaded');
                    $rootScope.loadWidget();

                    $scope.widget.sourcesLength = data.trustedSource.length + data.source.length;
                })
                .error(function (data, status, headers, config) {

                });
        } else {
            $scope.source = []
                        .concat(_.map(_page.userWidgetBookmark[('items_' + $scope.widget.id)].trustedSource, function (item) {
                            item.trusted = true;
                            return item;
                        }))
                        .concat(_.map(_page.userWidgetBookmark[('items_' + $scope.widget.id)].source, function (item) {
                            item.trusted = false;
                            return item;
                        }))
                        .slice(0, 8);

            $rootScope.$broadcast('dataloaded');
            $rootScope.loadWidget();

            $scope.widget.sourcesLength = _page.userWidgetBookmark[('items_' + $scope.widget.id)].trustedSource.length + _page.userWidgetBookmark[('items_' + $scope.widget.id)].source.length;
        }
    }])

    // Controller for MoreWebsiteCtrl in /Templates/MoreMyWebsite.html
    .controller('MoreWebsiteCtrl', ['$scope', '$http', '$sce', '$rootScope', function ($scope, $http, $sce, $rootScope) {
        $scope.widget = {}; // cria o objeto widget
        $scope.widget.id = $rootScope.widgets.attrsClick.id; // id do widget
        $scope.widget.title = $rootScope.widgets[$rootScope.widgets.attrsClick.indexWidget].title; // Pega o titulo do widget já armazenado em $rootScope de acordo com o index de array que está no botão

        $http.get('/REST/UserWidgetBookmark/' + $scope.widget.id + '?m=' + (new Date()).getMilliseconds(), { cache: false })
            .success(function (data, status, headers, config) {
                if (data.trustedSource.length > 0) {
                    $scope.trustedSource = data.trustedSource;
                }

                if (data.source.length > 0) {
                    $scope.source = data.source;
                }

                $rootScope.$broadcast('dataloaded');
            })
            .error(function (data, status, headers, config) {
            });
    }])


    .controller('MyProfileCtrl', ['$scope', '$http', '$rootScope', function ($scope, $http, $rootScope) {
        $scope.changePassword = false;
        $scope.step = 1;
        //$scope.user = { email: '', name: '', facebookId: '', yearofbirth: '', gender: '', password: '', preference: [] };
        $scope.userPrefences = [];

        $http.get('/REST/User/?m=' + (new Date()).getMilliseconds())
            .success(function (data, status, headers, config) {
                if (data.id != undefined) {
                    $scope.user = data;
                } else {
                    window.location.href = '/?SessionExpired';
                }
            })
            .error(function (data, status, headers, config) {
                $scope.feedbackRegister.msg = data.response;
                $scope.feedbackRegister.status = false;
            });


        $scope.setStep = function (i) {
            //alert(i);
            var retStep = true;
            switch (i) {
                case 2:
                    retStep = $scope.step2();
                    break;
            }

            if (!retStep)
                return false;

            $scope.step = i;
            $rootScope.$broadcast('dataloaded');
        };

        $scope.getChkId = function (list) {
            var chkList = [];

            for (var i in list) {
                if (list[i].chk)
                    chkList.push({ id: list[i].id });
            }

            return chkList;
        };

        $scope.step2 = function () {
            if ($scope.register.$invalid) {
                $scope.register.showMessage = true;
                return false;
            }

            $http.get('/REST/UserPreference/?m=' + (new Date()).getMilliseconds())
                .success(function (data, status, headers, config) {
                    if (data.length > 0) {
                        $scope.userPrefences = data;
                    }
                    var list = $scope.userPrefences;
                    for (var i in list) {
                        for (var n in $scope.user.preference) {
                            if (list[i].id == $scope.user.preference[n].id) {
                                list[i].chk = true;
                            }
                        }
                    }
                    $scope.wasLoaded = true;
                    $rootScope.$broadcast('dataloaded');
                })
                .error(function (data, status, headers, config) {
                });

            return true;
        };

        $scope.userChangePassword = function () {
            $scope.changePassword = !$scope.changePassword;
            $.colorbox.resize();
        };
        $scope.submit = function () {
            var deafultUser = {
                facebookId: '',
                login: '',
                password: '',
                name: '',
                email: '',
                birthdate: '',
                yearofbirth: '',
                gender: '',
                state: '',
                city: '',
                postalCode: '',
                preference: []
            };

            $scope.user.preference = $scope.getChkId($scope.userPrefences);
            $scope.user.categories = $scope.getChkId($scope.categories);
            $scope.user.birthdate = '';

            $scope.feedbackRegister = {
                msg: 'Updating user...',
                status: true
            };

            var user = angular.extend(deafultUser, $scope.user);

            $http.post('/REST/User/Update/', user)
                .success(function (data, status, headers, config) {
                    if (data.status) {
                        $.colorbox.close();
                        $scope.$broadcast('closeColorbox');
                        $('#closeModal').trigger('click');
                    } else {
                        $scope.feedbackRegister.msg = data.response;
                        $scope.feedbackRegister.status = false;
                    }
                })
                .error(function (data, status, headers, config) {
                    $scope.feedbackRegister.msg = data.response;
                    $scope.feedbackRegister.status = false;
                });
        };
    }])


    // Controller for RegisterCtrl in /Templates/Register.html
    .controller('RegisterCtrl', ['$scope', '$http', '$rootScope', 'gcfg', function ($scope, $http, $rootScope, gcfg) {
        $scope.overlayClose = false;
        $scope.step = 1;
        $scope.facebook = { register: false };
        console.log(gcfg);
        $scope.user = { email: $scope.newUseremail };
        if ($scope.newUseremail != "") {
            $scope.step = 2;
        }

        //$scope.user = $scope.user || {};
        //$scope.user.email = 'asda@asas.com';
        var yr = new Date().getFullYear();
        var minyear = yr - 100; // at most 100year old 
        //var maxyear = yr - 18; //at lease 18yr older
        var years = [];
        for (var i = parseInt(minyear) ; i <= parseInt(yr) ; i++) {
            //conole.log(i);
            years.push(i);
        }
        $scope.byears = years;
        $scope.user.yearofbirth = yr - 65;
        //console.log(years);

        //clear feedback errors to start clean
        $scope.clearFeedback = function () {
            $scope.google.feedback.msg = '';
            $scope.facebook.feedback.msg = '';
        };

        $scope.setStep = function (i) {
            var retStep = true;
            switch (i) {
                case 2:
                    retStep = $scope.step2();
                    break;
                case 3:
                    retStep = $scope.step3();
                    break;
                case 4:
                    retStep = $scope.step4();
                    break;
            }

            if (!retStep)
                return false;

            $scope.step = i;
            $rootScope.$broadcast('dataloaded');
        };

        $scope.getChkId = function (list) {
            var chkList = [];

            for (var i in list) {
                if (list[i].chk)
                    chkList.push({ id: list[i].id });
            }

            return chkList;
        };

        $scope.step2 = function () {
            return true;
        };

        $scope.step3 = function () {
            if ($scope.register.$invalid && !$scope.facebook.register && !$scope.google.register) {
                $scope.register.showMessage = true;
                return false;
            }

            $http.get('/REST/UserPreference/?m=' + (new Date()).getMilliseconds())
                .success(function (data, status, headers, config) {
                    if (data.length > 0) {
                        $scope.userPrefences = data;
                    }
                    $scope.wasLoaded = true;
                    $rootScope.$broadcast('dataloaded');
                })
                .error(function (data, status, headers, config) {
                });

            return true;
        };

        $scope.step4 = function () {
            $http.get('/REST/TrustedSourceCategory/?m=' + (new Date()).getMilliseconds(), { cache: false })
                .success(function (data, status, headers, config) {
                    $scope.wasLoadedCategories = true;
                    if (data.length > 0) {
                        $scope.categories = data;
                    }

                    $rootScope.$broadcast('dataloaded');
                })
                .error(function (data, status, headers, config) {
                });

            return true;
        };

        $scope.submit = function () {
            var deafultUser = {
                facebookId: '',
                googleId: '',
                login: '',
                password: '',
                name: '',
                email: '',
                birthdate: '',
                yearofbirth: '',
                gender: '',
                state: '',
                city: '',
                postalCode: '',
                preference: []
            };

            $scope.user.preference = $scope.getChkId($scope.userPrefences);
            $scope.user.categories = $scope.getChkId($scope.categories);
            $scope.user.email = $scope.register.email.$modelValue;
            $scope.feedbackRegister = {
                msg: 'Registering user...',
                status: true
            };

            var user = angular.extend(deafultUser, $scope.user);

            $http.post('/REST/User/', user)
                .success(function (data, status, headers, config) {
                    if (data.status) {
                        //$scope.feedbackRegister.msg = 'Register OK.';
                        //window.location.href = '/';
                        $('#openWizard').trigger('click');
                        //$scope.$parent.nextCustomStep();
                    } else {
                        $scope.feedbackRegister.msg = data.response;
                        $scope.feedbackRegister.status = false;
                    }
                })
                .error(function (data, status, headers, config) {
                    $scope.feedbackRegister.msg = data.response;
                    $scope.feedbackRegister.status = false;
                });
        };
        //gplus register
        $scope.registerGoogle = function () {
            console.log("register with google called...");
            //initlaize local variables
            $scope.google = {};
            $scope.google.feedback = {};
            $scope.google.feedback.status = true;
            //$scope.clearFeedback();
            // $scope.facebook.feedback.msg = '';
            $scope.google.feedback.msg = 'Authenticating on Google...';
            $rootScope.$broadcast('dataloaded');
            //flag to ensure only one callback
            var calbackflag = false;
            console.log("calling gapi.auth.singIn....");
            gapi.auth.signIn({
                'clientid': gcfg.clientId,
                'state': gcfg.state,
                'cookiepolicy': 'single_host_origin',
                'accesstype': 'offline',
                'responsetype': 'code',
                'approvalprompt': 'auto',
                'includegrantedscopes': 'true',
                'redirecturi': 'postmessage',
                'scope': gcfg.scopes.plus + " " + gcfg.scopes.me + " " + gcfg.scopes.email + " " + gcfg.scopes.profile,
                'callback': function (authresult) {
                    if (!calbackflag) {
                        if (typeof authresult["code"] != 'undefined') {
                            calbackflag = true;
                        }
                        console.log("Aplication state :   ", gcfg.state);
                        console.log("in google singn callback on gapi.auth.signIn -- authresult...");
                        console.log("authresult --- ", authresult);
                        console.log("authresult[status][method]----", authresult["status"]["method"]);
                        console.log("autherization code ....", authresult["code"]);
                        console.log("access tocken ....", authresult["access_token"]);
                        console.log("post to /REST/User/RegisterGoogleAccount  params... state:   ", gcfg.state, "authcode:  ", authresult["code"]);
                        $http.post('/REST/User/RegisterGoogleAccount', { state: gcfg.state, authcode: authresult["code"] }).
                            success(function (data) {
                                console.log("response received :  ", data.response);
                                if (data.status) {
                                    //console.log(data.response);
                                    //take it though customizing home page process
                                    $scope.setStep(2);

                                    $scope.user.googleId = gcfg.state;
                                    $scope.google.register = true;
                                    $scope.google.feedback.status = true;
                                    $scope.google.feedback.msg = '';
                                }
                                else {
                                    //console.log(data.response);
                                    //inform the user to use login
                                    //$scope.google.feedback = 'Google Account Already Exists';
                                    console.log("Google account already registered...  REST response:   " + data.response);
                                    if (data.response.length > 0) {
                                        $scope.google.feedback.msg = data.response;
                                    }
                                    else {
                                        $scope.google.feedback.msg = 'Google account already registered';
                                    }

                                    $scope.google.feedback.status = false;
                                    //window.location.href = '/';
                                }
                            })
                            .error(function () {

                                console.log("FATAL ERROR -- google user could not be registered...");
                                $scope.google.feedback.msg = 'Google account is not available';
                                $scope.google.feedback.status = false;
                            });
                    }
                }
            })
        }

        $scope.registerFacebook = function () {
            $scope.facebook = {};
            $scope.facebook.feedback = {};
            $scope.facebook.feedback.status = true;
            //$scope.clearFeedback();
            //$scope.google.feedback.msg = '';
            $scope.facebook.feedback.msg = 'Authenticating on facebook...';
            $rootScope.$broadcast('dataloaded');
            console.log("registerFacebook called....");

            FB.login(function (response) {
                if (response.authResponse) {
                    var authResponse = response.authResponse;

                    // Get user facebook data
                    FB.api('/me', function (response) {
                        // Check if user already has a registry in our site
                        $scope.facebook.response = response;
                        //if(response.email.length > 0) {
                        //check if email registered in take65 
                        $http.post('/REST/User/Check', { email: response.email }).
                            success(function (res) {
                                console.log("/REST/User/Check .. response - ", res.response);
                                if (!(res.status)) {
                                    var errmsg = $scope.facebook.response.email + "  is already registered with take65";
                                    console.log(errmsg);
                                    $scope.facebook.feedback.status = false;
                                    $scope.facebook.feedback.msg = errmsg;
                                }
                                else {
                                    $http.post('/REST/User/CheckFacebook', { facebookId: response.id }).
                                        success(function (data) {
                                            if (data.status) {
                                                //$scope.$apply(function () {
                                                $scope.setStep(2);
                                                $scope.user.email = $scope.facebook.response.email;
                                                $scope.user.facebookId = $scope.facebook.response.id;
                                                $scope.user.name = $scope.facebook.response.name;
                                                if ($scope.facebook.response.location != undefined) {
                                                    $scope.user.city = $scope.facebook.response.location.name;
                                                }
                                                $scope.user.gender = $scope.facebook.response.gender;
                                                $scope.facebook.register = true;
                                                //});
                                            }
                                            else {
                                                $http.post('/REST/User/Login', { facebookId: response.id, facebookToken: authResponse.accessToken })
                                                    .success(function (data, status, headers, config) {
                                                        if (data.status) {
                                                            //$scope.facebook.feedback = 'Facebook Account Already Exists';
                                                            $scope.facebook.feedback.msg = 'Facebook Account Already Exists';
                                                            window.location.href = '/';
                                                        }
                                                        else {
                                                            $scope.facebook.feedback.status = false;
                                                            // User did not authorized our application to access his data in Facebook
                                                            $scope.facebook.feedback.msg = 'Your Facebook account is not available at the moment.';
                                                        }
                                                    })
                                                    .error(function (data) {
                                                        $scope.facebook.feedback.status = false;
                                                        // User did not authorized our application to access his data in Facebook
                                                        $scope.facebook.feedback.msg = 'Your Facebook account is not available at the moment.';
                                                    });
                                            }
                                        })
                                        .error(function () {
                                            alert('check facebook error');
                                            $scope.facebook.feedback.status = false;
                                            // User did not authorized our application to access his data in Facebook
                                            $scope.facebook.feedback.msg = 'Your Facebook account is not available at the moment.';
                                        });
                                }
                            }).
                            error(function () {
                                var errmsg = "Error in checking user email take65";
                                console.log(errmsg);
                                $scope.facebook.feedback.status = false;
                                $scope.facebook.feedback.msg = errmsg;
                                return;
                            });
                    });
                }
                else {
                    $scope.facebook.feedback.status = false;
                    // User did not authorized our application to access his data in Facebook
                    $scope.facebook.feedback.msg = 'You have canceled Facebook connection.';
                }
            }, { scope: 'email' });
        };

      
    }])

    // Controller for SupportCtrl in /Templates/Support.html
    .controller('SupportCtrl', ['$scope', '$http', '$rootScope', function ($scope, $http, $rootScope) {
        $scope.feedbackStatus = 'error';
        $scope.isSending = false;
        $scope.isFeedback = false;
        $scope.feedbackMessage = '';
        $scope.title = 'Support Request';
        $scope.userExists = false;

        $http.get('/REST/User/?m=' + (new Date()).getMilliseconds())
           .success(function (data, status, headers, config) {
               if (data.id != undefined) {
                   $scope.name = data.name;
                   $scope.email = data.email;
                   $scope.userExists = true;
               } else {
                   $scope.name = '';
                   $scope.email = '';
                   $scope.userExists = false;
               }
           })
           .error(function (data, status, headers, config) {
               $scope.msgError(data.response);
               $rootScope.$broadcast('dataloaded');
           });

        $scope.submit = function () {
            $scope.isFeedback = false;
            $scope.classStatus = '';
            $scope.supportMessage = 'Sending mail...';
            $scope.isSending = true;
            $rootScope.$broadcast('dataloaded');

            var url = '/REST/User/SendSupportRequestEmail/' + $scope.name + '/' + $scope.email + '/' + $scope.subject + '/' + $scope.issue;

            var objData = {
                name: $scope.name,
                email: $scope.email,
                subject: $scope.subject,
                issue: $scope.issue
            };

            $http.post(url, objData)
                .success(function (data, status, headers, config) {
                    if (data.status) {
                        if (data.response == 'Issue submitted.') {
                            $scope.feedbackStatus = 'success';
                            $scope.supportMessage = 'sent.';
                            $scope.reloadHome = true;
                        }
                    } else {
                        $scope.msgError(data.response);
                    }
                    $rootScope.$broadcast('dataloaded');
                })
                .error(function (data) {
                    $scope.msgError(data.response);
                    $rootScope.$broadcast('dataloaded');
                });
        };
    }])
    .controller('GetToKnowAboutSiteCtrl', ['$scope', '$http', '$rootScope', 'gcfg', function ($scope, $http, $rootScope, gcfg) {
        $scope.title = 'Join Take 65 for Free';
        $scope.newUseremail = '';
        $scope.login = $scope.newUseremail;
        $scope.regsterEmail = function () {
            $http.post('/REST/User/RegisterNewUserEmail', { email: $scope.newUseremail })
               .success(function (data, status, headers, config) {
                   $rootScope.$broadcast('dataloaded');
                   //$rootScope.$broadcast('nglogged');
               })
               .error(function (data) {
                   $scope.msgError(data.response);
                   $rootScope.$broadcast('dataloaded');
               });
        }
    }])
     // Controller for LoginCtrl in /Templates/Login.html
   .controller('LoginCtrl', ['$scope', '$http', '$rootScope', 'gcfg', function ($scope, $http, $rootScope, gcfg) {
       $scope.feedbackStatus = 'error';
       $scope.isSending = false;
       $scope.isFeedback = false;
       $scope.feedbackMessage = '';
       $scope.forgotPass = false;
       $scope.forgotPasswordValid = true;
       $scope.title = 'Login TAKE 65';

       console.log("LoginCtrl ctr.......   ");
       $scope.login = $scope.newUseremail;
       $scope.setForgotPass = function (v) {
           $scope.forgotPass = v;
           $rootScope.$broadcast('dataloaded');

           if (v)
               $scope.title = 'Resend your password';
           else
               $scope.title = 'Login Take 65';
       };

       $scope.forgotPassword = function () {
           $scope.isFeedback = false;
           $scope.isSendingForgot = true;
           $scope.feedbackStatusForgot = 'success';
           $scope.forgotMessage = 'Sending data...';

           $http.post('REST/User/ForgotPassword', { email: $scope.loginForgot })
               .success(function (data, status, headers, config) {

                   if (data.status) {
                       $scope.forgotMessage = '';
                       $scope.feedbackMessage = 'Your new password was sent to ' + $scope.loginForgot + '. Please, check your email.';
                       $scope.isFeedback = true;
                       $scope.setForgotPass(false);
                   } else {
                       $scope.feedbackStatusForgot = 'error';
                       $scope.forgotMessage = data.response;
                   }

                   $rootScope.$broadcast('dataloaded');
                   //$rootScope.$broadcast('nglogged');
               })
               .error(function (data) {
                   $scope.feedbackStatusForgot = 'error';
                   $scope.forgotMessage = data.response;
                   $rootScope.$broadcast('dataloaded');
               });
       };

       // Função para logar com a conta do facebook
       $scope.loginFacebook = function () {
           $scope.isFeedback = false;
           $scope.facebookSending = true;
           $scope.facebookMessage = 'Sending data...';
           $scope.feedbackFacebook = 'success';
           $rootScope.$broadcast('dataloaded');

           FB.login(function (response) {
               if (response.authResponse) {
                   $scope.facebookMessage = 'Authenticated user.';
                   var authResponse = response.authResponse;
                   $rootScope.$broadcast('dataloaded');
                   // Get user facebook data
                   FB.api('/me', function (response) {
                       $scope.facebookMessage = 'Loading user information...';
                       // Check if user already has a registry in our site
                       $http.post('/REST/User/Login', { facebookId: response.id, facebookToken: authResponse.accessToken })
                           .success(function (data, status, headers, config) {
                               if (data.status) {
                                   $scope.facebookMessage = 'Logged';
                                   window.location.href = '/';
                                   $scope.reloadHome = true;
                               } else {
                                   $scope.feedbackFacebook = 'error';
                                   $scope.facebookMessage = data.response;
                               }

                               $rootScope.$broadcast('dataloaded');

                           })
                           .error(function (data) {
                               $scope.feedbackFacebook = 'error';
                               $scope.facebookMessage = data.response;
                               $rootScope.$broadcast('dataloaded');
                           });
                   });
               } else {
                   // User did not authorized our application to access his data in Facebook
                   $scope.feedbackFacebook = 'error';
                   $scope.facebookMessage = 'You have canceled Facebook connection.';
                   $rootScope.$broadcast('dataloaded');
               }
           }, { scope: 'email,read_friendlists,user_photos,friends_photos' });
       };

       //login google
       $scope.loginGoogle = function () {
           $scope.isFeedback = false;
           $scope.googleSending = true;
           $scope.googleMessage = 'Sending data...';
           $scope.feedbackGoogle = 'success';
           $rootScope.$broadcast('dataloaded');

           var calbackflag = false;
           console.log("calling gapi.auth.singIn....");
           gapi.auth.signIn({
               'clientid': gcfg.clientId,
               'state': gcfg.state,
               'cookiepolicy': 'single_host_origin',
               'accesstype': 'offline',
               'responsetype': 'code',
               'approvalprompt': 'auto',
               'includegrantedscopes': 'true',
               'redirecturi': 'postmessage',
               'scope': gcfg.scopes.plus + " " + gcfg.scopes.me + " " + gcfg.scopes.email + " " + gcfg.scopes.profile,
               'callback': function (authresult) {
                   if (!calbackflag) {
                       if (typeof authresult["code"] != 'undefined') {
                           calbackflag = true;
                       }
                       console.log("Aplication state :   ", gcfg.state);
                       console.log("in google singn callback on gapi.auth.signIn -- authresult...");
                       console.log("authresult --- ", authresult);
                       console.log("authresult[status][method]----", authresult["status"]["method"]);
                       console.log("autherization code ....", authresult["code"]);
                       console.log("access tocken ....", authresult["access_token"]);
                       //get google user id
                       if (authresult["access_token"]) {
                           gapi.client.load('plus', 'v1', function () {
                               gapi.client.plus.people.get({ 'userId': 'me' })
                                   .execute(function (resp) {
                                       // Shows profile information
                                       console.log("response received  : ", resp);
                                       console.log("google userid :    ", resp.id);

                                       $http.post('/REST/User/Login', { googleId: resp.id })
                                           .success(function (data, status, headers, config) {
                                               if (data.status) {
                                                   $scope.googleMessage = 'Logged, loading preferences...';
                                                   window.location.href = '/';
                                                   $scope.reloadHome = true;
                                               }
                                               else {
                                                   $scope.feedbackGoogle = 'error';
                                                   $scope.googleMessage = data.response;
                                               }
                                               $rootScope.$broadcast('dataloaded');
                                           })
                                           .error(function (data) {
                                               $scope.feedbackGoogle = 'error';
                                               $scope.googleMessage = data.response;
                                               $rootScope.$broadcast('dataloaded');
                                           });
                                   })
                           });

                           //gapi.client.load("oauth2", "v1", function () {
                           //    var req = gapi.client.oauth2.userinfo.get();
                           //    req.execute(function (res) {
                           //        console.log(res["useremail"]);
                           //    })
                           //})
                       }



                       //    console.log("post to /REST/User/RegisterGoogleAccount  params... state:   ", gcfg.state, "authcode:  ", authresult["code"]);
                       //    $http.post('/REST/User/RegisterGoogleAccount', { state: gcfg.state, authcode: authresult["code"] }).
                       //        success(function (data) {
                       //            console.log("response received :  ", data.response);
                       //            if (data.status) {
                       //                //console.log(data.response);
                       //                //take it though customizing home page process
                       //                $scope.setStep(2);

                       //                $scope.user.googleId = gcfg.state;
                       //                $scope.google.register = true;
                       //            }
                       //            else {
                       //                //console.log(data.response);
                       //                //inform the user to use login
                       //                //$scope.google.feedback = 'Google Account Already Exists';
                       //                console.log("Google account already registered...  REST response:   " + data.response);
                       //                $scope.google.feedback.msg = 'Google account already registered';
                       //                $scope.google.feedback.status = false;
                       //                //window.location.href = '/';
                       //            }
                       //        })
                       //        .error(function () {

                       //            console.log("FATAL ERROR -- google user could not be registered...");
                       //            $scope.google.feedback.msg = 'Google account is not available';
                       //            $scope.google.feedback.status = false;
                       //        });
                       //}
                   }
               }
           })
       }





       // Função para logar com login e password
       $scope.submit = function () {
           //var a = window.open('https://api.login.yahoo.com/oauth/v2/get_request_token?oauth_nonce=123456789&oauth_timestamp=1257965367&oauth_consumer_key=dj0yJmk9YTg0TXhJMjJKTXM3JmQ9WVdrOWFHRTNPRzFaTm1zbWNHbzlNQS0tJnM9Y29uc3VtZXJzZWNyZXQmeD0wNw--&oauth_signature_method=plaintext&oauth_signature=4b9a36b6f819efba691a669622088cf0ba3a1af5%26&oauth_version=1.0&xoauth_lang_pref=en-us&oauth_callback=http://www.take65.com​', '_blank', 'location=yes,height=570,width=520,scrollbars=yes,status=yes');

           $scope.isFeedback = false;
           $scope.classStatus = '';
           $scope.loginMessage = 'Sending data...';
           $scope.isSending = true;
           $rootScope.$broadcast('dataloaded');

           $http.post('/REST/User/Login', { email: $scope.login, password: $scope.password })
               .success(function (data, status, headers, config) {
                   if (data.status) {
                       if (data.response == 'Change Password') {
                           $scope.password = '';
                           $('#openChangePassword').trigger('click');
                       } else {
                           $scope.feedbackStatus = 'success';
                           $scope.loginMessage = 'OK.';
                           $scope.reloadHome = true;
                       }
                   } else {
                       $scope.msgError(data.response);
                   }

                   $rootScope.$broadcast('dataloaded');
                   //$rootScope.$broadcast('nglogged');
               })
               .error(function (data) {
                   $scope.msgError(data.response);
                   $rootScope.$broadcast('dataloaded');
               });
       };

       $scope.changePassword = function () {
           $scope.isFeedback = false;
           if ($scope.password != '') {
               if ($scope.password != $scope.password2) {
                   $scope.loginMessage = 'Your password does not match';
                   $scope.isSending = false;
               } else {
                   $scope.classStatus = '';
                   $scope.loginMessage = 'Sending data...';
                   $scope.isSending = true;

                   $http.post('/REST/User/UpdatePassword', { password: $scope.password })
                   .success(function (data, status, headers, config) {
                       if (data.status) {
                           $scope.feedbackStatus = 'success';
                           $scope.loginMessage = 'OK.';
                           $scope.reloadHome = true;
                       } else {
                           $scope.msgError(data.response);
                       }
                       $rootScope.$broadcast('dataloaded');
                   })
                   .error(function (data) {
                       $scope.msgError(data.response);
                       $rootScope.$broadcast('dataloaded');
                   });
               }
           }
       };

       // Mensagem de erro
       $scope.msgError = function (msg) {
           $scope.feedbackStatus = 'error';
           $scope.loginMessage = msg;
       };
   }])


    // Controller for AddNewWidgetCtrl in /Templates/AddNewWidget.html
    .controller('AddNewWidgetCtrl', ['$timeout', '$scope', '$http', '$rootScope', function ($timeout, $scope, $http, $rootScope) {
        $scope.hasLoad = false;
        $rootScope.edit = undefined;
        $scope.hasValidFacebookToken = false;
        $scope.isSocialMediaExists = false;

        $http.get('/REST/UserWidgetFacebookPhotos/GetToken?m=' + (new Date()).getMilliseconds())
        .success(function (data, status, headers, config) {
            $scope.hasValidFacebookToken = data.status;
            if (data.status) {
                $rootScope.facebookToken = data.response;
            }
        })
        .error(function (data, status, headers, config) {
            $scope.hasValidFacebookToken = false;
        });

        $scope.VerifyForSocialMediaFrame = function () {
            $scope.isSocialMediaExists = true;
            $timeout(function () {
                $.colorbox.resize({ width: $(".hold-modal").width() + 50 });
            }, 100);
        };

        $scope.addTravel = function () {
            $scope.hasLoad = true;
            $rootScope.$broadcast('dataloaded');
            $scope.loadMsg = 'Creating a frame...';

            $http.post('/REST/UserWidgetBookmark/Travel/')
                .success(function (data, status, headers, config) {
                    if (data.status) {
                        $scope.loadMsg = 'Frame created, please wait...';
                        //window.location.href = '/';
                        $rootScope.addWidgetLast(data.response);
                        $scope.$broadcast('closeColorbox');
                        $('#closeModal').trigger('click');
                    } else {
                        $scope.loadMsg = data.response;
                    }
                })
                .error(function (data, status, headers, config) {
                });
        };

        $scope.addFacebook = function () {
            $scope.hasLoad = true;
            $rootScope.$broadcast('dataloaded');
            $scope.loadMsg = 'Creating a frame...';

            $http.post('/REST/UserWidgetFacebook/')
                .success(function (data, status, headers, config) {
                    if (data.status) {
                        $scope.loadMsg = 'Frame created, please wait...';
                        //window.location.href = '/';
                        $rootScope.addWidgetLast(data.response);
                        $scope.$broadcast('closeColorbox');
                        $('#closeModal').trigger('click');
                    } else {
                        $scope.loadMsg = data.response;
                    }
                })
                .error(function (data, status, headers, config) {
                });
        };


        $scope.addFacebookPhotos = function () {
            $scope.hasLoad = true;
            $scope.loadMsg = 'Creating a frame...';
            $rootScope.$broadcast('dataloaded');



            $http.post('/REST/UserWidgetFacebookPhotos/')
                .success(function (data, status, headers, config) {

                    if (data.status) {
                        $rootScope.addWidgetFirst(data.response);
                        $rootScope.$broadcast('dataloaded');
                        $scope.loadMsg = 'Frame created, please wait...';
                        //window.location.href = '/';
                        $scope.$broadcast('closeColorbox');
                        $('#closeModal').trigger('click');

                    } else {
                        //$scope.loadMsg = data.response;
                        $scope.$broadcast('closeColorbox');
                        $('#closeModal').trigger('click');
                    }

                })
                .error(function (data, status, headers, config) {
                });
        };

        $scope.addWeather = function () {
            $scope.hasLoad = true;
            $rootScope.$broadcast('dataloaded');
            $scope.loadMsg = 'Creating a frame...';

            $http.post('/REST/UserWidgetWeather/')
                .success(function (data, status, headers, config) {
                    if (data.status) {
                        $scope.loadMsg = 'Frame created, please wait...';
                        //window.location.href = '/';
                        $rootScope.addWidgetLast(data.response);
                        $scope.$broadcast('closeColorbox');
                        $('#closeModal').trigger('click');
                    } else {
                        $scope.loadMsg = data.response;
                    }
                })
                .error(function (data, status, headers, config) {
                });
        };
    }])

    // Controller Facebook Login
    .controller('FacebookLoginCtrl', function ($scope, $http, $rootScope) {
        //$rootScope.$broadcast('dataloaded');
    })

    .controller('FacebookPhotosCtrl', ['$scope', '$http', '$sce', '$rootScope', function ($scope, $http, $sce, $rootScope) {
        $scope.hasLoad = false;
        $scope.hasValidFacebookToken = false;
        $scope.photos = [];
        $scope.userFriends = [];
        $scope.friendsSearch = [];
        $scope.highlightFriend = { id: 0, photoCount: 0, name: '' };

        $scope.currentPage = 0;
        $scope.pageSize = 10;


        $rootScope.userFriends = [];
        $rootScope.userFriendsSearch = [];

        $scope.checkFacebookToken = function (forceManageFriends) {
            $http.get('/REST/UserWidgetFacebookPhotos/GetToken?m=' + (new Date()).getMilliseconds())
            .success(function (data, status, headers, config) {
                $scope.hasValidFacebookToken = data.status;
                if (data.status) {
                    $rootScope.facebookToken = data.response;
                    $scope.loadUserFriends(forceManageFriends);
                }
            })
                .error(function (data, status, headers, config) {
                    $scope.hasValidFacebookToken = false;
                });
        }

        $scope.loadUserFriends = function (forceManageFriends) {
            $http.get('/REST/UserWidgetFacebookPhotos/UserFriends?m=' + (new Date()).getMilliseconds())
                .success(function (data, status, headers, config) {
                    if (data.length > 0) {
                        $scope.photos = [];
                        $rootScope.userFriends = data.slice(0);
                        $scope.userFriends = data;
                        /*
                        if (data.length > 5) {
                            var itemHighlight = Math.floor(Math.random() * data.length);
                            $scope.highlightFriend = data[itemHighlight];
                            $scope.userFriends.splice(itemHighlight, 1);
                        } else {
                            $scope.highlightFriend = { id: 0, photoCount: 0, name: '' };
                        }*/
                        $scope.highlightFriend = { id: 0, photoCount: 0, name: '' };

                        $rootScope.$broadcast('dataloaded');
                        //setTimeout(function () {
                        //$scope.$broadcast('callCarouselFbPhoto');
                        //}, 500);

                        //$scope.$broadcast('dataloaded');


                    } else {
                        $scope.userFriends = [];
                        $scope.highlightFriend = { id: 0, photoCount: 0, name: '' };
                        if (forceManageFriends) {
                            setTimeout(function () {
                                $("#lnk-edit-facebook-photo").trigger("click");
                            }, 1000);
                        }
                    }
                })
                .error(function (data, status, headers, config) {

                });
        }

        $rootScope.viewUserPhotos = $scope.viewUserPhotos = function (user) {
            $scope.currentPage = 0;
            if (user.photos == null) {
                $scope.hasLoad = true;
                $http.get('/REST/UserWidgetFacebookPhotos/FacebookPhotos/' + user.id + '?m=' + (new Date()).getMilliseconds())
                .success(function (data, status, headers, config) {
                    $scope.hasLoad = false;
                    if (data.length > 0) {

                        $scope.currentUser = user;
                        $scope.photos = data;

                        user.photos = data;
                        var blnUpdateCount = (user.photoCount != data.length);

                        user.photoCount = data.length;

                        $scope.facebookPhoto.friendName = user.name;
                        $scope.facebookPhoto.viewDetail = true;

                        /* Update User Reference to not call the next time */
                        for (var u in $scope.userFriends) {
                            if ($scope.userFriends[u].id == user.id) {
                                $scope.userFriends[u].photos = user.photos;
                                $scope.userFriends[u].photoCount = user.photos.length;
                                if (blnUpdateCount) {
                                    $scope.saveFriends();
                                }
                            }
                        }
                        /* Update User Reference to not call the next time */

                        $rootScope.$broadcast('dataloaded');
                    }
                })
                .error(function (data, status, headers, config) {
                    alert('facebook photos error');
                });
            } else {
                $scope.currentUser = user;
                $scope.photos = user.photos;

                $scope.facebookPhoto.friendName = user.name;
                $scope.facebookPhoto.viewDetail = true;
                $rootScope.$broadcast('dataloaded');
            }
        };

        $scope.saveFriends = function () {
            $http.post('/REST/UserWidgetFacebookPhotos/SaveFriends', $scope.userFriends)
                        .success(function (data, status, headers, config) {
                        });
        };

        $rootScope.rebind = function () {
            $rootScope.$broadcast('dataloaded');
        };

        $rootScope.updateFacebookFriendsList = $scope.updateFacebookFriendsList = function () {
            $scope.loadUserFriends(false);
        };

        $rootScope.showFriendsList = $scope.showFriendsList = function () {
            $scope.photos = [];
        };

        $scope.facebookLogin = function () {

            FB.login(function (response) {
                if (response.authResponse) {
                    $http.post('/REST/UserWidgetFacebookPhotos/SetToken', { facebookToken: response.authResponse.accessToken })
                        .success(function (data, status, headers, config) {
                            if (data.status) {
                                $scope.checkFacebookToken(true);
                            }
                            $rootScope.$broadcast('dataloaded');

                        })
                        .error(function (data) {

                        });


                } else {
                    // cancelled
                }
            }, { scope: 'email,read_friendlists,user_photos,friends_photos' });

        };

        $rootScope.loadWidget();
        $scope.checkFacebookToken(false);
        $rootScope.$broadcast('dataloaded');

    }])


    // Controller for FacebookPhotoDetail in /Templates/FacebookPhotoDetail.html
    .controller('FacebookPhotoDetailCtrl', function ($scope, $http, $rootScope) {
        //$scope.facebookImage = $scope.photos[$scope.$index].photo;
        //$scope.facebookImageWidth = $scope.photos[$scope.$index].width + 'px';
        //$scope.facebookImageHeight = $scope.photos[$scope.$index].height + 'px';
        //$scope.facebookImageCaption = $scope.photos[$scope.$index].name;
        //$rootScope.$broadcast('dataloaded');

        /*
        setTimeout(function () {
            $scope.$broadcast('callCarouselFbPhotoDetail');
        }, 200);
        */
    })

    // Controller for FacebookPhotosManageFriends in /Templates/FacebookPhotosManageFriends.html
    .controller('FacebookPhotosManageFriendsCtrl', function ($scope, $http, $rootScope) {
        // Swapna Changes
        $scope.facebookPhoto = { friendName: '', viewDetail: false };

        $scope.userFriends = $rootScope.userFriends.slice(0);
        $scope.facebookFriends = [];
        $scope.facebookFriendsFilter = [];
        $scope.friendSearch = { keywork: '' };


        $scope.loadFacebookFriends = function () {
            $http.get('/REST/UserWidgetFacebookPhotos/FacebookFriends?m=' + (new Date()).getMilliseconds())
                .success(function (data, status, headers, config) {
                    if (data.length > 0) {

                        $scope.facebookFriends = data;
                        for (var i in $scope.facebookFriends) {
                            for (var j in $scope.userFriends) {
                                if ($scope.facebookFriends[i].id == $scope.userFriends[j].id) {
                                    $scope.facebookFriends[i].chk = true;
                                }
                            }
                        }

                        $scope.facebookFriendsFilter = $scope.facebookFriends.slice(0);

                    } else {
                        $scope.facebookFriends = [];
                    }
                })
                .error(function (data, status, headers, config) {

                });
        }

        $scope.loadFacebookPhotos = function (user) {

            if (user.photoCount == -1) {
                user.verifing = true;
                $http.get('/REST/UserWidgetFacebookPhotos/FacebookPhotos/' + user.id + '?m=' + (new Date()).getMilliseconds())
            .success(function (data, status, headers, config) {
                user.verifing = false;
                if (data.length > 0) {

                    $scope.userFriends.push(user);

                    for (var o in $scope.userFriends) {
                        if ($scope.userFriends[o].id == user.id) {
                            $scope.userFriends[o].photos = data;
                            $scope.userFriends[o].photoCount = data.length;
                        }
                    }

                    for (var o in $scope.facebookFriends) {
                        if ($scope.facebookFriends[o].id == user.id) {
                            $scope.facebookFriends[o].photos = data;
                            $scope.facebookFriends[o].photoCount = data.length;
                        }
                    }


                    //$.colorbox.resize({ width: "910px" });

                } else {
                    alert('This user selected to not share their Facebook photos. Please, select a different user.');
                    user.photoCount = 0;
                    user.chk = false;
                }
            })
                    .error(function (data, status, headers, config) {

                    });
            } else {
                if (user.photoCount > 0) {
                    $scope.userFriends.push(o);
                } else {
                    alert('This user selected to not share their Facebook photos. Please, select a different user.');
                    user.chk = false;
                }
            }
        };

        $scope.findFriend = function () {
            $scope.facebookFriendsFilter = $scope.facebookFriends.slice(0);
            $scope.facebookFriendsFilter = _.filter($scope.facebookFriendsFilter, function (v) {
                return (v.name.toLowerCase().slice(0, $scope.friendSearch.keywork.length) == $scope.friendSearch.keywork.toLowerCase());
            });

        }

        $scope.removeFriend = function (i, id) {
            if (i != -1) {
                $scope.userFriends.splice(i, 1);
            } else {
                for (var o in $scope.userFriends) {
                    if ($scope.userFriends[o].id == id) {
                        $scope.userFriends.splice(o, 1);
                    }
                }
            }

            for (var o in $scope.facebookFriends) {
                if ($scope.facebookFriends[o].id == id) {
                    $scope.facebookFriends[o].chk = false;
                }
            }
        };

        $scope.addFriend = function (o) {
            if (o.chk) {
                //$scope.userFriends.push(o);
                $scope.loadFacebookPhotos(o);
            } else {
                $scope.removeFriend(-1, o.id);
            }
        };

        $scope.loadFacebookFriends();

        $scope.saveFriends = function () {
            $http.post('/REST/UserWidgetFacebookPhotos/SaveFriends', $scope.userFriends)
                        .success(function (data, status, headers, config) {
                            if (data.status) {
                                //$scope.$parent.LoadTake65FacebookFriends();
                                $scope.facebookPhoto.viewDetail = false;
                                $scope.facebookPhoto.friendName = '';
                                $rootScope.updateFacebookFriendsList()
                                $.colorbox.close();

                                if (data.response != 'User already have Facebook Photos Frame') {
                                    $rootScope.addWidgetFirst(data.response);
                                }

                                $rootScope.$broadcast('dataloaded');
                                $scope.$broadcast('closeColorbox');
                                $('#closeModal').trigger('click');
                            } else {
                                $scope.$broadcast('closeColorbox');
                                $('#closeModal').trigger('click');
                            }
                        })
                        .error(function (data, status, headers, config) {
                        });
        };
    })

    // Controller for AddNewWidget.FeedCtrl in /Templates/AddNewWidget/Feed.html
    .controller('AddNewWidget.FeedCtrl', ['$scope', '$http', '$rootScope', '$element', '$compile', function ($scope, $http, $rootScope, $element, $compile) {
        var edit = ($rootScope.edit !== undefined) ? true : false;
        $scope.typeWidget = $element.data('typewidget');
        $scope.clickSubmit = true;
        $scope.step = 1; // Variavel com o passo que esta
        $scope.checkeds = {}; // Cria objeto de checkeds
        $scope.checkeds.categories = []; // Cria array para categorias selecionadas
        $scope.checkeds.trustedSource = []; // Cria array para trusteds selecionados
        $scope.feedback = { status: 'error', msg: '' }; // Mensagem e status de feedback
        $scope.validation = { msg: '' };


        var url = (edit) ? '/REST/TrustedSourceCategory/EditUserWidgetNews/' + $rootScope.edit.id : '/REST/TrustedSourceCategory/' + $scope.typeWidget + '?m=' + (new Date()).getMilliseconds();
        $http.get(url, { cache: false })
            .success(function (data, status, headers, config) {
                if (data.length > 0) {
                    $scope.categories = data;

                    $scope.changeAll = {
                        id: 0,
                        title: 'Select All',
                        image: '',
                        chk: false
                    };

                }

                // Se for na edição, checka os itens que já foram selecionados pelo cliente
                if (edit)
                    $scope.checkItens();

                $scope.$broadcast('dataloaded');

                $scope.$watch('$compile', function () {
                    $scope.$broadcast('dataloaded');
                });
            })
            .error(function (data, status, headers, config) {
            });


        $scope.checkItens = function () {
            for (var iCat in $scope.categories) {
                for (var iCatSource = 0; iCatSource < $scope.categories[iCat].trustedSource.length; iCatSource++) {
                    if ($scope.categories[iCat].trustedSource[iCatSource].chk)
                        $scope.categories[iCat].chk = true;
                }
            }
        };

        // Seta mensagem e status de feedback
        var setFeedback = function (status, msg) {
            $scope.feedback.status = status;
            $scope.feedback.msg = msg;
            $rootScope.$broadcast('dataloaded');
        };

        $scope.postCategories = function () {
            $scope.clickSubmit = false;
            if (!edit) {
                if ($scope.widget == undefined) {
                    $scope.validation.msg = 'Please type a frame name to continue';
                    $scope.clickSubmit = true;
                    return false;
                } else {
                    if ($scope.widget.title == '') {
                        $scope.clickSubmit = true;
                        $scope.validation.msg = 'Please type a frame name to continue';
                        return false;
                    } else {
                        $scope.validation.msg = '';
                    }
                }
            }

            console.log($scope.getCheckeds($scope.categories));
            $scope.postTrusteds();
            /*
            setFeedback('success', 'Sending data...');
            var serviceUrl = ($rootScope.edit !== undefined) ? ("/REST/TrustedSource/Edit/" + $rootScope.edit.id) : "/REST/TrustedSource/New";

            $http.post(serviceUrl, { category: $scope.getCheckeds($scope.categories) })
                .success(function (data, status, headers, config) {
                    setFeedback('', '');

                    if (data.length > 0) {
                        $scope.trustedSource = data;
                        if ($rootScope.edit === undefined) {
                            for (var iSource in $scope.trustedSource) {
                                $scope.trustedSource[iSource].chk = true;
                            }
                        }
                    }

                    $scope.$broadcast('closeColorbox');
                    $('#closeModal').trigger('click');
                })
                .error(function (data, status, headers, config) {
                });
                */
        };

        $scope.postTrusteds = function () {
            $scope.clickSubmit = false;
            if (!edit) {
                if ($scope.widget == undefined) {
                    $scope.validation.msg = 'Please type a frame name to continue';
                    $scope.clickSubmit = true;
                    return false;
                } else {
                    if ($scope.widget.title == '') {
                        $scope.clickSubmit = true;
                        $scope.validation.msg = 'Please type a frame name to continue';
                        return false;
                    } else {
                        $scope.validation.msg = '';
                    }
                }
            }

            setFeedback('success', 'Sending data...');
            if (!edit) {
                $rootScope.repositionWidgets();
                var gridsterItems = $rootScope.$gridster.serialize();
                $rootScope.updatePosition(gridsterItems);
            };

            //, trustedSource: $scope.getCheckeds($scope.trustedSource)
            $http.post('/REST/UserWidgetFeed/' + ((edit) ? $rootScope.edit.id : ''), { title: $scope.widget.title, category: $scope.getCheckeds($scope.categories) })
                .success(function (data, status, headers, config) {
                    if (data.status) {
                        if (edit) {

                            $('.list-gridster .box-column').each(function (i, e) {
                                if ($(e).attr('data-widget') == $rootScope.edit.id) {
                                    $rootScope.$gridster.remove_widget(e);
                                }
                            });

                            LoadBehaviorCaller['dataload-' + $rootScope.edit.id] = undefined;
                            _page.userWidgetFeed[('items_' + $rootScope.edit.id)] = undefined;
                            $rootScope.attWidget($rootScope.edit.id, data.response);
                            $scope.$broadcast('closeColorbox');
                            $('#closeModal').trigger('click');
                            $rootScope.loadDragWidgets($rootScope.edit.id);

                        } else {
                            $rootScope.addWidgetFirst(data.response);
                            $scope.$broadcast('closeColorbox');
                            $('#closeModal').trigger('click');
                        }
                    } else {
                        $scope.messageFeedback = 'Error, try again.';
                    }
                })
                .error(function (data, status, headers, config) {
                });
        };

        $scope.changeChecked = function (item) {
            item.chk = !item.chk;
            $scope.changeAll.chk = $scope.getCheckeds($scope.categories).length === $scope.categories.length;
        };

        $scope.getCheckeds = function (list) {
            var checkeds = [];
            for (var iEl in list) {
                var el = list[iEl];
                if (el.chk)
                    checkeds.push({ id: el.id });
            }

            return checkeds;
        };

        $scope.changeAllCategories = function (item) {
            $scope.checkeds.categories = [];
            item.chk = !item.chk;

            for (var el in $scope.categories) {
                $scope.categories[el].chk = item.chk;
                if (item.chk)
                    $scope.checkeds.categories.push({ id: $scope.categories[el].id });
            }
        };

        $scope.changeStep = function (step) {
            if (step === 1) {
                $scope.step = 1;
                $rootScope.$broadcast('dataloaded');
                return;
            } else if (step === 2) {
                if ($scope.clickStep2)
                    return false;

                $scope.clickStep2 = true;
                $scope.checkeds.categories = $scope.getCheckeds($scope.categories);
                if ($scope.checkeds.categories.length > 0) {
                    $scope.postCategories();
                } else {
                    setFeedback('error', 'Please select at least one category.');
                    $scope.clickStep2 = false;
                }

                return;
            }
        };

        $scope.submitAdd = function () {
            setFeedback('', '');
            $scope.checkeds.categories = $scope.getCheckeds($scope.categories);

            if ($scope.checkeds.categories.length > 0) {
                $scope.postCategories();
            } else {
                setFeedback('error', 'Please select at least one category.');
            }
        };

        $scope.submit = function () {
            setFeedback('', '');
            $scope.checkeds.trustedSource = $scope.getCheckeds($scope.trustedSource);
            if ($scope.checkeds.trustedSource.length > 0) {
                $scope.postTrusteds();
            } else {
                setFeedback('error', 'Please select at least one resources.');
                $scope.clickSubmit = true;
            }
        };

        $scope.submitInRegister = function () {
            setFeedback('', '');
            $scope.checkeds.trustedSource = $scope.getCheckeds($scope.trustedSource);
            $scope.postTrustedsInRegister();
        };

        $scope.postTrustedsInRegister = function () {
            setFeedback('success', 'Sending data, please wait...');

            $scope.ajaxController = $scope.getCheckeds($scope.categories).length;

            if ($scope.ajaxController > 0) {

                var allTrustedSource = [];
                var selectedCats = $scope.getCheckeds($scope.categories);

                for (var catSel = 0; catSel < selectedCats.length; catSel++) {
                    for (var cats = 0; cats < $scope.categories.length; cats++) {
                        if (selectedCats[catSel].id == $scope.categories[cats].id) {
                            for (var ts = 0; ts < $scope.categories[cats].trustedSource.length; ts++) {
                                var blnExisits = false;
                                for (var exists = 0; exists < allTrustedSource.length; exists++) {
                                    if (allTrustedSource[exists].id == $scope.categories[cats].trustedSource[ts].id) {
                                        blnExisits = true;
                                    }
                                }
                                if (!blnExisits) {
                                    allTrustedSource.push({ id: $scope.categories[cats].trustedSource[ts].id });
                                }

                            }
                        }
                    }
                }
                $http.post('/REST/UserWidgetFeed', { title: 'News', category: $scope.getCheckeds($scope.categories), trustedSource: allTrustedSource })
                    .success(function (data, status, headers, config) {
                        if (data.status) {
                            $scope.$parent.nextCustomStep();
                        } else {
                            $scope.messageFeedback = 'Error, try again.';
                            $rootScope.$broadcast('dataloaded');
                        }
                    })
                    .error(function (data, status, headers, config) {
                    });
            } else {
                $scope.$parent.nextCustomStep();
            }
            /*
            if ($scope.ajaxController > 0) {
                for (var requestAjax in $scope.getCheckeds($scope.categories)) {
                    
                    $http.post('/REST/UserWidgetFeed', { category: [$scope.categories[requestAjax]], trustedSource: $scope.categories[requestAjax].trustedSource })
                    .success(function (data, status, headers, config) {
                        if (data.status) {
                            $scope.ajaxController--;
                            if ($scope.ajaxController <= 0) {
                                $scope.$parent.nextCustomStep();
                            }
                        } else {
                            $scope.messageFeedback = 'Error, try again.';
                            $rootScope.$broadcast('dataloaded');
                        }
                    })
                    .error(function (data, status, headers, config) {
                    });
                }
            } else {
                $scope.$parent.nextCustomStep();
            }
            */
        };
    }])

    // Controller for AddNewWidget.MyWebsiteCtrl in /Templates/AddNewWidget/Feed.html
    .controller('AddNewWidget.MyWebsiteCtrl', ['$timeout', '$scope', '$http', '$rootScope', '$element', function ($timeout, $scope, $http, $rootScope, $element) {
        var edit = ($rootScope.edit !== undefined) ? true : false;
        $scope.websites = [];
        $scope.trustedWebsites = {};
        $scope.trusted = {};
        $scope.trusted.trustedSourceSelected = [];
        $scope.feedback = { status: 'error', msg: '' };
        $scope.validation = { msg: '' };
        $scope.clickSubmit = true;
        $scope.confirmTrusted = false;
        $scope.listTrustedCustom = {};
        $rootScope.websitesCategories = [];
        $scope.$broadcast('dataloaded');

        // Get Trusteds and Categories in REST/TrustedSourceCategory/
        $scope.getTrusteds = function () {
            var url = '/REST/TrustedSourceCategory/?m=' + (new Date()).getMilliseconds();
            $scope.listTrusted = [];
            $scope.listSources = [];
            $scope.category = {};

            $http.get(url, { cache: false })
                .success(function (data, status, headers, config) {
                    if (data.length > 0) {
                        $scope.listTrusted = data;
                        $rootScope.websitesCategories = data;
                        $scope.$parent.cListTrusted = data.length;
                        $scope.category.selected = $scope.listTrusted[0].id;

                        for (var i in $scope.listTrusted) {
                            $scope.trustedWebsites[i] = [];
                        }
                    }
                    //$.colorbox.resize({ width: "75%", height: "90%" });
                    //$rootScope.$broadcast('dataloaded');                    
                    $timeout(function () {
                        $.colorbox.resize({ width: "85%" });
                    }, 500);
                })
                .error(function (data, status, headers, config) {
                });
        };

        // Get Edit Trusteds and Categories in REST/TrustedSourceCategory/EditUserWidgetBookmark
        $scope.getEditTrusteds = function () {
            var url = '/REST/TrustedSourceCategory/EditUserWidgetBookmark/' + $rootScope.edit.id + '?m=' + (new Date()).getMilliseconds();
            $scope.listTrusted = [];
            $scope.listSources = [];
            $scope.category = {};
            $scope.widget = $rootScope.edit;
            $rootScope.deleteItem = { id: $scope.widget.id };

            $http.get(url, { cache: false })
                .success(function (data, status, headers, config) {
                    if (data.length > 0) {

                        var dataTrustedUrls = [];
                        var initialCategory = -1;

                        for (var iCat = 0; iCat < data.length; iCat++) {

                            if (data[iCat].id != 0) {
                                dataTrustedUrls.push(data[iCat]);
                                if (initialCategory == -1) {
                                    for (var icatcheck = 0; icatcheck < data[iCat].trustedSource.length; icatcheck++) {
                                        if (data[iCat].trustedSource[icatcheck].chk)
                                            initialCategory = iCat;
                                    }
                                }
                            } else {
                                for (var iCatSources = 0; iCatSources < data[iCat].trustedSource.length; iCatSources++) {
                                    $scope.websites.push({
                                        title: data[iCat].trustedSource[iCatSources].title,
                                        link: data[iCat].trustedSource[iCatSources].link
                                    });
                                }
                            }
                        }

                        $scope.listTrusted = dataTrustedUrls;
                        $scope.$parent.cListTrusted = dataTrustedUrls.length;


                        initialCategory = (initialCategory == -1) ? 0 : initialCategory;

                        $scope.category.selected = $scope.listTrusted[initialCategory].id;

                        for (var i in $scope.listTrusted) {
                            $scope.trustedWebsites[i] = [];
                        }
                        $scope.setTrustedsChecked();
                    }
                    //$.colorbox.resize({ width: "75%", height: "90%" });
                    //$rootScope.$broadcast('dataloaded');
                    $timeout(function () {
                        $.colorbox.resize({ width: "85%" });
                    }, 500);
                })
                .error(function (data, status, headers, config) {
                });
        };

        // Add new websites
        $scope.addWebsite = function () {
            $scope.websites.push({
                title: $scope.newWebsite.title,
                link: $scope.newWebsite.link
            });

            $scope.newWebsite.title = '';
            $scope.newWebsite.link = '';

            $scope.setConfirmTrusted(false);
            //$rootScope.$broadcast('dataloaded');
            //$.colorbox.resize({ width: "75%", height: "90%" });
            $timeout(function () {
                $.colorbox.resize({ width: "85%" });
            }, 500);
        };
        $scope.addWebsiteInCategory = function (iArray) {

            $scope.trustedWebsites[iArray].push({
                title: $scope.newWebsite.title,
                link: $scope.newWebsite.link
            });

            $scope.newWebsite.title = '';
            $scope.newWebsite.link = '';

            $scope.setConfirmTrusted(false);
            $rootScope.$broadcast('dataloaded');

            $(".list-dashboard .content").animate({ scrollTop: $('.list-dashboard .content')[0].scrollHeight }, 400);
        };

        $scope.setConfirmTrusted = function (val) {
            if (val) {
                $http.post('/REST/SafeWebsite', { url: $scope.newWebsite.link })
                .success(function (data, status, headers, config) {
                    if (data.status) {
                        $scope.addWebsite();
                        $scope.confirmTrusted = false;
                    } else {
                        $scope.confirmTrusted = val;
                    }
                })
                .error(function (data, status, headers, config) {
                    $scope.confirmTrusted = val;
                });
            } else {
                $scope.confirmTrusted = val;
            }
            //$scope.confirmTrusted = val;
            //$rootScope.$broadcast('dataloaded');
        };

        $scope.setConfirmTrustedInCategory = function (val, cat) {
            if (val) {
                $http.post('/REST/SafeWebsite', { url: $scope.newWebsite.link })
                .success(function (data, status, headers, config) {
                    if (data.status) {
                        $scope.addWebsiteInCategory(cat);
                        $scope.confirmTrusted = false;
                    } else {
                        $scope.confirmTrusted = val;
                    }
                })
                .error(function (data, status, headers, config) {
                    $scope.confirmTrusted = val;
                });
            } else {
                $scope.confirmTrusted = val;
            }
            //$scope.confirmTrusted = val;
            //$rootScope.$broadcast('dataloaded');
        };

        $scope.selectCategory = function (cat, itemID) {
            cat.selected = itemID;
            $timeout(function () {
                $.colorbox.resize({ height: $(".hold-modal").height() + 75 });
            }, 200);
        }
        // Change source and manipulate the $scope.trusted.trustedSourceSelected's array
        $scope.changeSource = function (src) {
            src.chk = !src.chk;
            $(".list-dashboard .content").animate({ scrollTop: $('.list-dashboard .content')[0].scrollHeight }, 400);

            if (src.chk) {
                $scope.trusted.trustedSourceSelected.push(src);
            } else {
                $scope.trusted.trustedSourceSelected.splice($scope.trusted.trustedSourceSelected.indexOf(src), 1);
            }
            //$.colorbox.resize({ width: "75%", height: "90%" });
            //$rootScope.$broadcast('dataloaded');
            $timeout(function () {
                $.colorbox.resize({ width: "85%" });
            }, 500);
        };
        $scope.setTrustedsChecked = function () {
            for (var i in $scope.listTrusted) {
                for (var j in $scope.listTrusted[i].trustedSource) {
                    if ($scope.listTrusted[i].trustedSource[j].chk)
                        $scope.trusted.trustedSourceSelected.push($scope.listTrusted[i].trustedSource[j]);
                }
            }
        };

        $scope.changeSourceInCategory = function (index, src) {
            $scope.trusted.trustedSourceSelected[index] = $scope.trusted.trustedSourceSelected[index] || [];
            src.chk = !src.chk;
            $(".list-dashboard .content").animate({ scrollTop: $('.list-dashboard .content')[0].scrollHeight }, 400);

            if (src.chk) {
                $scope.trusted.trustedSourceSelected[index].push(src);
            } else {
                $scope.trusted.trustedSourceSelected[index].splice(index, 1);
            }
            $rootScope.$broadcast('dataloaded');
        };

        $scope.deleteWebsite = function (index) {
            $scope.websites.splice(index, 1);
        };
        $scope.deleteWebsiteInCategory = function (index, cat) {
            $scope.trustedWebsites[cat].splice(index, 1);
        };

        $scope.toggleCustomWebsite = function () {
            $scope.customWebsiteDisplay = !$scope.customWebsiteDisplay;
            $rootScope.$broadcast('dataloaded');
            //$.colorbox.resize({ width: "75%", height: "90%" });
        };

        $scope.closeModal = function () {
            $scope.$broadcast('closeColorbox');
            $('#closeModal').trigger('click');
        };

        // Send data for MyWebsite to /REST/UserWidgetBookmark/
        $scope.submit = function () {
            if (!edit) {
                if ($scope.widget == undefined) {
                    $scope.validation.msg = 'Please type a frame name to continue';
                    return false;
                } else {
                    if ($scope.widget.title == '') {
                        $scope.validation.msg = 'Please type a frame name to continue';
                        return false;
                    } else {
                        $scope.validation.msg = '';
                    }
                }
            }


            var url = '/REST/UserWidgetBookmark/' + ((edit) ? 'Edit/' + $rootScope.edit.id : '');

            $scope.clickSubmit = false;
            $scope.feedback.status = 'success';
            $scope.feedback.msg = 'Sending data...';
            var objData = {
                title: (edit) ? $rootScope.edit.title : $scope.widget.title,
                trustedSource: $scope.trusted.trustedSourceSelected.concat($scope.websites)
            };

            if (!edit) {
                if ($rootScope.repositionWidgets() != null)
                    $rootScope.repositionWidgets();
                if ($rootScope.$gridster != null) {
                    var gridsterItems = $rootScope.$gridster.serialize();
                    $rootScope.updatePosition(gridsterItems);
                }
            };

            $http.post(url, objData)
                .success(function (data, status, headers, config) {
                    if (data.status) {
                        $scope.feedback.msg = 'OK';
                        if (edit) {
                            $('.list-gridster .box-column').each(function (i, e) {
                                if ($(e).attr('data-widget') == $rootScope.edit.id) {
                                    if ($rootScope.$gridster != null)
                                        $rootScope.$gridster.remove_widget(e);

                                }
                            });

                            LoadBehaviorCaller['dataload-' + $rootScope.edit.id] = undefined;
                            _page.userWidgetBookmark[('items_' + $rootScope.edit.id)] = undefined;
                            $rootScope.attWidget($rootScope.edit.id, data.response);
                            $rootScope.loadDragWidgets($rootScope.edit.id);
                        } else {
                            $rootScope.addWidgetLast(data.response);
                        }

                        $scope.$broadcast('closeColorbox');
                        $('#closeModal').trigger('click');
                        location.reload();
                    } else {
                        $scope.feedback.msg = data.response;
                        $scope.clickSubmit = true;
                    }
                })
                .error(function (data, status, headers, config) {
                    $scope.feedback.msg = data.response;
                    $scope.clickSubmit = true;
                });
        };

        // Send data for MyWebsite to /REST/UserWidgetBookmark/
        $scope.submitInCategory = function () {
            $scope.cSelecteds = 0;
            $scope.clickSubmit = false;
            $scope.feedback.status = 'success';
            $scope.selectedsCategories = [];


            for (var count in $scope.trusted.trustedSourceSelected) {
                $scope.selectedsCategories[count] = [];

                $scope.selectedsCategories[count] = $scope.trusted.trustedSourceSelected[count];
            }
            for (var count2 in $scope.trustedWebsites) {
                if ($scope.trustedWebsites[count2].length > 0) {
                    $scope.selectedsCategories[count2] = $scope.selectedsCategories[count2] || [];
                    $scope.selectedsCategories[count2] = $scope.selectedsCategories[count2].concat($scope.trustedWebsites[count2]);
                }
            }
            for (var i in $scope.selectedsCategories) {
                var frameName = "Websites";
                for (var cats = 0; cats < $scope.listTrusted.length; cats++) {
                    if ($scope.selectedsCategories[i][0].categoryId == $scope.listTrusted[cats].id) {
                        frameName = $scope.listTrusted[cats].title;
                    }
                }

                $scope.cSelecteds++;
                var objData = {
                    title: frameName,
                    trustedSource: $scope.selectedsCategories[i]
                };

                $http.post('/REST/UserWidgetBookmark/', objData)
                    .success(function (data, status, headers, config) {
                        if (data.status) {
                            $scope.feedback.msg = 'Creating frames...';
                        } else {
                            $scope.feedback.msg = data.response;
                            $scope.clickSubmit = true;
                        }
                        $rootScope.$broadcast('dataloaded');

                        $scope.cSelecteds--;

                        if ($scope.cSelecteds === 0) {
                            window.location.href = '/?InviteYourFriends';
                        }
                    })
                    .error(function (data, status, headers, config) {
                        $scope.feedback.msg = data.response;
                        $scope.clickSubmit = true;

                        $scope.cSelecteds--;

                        if ($scope.cSelecteds === 0) {
                            window.location.href = '/?InviteYourFriends';
                        }
                    });
            }

            if ($scope.selectedsCategories.length === 0)
                window.location.href = '/?InviteYourFriends';
            //$scope.clickSubmit = true;
        };


        if (!edit)
            $scope.getTrusteds();
        else
            $scope.getEditTrusteds();
    }])
    // Controller for InviteFriends
    .controller('InviteFriends', ['$scope', '$http', '$rootScope', '$element', '$timeout', '$window', 'authcfg', function ($scope, $http, $rootScope, $element, $timeout, $window, authcfg) {
        $scope.title = 'Invite your Friends';
        $scope.step = 1;
        $scope.listEmails = [];
        $scope.firstAccess = false;
        // $rootScope.$broadcast('dataloaded');
        console.log("live yahoo auth details :    ", authcfg);

        if ($rootScope.firstAccess) {
            $scope.firstAccess = true;
            $rootScope.firstAccess = false;
        }

        $scope.goStep = function (i) {
            $scope.step = i;
            // $rootScope.$broadcast('dataloaded');
        };

        $scope.finishRegistration = function () {
            $.colorbox.close();
            $scope.$broadcast('closeColorbox');
            $('#closeModal').trigger('click');
        };

        $scope.addIndividual = function () {
            if ($scope.addIndividualEmail.$valid) {
                var friendsInvited = $scope.emailIndividual.split(',');
                var objFriends = [];

                for (var friend in friendsInvited)
                    objFriends.push({ email: friendsInvited[friend] });

                var invite = $scope.invite(objFriends, function (data) {
                    if (data.status) {
                        //cboxLoadingGraphic
                        $scope.classIndividualFeedback = 'success';
                        $scope.msgIndividualFeedback = 'Your invite was sent successfully.';
                    } else {
                        $scope.classIndividualFeedback = 'error';
                        $scope.msgIndividualFeedback = data.response;
                    }
                });

                $scope.emailIndividual = '';
                $scope.classIndividualFeedback = 'success';
                $scope.msgIndividualFeedback = 'Inviting your friend...';
                // $rootScope.$broadcast('dataloaded');
            }
        };

        $scope.loginGmail = function () {

            $scope.feedbackStatus = 'success';
            $scope.loginMessage = 'Sending data...';
            $rootScope.$broadcast('dataloaded');

            $http.get('/REST/Invite/Gmail/' + $scope.login + '/' + $scope.password + '?m=' + (new Date()).getMilliseconds())
                .success(function (data, status, headers, config) {
                    if (data.status || data.length > 0) {
                        $scope.loginMessage = 'OK.';
                        $scope.title = 'Select your Friends';

                        $scope.friends = data;
                        $scope.friendsFilter = $scope.friends;
                        $scope.goStep(3);
                    } else {
                        $scope.feedbackStatus = 'error';
                        $scope.loginMessage = data.response;
                    }
                    $rootScope.$broadcast('dataloaded');
                })
                .error(function (data, status, headers, config) {
                    $scope.feedbackStatus = 'error';
                    $scope.loginMessage = data;
                });
        };

        $scope.handleGmailAuthResult = function (authResult) {
            if (authResult && !authResult.error) {
                $http.jsonp('https://www.google.com/m8/feeds/contacts/default/full', { params: { 'max-results': '999', access_token: authResult.access_token, alt: 'json', callback: 'JSON_CALLBACK' } })
                    .success(function (response) {
                        // $scope.$apply(function () {
                        if (response.feed && response.feed.entry && response.feed.entry.length) {

                            $scope.friends = _.compact(_.map(response.feed.entry, function (item) {
                                var emails = []
                                for (en in item.gd$email) {
                                    entry = item.gd$email[en];
                                    if (entry.primary == "true") {
                                        return {
                                            email: entry.address,
                                            name: item.title.$t || entry.address
                                        }
                                    }
                                }
                            }));
                            $scope.friendsFilter = $scope.friends;

                            $scope.loginMessage = 'OK.';
                            $scope.$parent.title = 'Select your Friends';

                            $scope.goStep(3);
                        } else {
                            $scope.friends = [];
                            $scope.friendsFilter = $scope.friends;

                            $scope.loginMessage = 'OK.';
                            $scope.title = "Not found";
                            $scope.inviteMessage = "You don't have friends on this account";
                            $scope.goStep(4);
                        }

                        $timeout($.colorbox.resize, 500);

                        $scope.hasLoad = false;
                    });
            }
        };

        $scope.getGmailContacts = function (callback) {
            $scope.hasLoad = true;
            gapi.auth.authorize({ client_id: _googleConfig.clientId, scope: [_googleConfig.scopes.contacts, _googleConfig.scopes.plus], immediate: false }, $scope.handleGmailAuthResult);
        };

        $scope.findFriend = function () {
            if ($scope.friendSearch.keywork.length > 2) {
                $scope.friendsFilter = $scope.friends.slice(0);
                $scope.friendsFilter = _.filter($scope.friendsFilter, function (v) {
                    if ((v.name != undefined) && (v.name.length > $scope.friendSearch.keywork.length)) {
                        return (v.name.toLowerCase().slice(0, $scope.friendSearch.keywork.length) == $scope.friendSearch.keywork.toLowerCase())
                    }
                });
            } else {
                $scope.friendsFilter = $scope.friends;
            }

        }


        $scope.getOutlookContacts = function () {
            console.log("getOutlookContacts called...");
            $scope.hasLoad = true;
            var network = 'windows';
            var path = 'me/contacts';
            var list = document.getElementById('list');
            hello.login(network, { scope: 'friends', force: true }, function (auth) {
                if (!auth || auth.error) {
                    console.log("Signin aborted");
                    $scope.hasLoad = false;
                    return;
                }
                hello(network).api(path, { limit: 1000 }, function responseHandler(r) {
                    if (r.data != undefined) {
                        $scope.friends = _.compact(_.map(r.data, function (item) {
                            var emails = []
                            if (item.email != undefined) {
                                return {
                                    email: item.email,
                                    name: item.name
                                }
                            }
                        }));
                        $scope.friendsFilter = $scope.friends;
                        $scope.loginMessage = 'OK.';
                        $scope.$parent.title = 'Select your Friends';
                        $scope.goStep(3);
                        $scope.hasLoad = false;
                    }
                    else {
                        $scope.friends = [];
                        $scope.friendsFilter = $scope.friends;

                        $scope.loginMessage = 'OK.';
                        $scope.title = "Not found";
                        $scope.inviteMessage = "You don't have friends on this account";
                        $scope.goStep(4);
                        $timeout($.colorbox.resize, 500);
                        $scope.hasLoad = false;
                    }
                });
            });
        };

        $scope.invite = function (friends, callback) {
            var friendsInvited = friends;
            callback = callback || function () { };

            $http.post('/REST/Invite/', friendsInvited)
                .success(function (data, status, headers, config) {
                    callback(data);

                    $rootScope.$broadcast('dataloaded');
                })
                .error(function (data, status, headers, config) {
                    callback(data);
                });
        };

        $scope.inviteAllFriends = function () {
            for (var i in $scope.friends) {
                $scope.friends[i].chk = true; //#-TEMP TO NOT ENABLE FOR TESTING
            }
            $scope.inviteFriends();
        };

        $scope.inviteFriends = function () {
            var friendsInvited = $scope.getCheckeds();
            $scope.msgSendInvite = 'Inviting your friends...';
            $scope.feedbackSendStatus = 'success';
            $rootScope.$broadcast('dataloaded');

            $scope.invite(friendsInvited, function (data) {
                if (data.status) {
                    $scope.title = "Invite your Friends";
                    $scope.inviteMessage = "Your friends were invited successfully.";

                    if ($scope.$parent.goStep)
                        $scope.$parent.goStep(4);
                    else if ($scope.goStep)
                        $scope.goStep(4);
                } else {
                    $scope.feedbackSendStatus = 'error';
                    $scope.msgSendInvite = data.response;
                }

                $rootScope.$broadcast('dataloaded');
            });
        };

        $scope.getCheckeds = function () {
            return _.filter($scope.friends, function (item) {
                return item.chk
            });
        };

        $scope.getauthnonce = function () {
            var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
            var result = "";
            for (var i = 0; i < 10; ++i) {
                var rnum = Math.floor(Math.random() * chars.length);
                result += chars.substring(rnum, rnum + 1);
            }
            return result;
        };
        $scope.getauthtimestamp = function () {
            var t = (new Date()).getTime();
            return Math.floor(t / 1000);
        };

        //yahoo contacts implementation
        $scope.getYahooContacts = function () {
            console.log("getyahoocontacts called....");
            $scope.hasLoad = true;

            var gdata = { token: 'abc', email: 'a@a.com' };
            $http.get('/rest/Yahoo', { params: gdata })
                               .success(function (data, status, headers, config) {

                                   if (data) {
                                       $scope.userEmailFeed = $rootScope.userEmailFeed = data;
                                       $rootScope.$broadcast('dataloaded');
                                       $scope.userHasEmailAccount = true;
                                       $scope.wasLoaded = true;
                                   } else {
                                       $scope.userHasEmailAccount = false;
                                   }
                               });


            var network = 'yahoo';
            var path = 'me/friends';
            var list = document.getElementById('list');
            hello.login(network, { scope: 'friends', force: true }, function (auth) {
                if (!auth || auth.error) {
                    console.log("Signin aborted");
                    $scope.hasLoad = false;
                    return;
                }
                hello(network).api(path, { limit: 1000 }, function responseHandler(r) {
                    if (r.data != undefined) {
                        $scope.friends = _.compact(_.map(r.data, function (item) {
                            var emails = []
                            if (item.email != undefined) {
                                return {
                                    email: item.email,
                                    name: item.name
                                }
                            }
                        }));
                        $scope.friendsFilter = $scope.friends;
                        $scope.loginMessage = 'OK.';
                        $scope.$parent.title = 'Select your Friends';
                        $scope.goStep(3);
                        $scope.hasLoad = false;
                    }
                    else {
                        $scope.friends = [];
                        $scope.friendsFilter = $scope.friends;

                        $scope.loginMessage = 'OK.';
                        $scope.title = "Not found";
                        $scope.inviteMessage = "You don't have friends on this account";
                        $scope.goStep(4);
                        $timeout($.colorbox.resize, 500);
                        $scope.hasLoad = false;
                    }
                });
            });
        };

    }])
    .directive('ngLastRepeat', function () {
        return function (scope, element, attrs) {
            if (scope.$last) {
                setTimeout($.colorbox.resize, 500);
            }
        };
    })

    // Controller for CustomizeHomepageCtrl in /Templates/CustomizeHomepage.html
    .controller('CustomizeHomepageCtrl', ['$scope', '$http', '$rootScope', '$timeout', function ($scope, $http, $rootScope, $timeout) {
        $scope.customStep = 0;
        $scope.custom = {};
        $scope.custom.mywebsite = {};
        $scope.custom.mywebsite.step = 0;
        $scope.currentCategory = 'Entertainment';
        $rootScope.currentCategoryIndex = 0;

        $scope.refreshPage = function () {
            window.window.location.href = '/?InviteYourFriends';
        };
        $scope.setCustomStep = function (i) {
            if (i == 2)
                $.colorbox.resize({ width: "75%" });

            $scope.customStep = i;
            $rootScope.$broadcast('dataloaded');
            $scope.$watch('$compile', function () {
                $rootScope.$broadcast('dataloaded');
            });
        };

        $scope.resizeModal = function () {
            $.colorbox.resize({ width: "910px" });
        };

        $scope.nextCustomStep = function () {
            $scope.setCustomStep($scope.customStep + 1);
        };
        $scope.prevCustomStep = function () {
            $scope.setCustomStep($scope.customStep - 1);
        };

        $scope.defaultHomepage = function () {
            $http.post('/REST/UserWidget/CreateDefault', { cache: false })
                .success(function (data, status, headers, config) {
                    $scope.refreshPage();
                })
                .error(function (data, status, headers, config) {
                });
        };

        // Custom events for myWebsite
        $scope.custom.mywebsite.selectCategory = function (i, id) {
            $scope.currentCategory = $rootScope.websitesCategories[i].title;
            $rootScope.currentCategoryIndex = i;
            $scope.custom.mywebsite.step = i;
            $timeout(function () {
                $.colorbox.resize({ height: $(".hold-modal").height() + 75 });
            }, 200);
            //if ($scope.custom.mywebsite.step > i) {
            //    $scope.custom.mywebsite.step = i;
            //}
        };
        $scope.custom.mywebsite.nextStep = function () {
            $scope.custom.mywebsite.step++;
            $scope.currentCategory = $rootScope.websitesCategories[$scope.custom.mywebsite.step].title;
            $timeout(function () {
                $.colorbox.resize({ height: $(".hold-modal").height() + 75 });
            }, 200);
        };
        $scope.custom.mywebsite.prevStep = function () {
            $scope.custom.mywebsite.step--;
            $scope.currentCategory = $rootScope.websitesCategories[$scope.custom.mywebsite.step].title;
            $timeout(function () {
                $.colorbox.resize({ height: $(".hold-modal").height() + 75 });
            }, 200);
        };

        $scope.toggleCustomWebsite = function () {
            $scope.customWebsiteDisplay = !$scope.customWebsiteDisplay;
            $rootScope.$broadcast('dataloaded');
        };
    }])

    .controller('EmailCtrl', ['$scope', '$http', '$rootScope', function ($scope, $http, $rootScope) {
        $rootScope.loadWidget();
    }])

    .controller('EmailFeedCtrl', ['$scope', '$http', '$rootScope', function ($scope, $http, $rootScope) {
        $scope.wasLoaded = false;
        try {
            gapi.auth.init(function () { });
        } catch (e) { }
        $scope.userEmailFeed = $rootScope.userEmailFeed || [];
        $scope.userHasEmailAccount = true;

        $scope.providers = [
            { name: 'Gmail', image: 'gmail.gif', serverType: 'GMAIL' }
            //, { name: 'Live', image: 'hotmail.gif', serverType: 'HOTMAIL' }
            // , { name: 'YahooMail', image: 'yahoo.gif', serverType: 'YAHOO' }
        ];

        $rootScope.checkEmailAccount = $scope.checkEmailAccount = function () {
            $http.get('/REST/UserWidgetEmail/?m=' + (new Date()).getMilliseconds())
                .success(function (data, status, headers, config) {
                    if (data.length > 0) {
                        if (data.username != undefined) {
                            $scope.userHasEmailAccount = true;
                            $scope.$parent.widget.userHasEmailAccount = true;
                            $rootScope.serverType = data.serverType;
                            switch (data.serverType) {
                                case 'GMAIL':
                                    $scope.$parent.widget.webmailUrl = $scope.webmailUrl = 'http://www.gmail.com/';
                                    gapi.auth.authorize({ client_id: _googleConfig.clientId, scope: [_googleConfig.scopes.email, _googleConfig.scopes.feed], immediate: true }, $scope.handleGmailAuthResult);
                                    break;
                                case 'HOTMAIL':
                                    $scope.$parent.widget.webmailUrl = $scope.webmailUrl = 'http://www.outlook.com/';
                                    break;
                                case 'YAHOO':
                                    $scope.$parent.widget.webmailUrl = $scope.webmailUrl = 'http://mail.yahoo.com/';
                                    break;
                            }
                            //$scope.loadEmailFeed();
                        } else {
                            $scope.$parent.widget.webmailUrl = '';
                            $scope.$parent.widget.userHasEmailAccount = false;
                            $scope.userHasEmailAccount = false;
                            $rootScope.loadWidget();
                        }
                    } else {
                        $scope.userHasEmailAccount = false;
                        $scope.wasLoaded = true;
                        $rootScope.loadWidget();
                    }
                });
        }

        $scope.setServerType = function (serverType) {
            $rootScope.serverType = serverType;
        };

        $scope.handleGmailAuthResult = function (authResult) {
            if (authResult != null) {
                if (authResult && !authResult.error) {
                    gapi.client.load('oauth2', 'v2', function () {
                        var request = gapi.client.oauth2.userinfo.v2.me.get({
                            'fields': 'email'
                        });
                        request.execute(function (resp) {
                            var gdata = { token: authResult.access_token, email: resp.email };
                            $http.get('/rest/gmail', { params: gdata })
                                .success(function (data, status, headers, config) {
                                    if (data) {
                                        $scope.userEmailFeed = $rootScope.userEmailFeed = data;
                                        $rootScope.$broadcast('dataloaded');
                                        $scope.userHasEmailAccount = true;
                                        $scope.wasLoaded = true;
                                    } else {
                                        $scope.userHasEmailAccount = false;
                                    }
                                });
                        });
                    });
                } else {
                    // authorizeButton.style.visibility = '';
                    // authorizeButton.onclick = handleAuthClick;
                }
            } else {
                $scope.userHasEmailAccount = false;
                $scope.wasLoaded = true;
            }
        };

        $scope.setEmailAccount = function (serverType) {

            $scope.account = { username: 'oauth', password: '', serverType: serverType };
            $scope.wasLoaded = false;

            switch (serverType) {
                case 'GMAIL':
                    gapi.auth.authorize({
                        client_id: _googleConfig.clientId,
                        scope: [_googleConfig.scopes.email, _googleConfig.scopes.feed],
                        immediate: false
                    }, $scope.handleGmailAuthResult);

                    $http.post('/REST/UserWidgetEmail/Save', $scope.account)
                    .success(function (data, status, headers, config) {
                        if (!data.status) {
                            $scope.loginMessage = data.response;
                        }
                    });

                    return false;
                case 'HOTMAIL':
                    $scope.wasLoaded = true;
                    alert('Account Yahoo');
                    break;
                case 'YAHOO':
                    $scope.wasLoaded = true;
                    alert('Account Live');
                    break;
            }
        };

        $scope.loadEmailFeed = function () {
            $scope.userEmailFeed = [];
            $scope.wasLoaded = false;
            $http.get('/REST/UserWidgetEmail/Feed?m=' + (new Date()).getMilliseconds())
                .success(function (data, status, headers, config) {
                    if (data != null) {
                        if (data.status) {
                            $scope.userEmailFeed = $rootScope.userEmailFeed = $.parseJSON(data.response);
                            $rootScope.$broadcast('dataloaded');
                        } else {
                            $scope.userHasEmailAccount = false;
                            $scope.wasLoaded = true;
                        }
                    }
                    //$scope.wasLoaded = true;
                    // $rootScope.loadWidget();
                });
        };

        $scope.checkEmailAccount();
    }])


    .controller('EmailAccountCtrl', ['$scope', '$http', '$rootScope', function ($scope, $http, $rootScope) {
        $scope.canDeleted = false;
        $scope.loginMessage = '';
        $scope.account = { username: '', password: '', serverType: $rootScope.serverType };

        switch ($rootScope.serverType) {
            case "GMAIL":
                $scope.provider = "Gmail";
                $scope.provider_image = "gmail.gif";
                break;
            case "HOTMAIL":
                $scope.provider = "Live";
                $scope.provider_image = "hotmail.gif";
                break;
            case "YAHOO":
                $scope.provider = "Yahoo Mail";
                $scope.provider_image = "yahoo.gif";
                break;
        }

        $http.get('/REST/UserWidgetEmail/?m=' + (new Date()).getMilliseconds())
            .success(function (data, status, headers, config) {
                if (data != undefined) {
                    if (data.username != undefined) {
                        $scope.canDeleted = true;
                        $scope.account = data;
                    }
                }
            })
            .error(function (data, status, headers, config) {

            });

        // $scope.login = function () {
        $scope.login = function () {
            $http.post('/REST/UserWidgetEmail/Save', $scope.account)
                .success(function (data, status, headers, config) {
                    if (data.status) {
                        $rootScope.userEmailFeed = $.parseJSON(data.response);
                        $rootScope.checkEmailAccount();
                        $.colorbox.close();

                    } else {
                        $scope.loginMessage = data.response;
                    }
                });
        }

        $scope.delete = function () {
            $http.post('/REST/UserWidgetEmail/Delete')
            .success(function (data, status, headers, config) {
                if (data.status) {
                    $rootScope.userEmailFeed = [];
                    $rootScope.userHasEmailAccount = false;
                    $rootScope.checkEmailAccount();
                    $.colorbox.close();
                } else {
                    $scope.loginMessage = data.response;
                }
            });
        }

    }])

    .controller('SuggestionCtrl', ['$scope', '$http', '$rootScope', function ($scope, $http, $rootScope) {
        $scope.currentPage = 0;
        $scope.limitSuggestions = 5;
        $scope.suggestions = [];
        var remainingSuggestion = [];
        if (typeof (Storage) !== "undefined") {
            if (localStorage != undefined || localStorage != "undefined") {
                if (localStorage.remainingSuggestion != undefined) {
                    remainingSuggestion = JSON.parse(localStorage.remainingSuggestion);
                    localStorage.removeItem("remainingSuggestion");
                }
            }
        }
        /*
        $http.get('/REST/SuggestionBox?m=' + (new Date()).getMilliseconds())
            .success(function (data, status, headers, config) {
                //$scope.suggestions = data.splice(0, 3);
                $scope.suggestions = data;
                $rootScope.$broadcast('dataloaded');
            });
            */
        $scope.suggestions = _page.suggestions;
        if (remainingSuggestion != undefined && remainingSuggestion.length > 0)
            $scope.suggestions = remainingSuggestion;
        $rootScope.$broadcast('dataloaded');

        $scope.numberOfPages = function () {
            return Math.ceil($scope.suggestions.length / $scope.limitSuggestions);
        }

        $scope.$on('removeSuggestion', function (e) {
            $scope.suggestions = _.without($scope.suggestions, _.findWhere($scope.suggestions, { Id: $rootScope.selectedSuggestionBoxId }));
            $scope.$broadcast('closeColorbox');
            $('#closeModal').trigger('click');
        });

        $scope.setSelected = function (id) {
            $rootScope.selectedSuggestionBoxId = id;
        };


        $rootScope.reloadSuggestions = $scope.reloadSuggestions = function () {
            $http.get('/REST/SuggestionBox')
                .success(function (data, status, headers, config) {
                    _page.suggestions = data;
                    $scope.suggestions = _page.suggestions;
                    $rootScope.$broadcast('dataloaded');
                });
        }


        $scope.ignore = function (o) {
            $scope.suggestions = _.without($scope.suggestions, o);

            o.register = '';
            o.lastupdate = '';
            o.deleted = '';

            $http.post('/REST/SuggestionBox/Ignore', o)
            .success(function (data, status, headers, config) {
                //$scope.suggestions = data.splice(0, 3);
                //$rootScope.reloadSuggestions();

            });
            ////back to first page
            //if ($scope.suggestions.length <= 5) {
            //    $scope.currentPage = $scope.currentPage - 1;
            //}

        };
    }])

    .controller('AddSuggestionCtrl', ['$scope', '$http', '$rootScope', function ($scope, $http, $rootScope) {
        $scope.feedbackSuggestion = { status: false, msg: '' };
        $scope.widgets = [];
        $scope.suggestionBoxWidgetId = 0;
        $scope.suggestionBoxWidgetVisible = false;
        $scope.suggestionBoxWidgetTitle = 'New Frame +';
        $scope.widgets.push({ id: 0, title: '<< New Frame >>' });
        $scope.setSuggestionBoxWidgetId = function (widgetId, widgetTitle) {
            if (widgetId)
                $scope.suggestionBoxWidgetTitle = widgetTitle;
            else
                $scope.suggestionBoxWidgetTitle = 'New Frame +';

            $scope.suggestionBoxWidgetId = widgetId;
            $scope.suggestionBoxWidgetVisible = false;
        }

        for (var iws = 0; iws < $rootScope.widgets.length; iws++) {
            if ($rootScope.widgets[iws].typeId == 2) {
                $scope.widgets.push($rootScope.widgets[iws]);
            }
        }

        $scope.submit = function () {
            var url = '/REST/UserWidgetBookmark/AddSuggestionBox/' + $rootScope.selectedSuggestionBoxId;

            $scope.clickSubmit = false;
            $scope.feedbackSuggestion.status = 'success';
            $scope.feedbackSuggestion.msg = 'Sending data...';
            $scope.$broadcast('dataloaded');
            var objData = {
                id: $scope.suggestionBoxWidgetId,
                title: 'Websites'
            };
            $http.post(url, objData)
               .success(function (data, status, headers, config) {
                   if (data.status) {
                       $scope.$emit('removeSuggestion');
                       $scope.feedbackSuggestion.msg = 'OK';
                       if ($scope.suggestionBoxWidgetId === 0) {
                           $rootScope.addWidgetLast(data.response);
                       } else {
                           $('.list-gridster .box-column').each(function (i, e) {
                               if ($(e).attr('data-widget') == $scope.suggestionBoxWidgetId) {
                                   if ($rootScope.$gridster != null)
                                       $rootScope.$gridster.remove_widget(e);

                               }
                           });

                           LoadBehaviorCaller['dataload-' + $scope.suggestionBoxWidgetId] = undefined;
                           _page.userWidgetBookmark[('items_' + $scope.suggestionBoxWidgetId)] = undefined;
                           $rootScope.attWidget($scope.suggestionBoxWidgetId, data.response);
                           $rootScope.loadDragWidgets($scope.suggestionBoxWidgetId);
                       }
                       if (typeof (Storage) !== "undefined") {

                           if (localStorage != undefined) {
                               localStorage.setItem("remainingSuggestion", JSON.stringify($scope.suggestions));
                           }
                       }

                       //         $rootScope.reloadSuggestions();
                       $scope.$broadcast('closeColorbox');
                       $('#closeModal').trigger('click');
                       location.reload();

                   } else {
                       $scope.feedbackSuggestion = false;
                       $scope.feedbackSuggestion.msg = data.response;
                   }
               })
                .error(function (data, status, headers, config) {
                    $scope.feedbackSuggestion = false;
                    $scope.feedbackSuggestion.msg = data.response;
                });
        };
    }])

    .controller('ChatCtrl', ['$scope', '$http', '$rootScope', 'xsocket', function ($scope, $http, $rootScope, xsocket) {
        $scope.users = [];

        if (typeof _userName === 'string') {
            //$scope.$apply(function () {
            //    Candy.Core.connect(_chatUrl, null, _userName);
            //});
        }
    }])

    // Controller for AddAsHomePageCtrl
    .controller('AddAsHomePageCtrl', ['$timeout', '$scope', function ($timeout, $scope) {
        $scope.browser;

        $.browser.chrome = $.browser.webkit && !!window.chrome;
        $.browser.safari = $.browser.webkit && !window.chrome;
        $scope.homepageImgWidth = 0;

        if ($.browser.mozilla) {
            $scope.browser = "mozilla";
        }

        else if ($.browser.chrome) {
            $scope.browser = "chrome";
        }

        else if ($.browser.safari) {
            $scope.browser = "safari";
        }

        else if ($.browser.msie) {
            $scope.browser = "msie";
        }
        //initiate an array to hold all active Questions
        $scope.activeHPageQs = [];

        $scope.currentHPageTab = 'AddAsHome.tpl.html';

        //check if the Question is active
        $scope.isOpenHPageQ = function (question) {
            //check if this question is already in the activeQs array
            if ($scope.activeHPageQs.indexOf(question) > -1) {
                $scope.homepageImgWidth = (($(".accord_container").width() - 20) / 2) * 60 / 100;
                //if so, return true                      
                return true;
            } else {
                //if not, return false
                return false;
            }
        }
        //function to 'open' a question
        $scope.openHPageQ = function (question) {
            //check if question is already open
            if ($scope.isOpenHPageQ(question)) {
                //if it is, remove it from the activeQs array
                $scope.activeHPageQs.splice($scope.activeHPageQs.indexOf(question), 1);
                $timeout(function () {
                    $.colorbox.resize({ height: $(".hold-modal").height() + 50 });
                }, 200);
            } else {
                //if it's not, add it!
                $scope.activeHPageQs.push(question);
                $timeout(function () {
                    $.colorbox.resize({ height: $(".hold-modal").height() + 50 });
                }, 200);
            }
        }
        $scope.$broadcast('dataloaded');
    }])

     .controller('FAQsCtrl', ['$timeout', '$scope', function ($timeout, $scope) {
         //initiate an array to hold all active Questions
         $scope.activeQs = [];
         $scope.faqImgWidth = 0;
         $scope.tabs = [{
             title: 'Registration',
             url: 'Registration.tpl.html'
         }, {
             title: 'Frames',
             url: 'Frames.tpl.html'
         }, {
             title: 'Misc',
             url: 'Misc.tpl.html'
         }];

         $scope.currentTab = 'Registration.tpl.html';

         $scope.onClickTab = function (tab) {
             $scope.activeQs = [];
             $scope.currentTab = tab.url;
             $timeout(function () {
                 $.colorbox.resize({ height: $(".hold-modal").height() + 90 });
             }, 200);
         }

         $scope.isActiveTab = function (tabUrl) {
             $scope.faqImgWidth = (($(".accordion_container").width() - 20) / 2) * 60 / 100;
             return tabUrl == $scope.currentTab;
         }

         //check if the Question is active
         $scope.isOpenQ = function (question) {
             //check if this question is already in the activeQs array
             if ($scope.activeQs.indexOf(question) > -1) {
                 //if so, return true
                 return true;
             } else {
                 //if not, return false
                 return false;
             }
         }
         //function to 'open' a question
         $scope.openQ = function (question) {
             //check if question is already open
             if ($scope.isOpenQ(question)) {
                 //if it is, remove it from the activeQs array
                 $scope.activeQs.splice($scope.activeQs.indexOf(question), 1);
                 $timeout(function () {
                     $.colorbox.resize({ height: $(".hold-modal").height() + 90 });
                 }, 200);
             } else {
                 //if it's not, add it!
                 $scope.activeQs.push(question);
                 $timeout(function () {
                     $.colorbox.resize({ height: $(".hold-modal").height() + 90 });
                 }, 200);
             }
         }
     }])
    // Controller for Welcome Modal
    .controller('WelcomeModal', ['$scope', function ($scope) {
        //$scope.step = 1;
    }]);
'use strict';

/* Filters */

angular.module('App.filters', [])
    .filter('interpolate', function (version) {
        return function (text) {
            return String(text).replace(/\%VERSION\%/mg, version);
        };
    })
    .filter('pubdate', function () {
        return function (value) {
            var date = new Date(Date(value));
            return date.toISOString();
        };
    })
    .filter('formatDate', function () {
        return function (date) {
            return moment(date).format('MM/D/YYYY - hh:mm a');
        };
    })
    .filter('numberForString', function () {
        return function (value) {
            switch (value) {
                case 1:
                    return 'one';
                case 2:
                    return 'two';
                case 3:
                    return 'three';
            }
        };
    })
    .filter('categoryWidget', function () {
        return function (value) {
            switch (value) {
                case 1:
                    return 'Feed';
                case 2:
                    return 'Bookmark';
            }
        };
    })
    .filter('sizeLightbox', function () {
        return function (value) {
            switch (value) {
                case 1:
                    return '80%';
                case 2:
                    return '60%';//return '800';
                default:
                    return '80%';
            }
        };
    })
    .filter('linkService', function () {
        return function (value) {
            switch (value) {
                case 1:
                    return '/Templates/MoreFeed.html';
                case 2:
                    return '/Templates/MoreMyWebsite.html';
            }
        };
    })
    .filter('countCheckeds', function () {
        return function (inputs) {
            var cont = 0;
            angular.forEach(inputs, function (item) {
                if (item.chk)
                    cont++;
            });
            return cont;
        };
    })
    .filter('escape', function () {
        return window.escape;
    })
    .filter('startFrom', function () {
        return function (input, start) {
            start = +start; //parse to int
            try {
                return input.slice(start);
            } catch (e) { return null; }
        }
    });
'use strict';

/* Animate */
angular.module('App.animate', [])
    .animation('animateSliderLeft', function () {
        return {
            setup: function (el) {
                el.width(0);
            },
            start: function (el) {
                el.animate({ width: 'auto' }, 500);
            }
        }
    })
;
'use strict';

//WL.Event.subscribe("auth.login", onLogin);
//alert("liveid : " + _authConfig.live.client_id);
WL.init({
    client_id: _authConfig.live.client_id,
    redirect_uri: window.location.origin + _authConfig.live.redirect_url,
    scope: ["wl.signin", "wl.basic", "wl.emails", "wl.contacts_emails"],
    response_type: "code"
});
//WL.ui({
//    name: "signin",
//    element: "signin"
//});

function onLogin(session) {
    if (!session.error) {
        WL.api({
            path: "me",
            method: "GET"
        }).then(
            function (response) {
                // console.info("Hello, " + response.first_name + " " + response.last_name + "!");
            },
            function (responseFailed) {
                console.error("Error calling API: " + responseFailed.error.message);
            }
        );
    }
    else {
        console.error("Error signing in: " + session.error_description);
    }
}

function onGoogleApiLoad() {
    gapi.client.setApiKey(_googleConfig.api_key);
}

// Declare app level module which depends on filters, and services
var App = angular.module('App', [
    'XSockets',
    'ngRoute',
    'ngAnimate',
    //'ngMobile',
    'App.controllers',
    'App.filters',
    'App.services',
    'App.directives',
    'angular-underscore'
]).run(['$rootScope', function ($rootScope) {
    $rootScope.now = new Date();

    if ((typeof _userName === 'string' || typeof _userEmail === 'string') && _currentEnvironment == 'sandbox') {
        Candy.init(_chatCoreUrl, {
            core: { debug: false, autojoin: [_chatRoom] },
            view: { resources: '/Img/Default/' }
        }); //take65@conference.kwwcws / tak65@conference.amazona-kd5nje2

        Candy.Core.connect(_chatUrl, null, _userName || _userEmail.split('@')[0]);
    }
}]).config(function ($routeProvider, $locationProvider) {
    $routeProvider
        .when('/', {})
          .otherwise({
              redirectTo: '/'
          });

    $locationProvider.html5Mode(false);
});
